
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">usl-server/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">usl-server/internal/auth/discord.go (0.0%)</option>
				
				<option value="file2">usl-server/internal/config/config.go (0.0%)</option>
				
				<option value="file3">usl-server/internal/config/environments.go (0.0%)</option>
				
				<option value="file4">usl-server/internal/handlers/guild_handler.go (0.0%)</option>
				
				<option value="file5">usl-server/internal/handlers/tracker_handler.go (0.0%)</option>
				
				<option value="file6">usl-server/internal/handlers/trueskill_handler.go (0.0%)</option>
				
				<option value="file7">usl-server/internal/handlers/user_handler.go (0.0%)</option>
				
				<option value="file8">usl-server/internal/logger/logger.go (0.0%)</option>
				
				<option value="file9">usl-server/internal/middleware/guild_context.go (0.0%)</option>
				
				<option value="file10">usl-server/internal/middleware/logging.go (0.0%)</option>
				
				<option value="file11">usl-server/internal/middleware/notfound.go (0.0%)</option>
				
				<option value="file12">usl-server/internal/models/guild.go (0.0%)</option>
				
				<option value="file13">usl-server/internal/models/guild_config.go (0.0%)</option>
				
				<option value="file14">usl-server/internal/models/pagination.go (0.0%)</option>
				
				<option value="file15">usl-server/internal/models/player_effective_mmr.go (0.0%)</option>
				
				<option value="file16">usl-server/internal/models/player_historical_mmr.go (0.0%)</option>
				
				<option value="file17">usl-server/internal/models/tracker.go (0.0%)</option>
				
				<option value="file18">usl-server/internal/models/user.go (0.0%)</option>
				
				<option value="file19">usl-server/internal/models/user_guild_membership.go (0.0%)</option>
				
				<option value="file20">usl-server/internal/models/validation.go (0.0%)</option>
				
				<option value="file21">usl-server/internal/repositories/guild_repository.go (0.0%)</option>
				
				<option value="file22">usl-server/internal/repositories/tracker_repository.go (0.0%)</option>
				
				<option value="file23">usl-server/internal/repositories/user_repository.go (0.0%)</option>
				
				<option value="file24">usl-server/internal/services/data_transformation_service.go (32.0%)</option>
				
				<option value="file25">usl-server/internal/services/enhanced_uncertainty_calculator.go (98.9%)</option>
				
				<option value="file26">usl-server/internal/services/mmr_calculator.go (79.4%)</option>
				
				<option value="file27">usl-server/internal/services/percentile_converter.go (86.0%)</option>
				
				<option value="file28">usl-server/internal/services/permission_service.go (0.0%)</option>
				
				<option value="file29">usl-server/internal/services/trueskill_service.go (12.9%)</option>
				
				<option value="file30">usl-server/internal/usl/handlers/migration_handler.go (2.9%)</option>
				
				<option value="file31">usl-server/internal/usl/handlers/v2_trackers_handler.go (0.0%)</option>
				
				<option value="file32">usl-server/internal/usl/handlers/v2_users_handler.go (0.0%)</option>
				
				<option value="file33">usl-server/internal/usl/models.go (0.0%)</option>
				
				<option value="file34">usl-server/internal/usl/repository.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "html/template"
        "log"
        "log/slog"
        "net/http"
        "os"
        "path/filepath"
        "usl-server/internal/auth"
        "usl-server/internal/config"
        "usl-server/internal/handlers"
        "usl-server/internal/logger"
        "usl-server/internal/middleware"
        "usl-server/internal/repositories"
        "usl-server/internal/services"
        usl "usl-server/internal/usl"
        uslHandlers "usl-server/internal/usl/handlers"

        "github.com/supabase-community/supabase-go"
)

type AppDependencies struct {
        Config           *config.Config
        UserRepo         *repositories.UserRepository
        TrackerRepo      *repositories.TrackerRepository
        GuildRepo        *repositories.GuildRepository
        TrueSkillService *services.UserTrueSkillService
        Templates        *template.Template
        Logger           *slog.Logger
        Auth             *auth.DiscordAuth
}

func main() <span class="cov0" title="0">{
        // Setup logging first - write to both stdout AND log file
        appLogger := logger.SetupLogger(slog.LevelDebug, "logs/server.log")
        appLogger.Info("Starting USL server application")

        dependencies := initializeApplication(appLogger)
        server := setupHTTPServer(dependencies)
        startServer(server, dependencies.Config, dependencies.Logger)
}</span>

func initializeApplication(appLogger *slog.Logger) *AppDependencies <span class="cov0" title="0">{
        configuration := loadConfiguration(appLogger)
        supabaseClient := createSupabaseClient(configuration, appLogger)
        repositories := setupRepositories(supabaseClient, configuration, appLogger)
        services := setupServices(configuration, repositories, appLogger)
        templates := loadTemplates(appLogger)

        // Create unified Discord OAuth auth system
        discordAuth := auth.NewDiscordAuth(supabaseClient, configuration.USL.AdminDiscordIDs,
                configuration.Supabase.URL, configuration.Supabase.PublicURL, configuration.Supabase.AnonKey)

        return &amp;AppDependencies{
                Config:           configuration,
                UserRepo:         repositories.UserRepo,
                TrackerRepo:      repositories.TrackerRepo,
                GuildRepo:        repositories.GuildRepo,
                TrueSkillService: services,
                Templates:        templates,
                Logger:           appLogger,
                Auth:             discordAuth,
        }
}</span>

func loadConfiguration(logger *slog.Logger) *config.Config <span class="cov0" title="0">{
        logger.Info("Loading configuration")
        configuration, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to load configuration", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Info("Configuration loaded successfully")
        return configuration</span>
}

func createSupabaseClient(configuration *config.Config, logger *slog.Logger) *supabase.Client <span class="cov0" title="0">{
        logger.Info("Initializing Supabase client", "url", configuration.Supabase.URL)
        client, err := supabase.NewClient(
                configuration.Supabase.URL,
                configuration.Supabase.ServiceRoleKey,
                nil,
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to initialize Supabase client", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">logger.Info("Supabase client initialized successfully")
        return client</span>
}

type RepositoryCollection struct {
        UserRepo    *repositories.UserRepository
        TrackerRepo *repositories.TrackerRepository
        GuildRepo   *repositories.GuildRepository
}

func setupRepositories(client *supabase.Client, config *config.Config, logger *slog.Logger) *RepositoryCollection <span class="cov0" title="0">{
        logger.Info("Setting up repositories")
        return &amp;RepositoryCollection{
                UserRepo:    repositories.NewUserRepository(client, config),
                TrackerRepo: repositories.NewTrackerRepository(client, config),
                GuildRepo:   repositories.NewGuildRepository(client, config),
        }
}</span>

func setupServices(config *config.Config, repos *RepositoryCollection, logger *slog.Logger) *services.UserTrueSkillService <span class="cov0" title="0">{
        logger.Info("Setting up services")
        percentileConverter := services.NewPercentileConverter(config)
        mmrCalculator := services.NewMMRCalculator(config, percentileConverter)
        uncertaintyCalculator := services.NewEnhancedUncertaintyCalculator(config)
        dataTransformationService := services.NewDataTransformationService()

        return services.NewUserTrueSkillService(
                repos.TrackerRepo,
                repos.UserRepo,
                mmrCalculator,
                uncertaintyCalculator,
                dataTransformationService,
                config,
        )
}</span>

func loadTemplates(logger *slog.Logger) *template.Template <span class="cov0" title="0">{
        logger.Info("Loading templates")

        // Load all templates from our new nested structure
        tmpl := template.New("app")

        // Add template functions
        tmpl = tmpl.Funcs(template.FuncMap{
                "dict": func(values ...interface{}) map[string]interface{} </span><span class="cov0" title="0">{
                        dict := make(map[string]interface{})
                        for i := 0; i &lt; len(values); i += 2 </span><span class="cov0" title="0">{
                                if i+1 &lt; len(values) </span><span class="cov0" title="0">{
                                        dict[values[i].(string)] = values[i+1]
                                }</span>
                        }
                        <span class="cov0" title="0">return dict</span>
                },
                "slice": func(values ...interface{}) []interface{} <span class="cov0" title="0">{
                        return values
                }</span>,
                "add": func(a, b int) int <span class="cov0" title="0">{
                        return a + b
                }</span>,
                "sub": func(a, b float64) float64 <span class="cov0" title="0">{
                        return a - b
                }</span>,
                "mul": func(a, b float64) float64 <span class="cov0" title="0">{
                        return a * b
                }</span>,
                "printf": func(format string, args ...interface{}) string <span class="cov0" title="0">{
                        return fmt.Sprintf(format, args...)
                }</span>,
                "lt": func(a, b float64) bool <span class="cov0" title="0">{
                        return a &lt; b
                }</span>,
        })

        // Parse all template files
        <span class="cov0" title="0">patterns := []string{
                "templates/partials/*.html",
                "templates/components/*.html",
                "templates/fragments/*.html",
                "templates/pages/*.html",
        }

        for _, pattern := range patterns </span><span class="cov0" title="0">{
                matches, err := filepath.Glob(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to glob templates", "pattern", pattern, "error", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">if len(matches) &gt; 0 </span><span class="cov0" title="0">{
                        logger.Info("Loading templates", "pattern", pattern, "count", len(matches))
                        tmpl = template.Must(tmpl.ParseFiles(matches...))
                }</span>
        }

        <span class="cov0" title="0">logger.Info("Templates loaded successfully")
        return tmpl</span>
}

func setupHTTPServer(deps *AppDependencies) http.Handler <span class="cov0" title="0">{
        mux := http.NewServeMux()

        setupStaticRoutes(mux)
        setupAuthRoutes(mux, deps) // Unified Discord OAuth routes
        setupHomeRoute(mux)
        setupGuildAwareRoutes(mux, deps) // New guild-aware routes
        setupUserRoutes(mux, deps)       // Legacy routes
        setupTrackerRoutes(mux, deps)    // Legacy routes
        setupTrueSkillRoutes(mux, deps)  // Legacy routes
        setupAPIRoutes(mux, deps)
        setupUSLRoutes(mux, deps) // USL-specific temporary migration routes

        // Create guild context middleware
        guildMiddleware := middleware.NewGuildContextMiddleware(deps.GuildRepo, deps.Logger)

        // Apply middleware chain
        handler := middleware.LoggingMiddleware(deps.Logger)(mux)
        handler = guildMiddleware.GuildContext()(handler)

        return handler
}</span>

func setupStaticRoutes(mux *http.ServeMux) <span class="cov0" title="0">{
        mux.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("static/"))))
}</span>

func setupGuildAwareRoutes(mux *http.ServeMux, deps *AppDependencies) <span class="cov0" title="0">{
        // Create new guild-aware handlers
        userHandler := handlers.NewUserHandler(deps.UserRepo, deps.Templates)

        // Guild-specific user management routes
        // Format: /{guild-slug}/users...
        mux.HandleFunc("/usl/users", deps.Auth.RequireAuth(userHandler.ListUsers))
        mux.HandleFunc("/usl/users/", deps.Auth.RequireAuth(userHandler.ListUsers)) // Handle search queries
        mux.HandleFunc("/usl/users/new", deps.Auth.RequireAuth(userHandler.NewUserForm))
        mux.HandleFunc("/usl/users/create", deps.Auth.RequireAuth(userHandler.CreateUser))
        mux.HandleFunc("/usl/users/edit", deps.Auth.RequireAuth(userHandler.EditUserForm))
        mux.HandleFunc("/usl/users/update", deps.Auth.RequireAuth(userHandler.UpdateUser))
        mux.HandleFunc("/usl/users/delete", deps.Auth.RequireAuth(userHandler.DeleteUser))

        // HTMX Fragment endpoints
        mux.HandleFunc("/usl/api/users/table", deps.Auth.RequireAuth(userHandler.ListUsers))
        mux.HandleFunc("/usl/api/users/search", deps.Auth.RequireAuth(userHandler.SearchUsers))

        // TODO: Add tracker and trueskill routes in similar pattern
        // TODO: Add support for dynamic guild slugs instead of hardcoded "usl"
}</span>

func setupAuthRoutes(mux *http.ServeMux, deps *AppDependencies) <span class="cov0" title="0">{
        // Unified Discord OAuth routes for both main app and USL
        mux.HandleFunc("/login", deps.Auth.LoginForm)
        mux.HandleFunc("/usl/login", deps.Auth.LoginForm) // USL uses same login
        mux.HandleFunc("/auth/callback", deps.Auth.AuthCallback)
        mux.HandleFunc("/auth/process", deps.Auth.ProcessTokens)
        mux.HandleFunc("/logout", deps.Auth.Logout)
        mux.HandleFunc("/usl/logout", deps.Auth.Logout) // USL uses same logout
}</span>

func setupHomeRoute(mux *http.ServeMux) <span class="cov0" title="0">{
        mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.URL.Path != "/" </span><span class="cov0" title="0">{
                        // This is an unmatched route, show custom 404
                        w.WriteHeader(http.StatusNotFound)
                        w.Header().Set("Content-Type", "text/html; charset=utf-8")

                        // Simple inline 404 for now - could use template later
                        html := `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;404 - Page Not Found&lt;/title&gt;&lt;/head&gt;
&lt;body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;"&gt;
&lt;h1&gt;404 - Page Not Found&lt;/h1&gt;
&lt;p&gt;The page you're looking for doesn't exist.&lt;/p&gt;
&lt;a href="/" style="color: #007cba;"&gt;‚Üê Go Home&lt;/a&gt; | 
&lt;a href="/usl/admin" style="color: #007cba;"&gt;USL Admin&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;`
                        w.Write([]byte(html))
                        return
                }</span>
                <span class="cov0" title="0">http.Redirect(w, r, "/users", http.StatusSeeOther)</span>
        })
}

func setupUserRoutes(mux *http.ServeMux, deps *AppDependencies) <span class="cov0" title="0">{
        // Legacy routes - redirect to guild-aware routes
        mux.HandleFunc("/users", deps.Auth.RequireAuth(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/usl/users", http.StatusMovedPermanently)
        }</span>))
        <span class="cov0" title="0">mux.HandleFunc("/users/new", deps.Auth.RequireAuth(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/usl/users/new", http.StatusMovedPermanently)
        }</span>))
        <span class="cov0" title="0">mux.HandleFunc("/users/create", deps.Auth.RequireAuth(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/usl/users/create", http.StatusMovedPermanently)
        }</span>))
        <span class="cov0" title="0">mux.HandleFunc("/users/edit", deps.Auth.RequireAuth(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/usl/users/edit", http.StatusMovedPermanently)
        }</span>))
        <span class="cov0" title="0">mux.HandleFunc("/users/update", deps.Auth.RequireAuth(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/usl/users/update", http.StatusMovedPermanently)
        }</span>))
        <span class="cov0" title="0">mux.HandleFunc("/users/delete", deps.Auth.RequireAuth(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/usl/users/delete", http.StatusMovedPermanently)
        }</span>))
        <span class="cov0" title="0">mux.HandleFunc("/users/search", deps.Auth.RequireAuth(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/usl/users/search", http.StatusMovedPermanently)
        }</span>))
}

func setupTrackerRoutes(mux *http.ServeMux, deps *AppDependencies) <span class="cov0" title="0">{
        trackerHandler := handlers.NewTrackerHandler(deps.TrackerRepo, deps.TrueSkillService, deps.Templates)

        // Main app tracker routes - protected by unified Discord OAuth
        mux.HandleFunc("/trackers", deps.Auth.RequireAuth(trackerHandler.ListTrackers))
        mux.HandleFunc("/trackers/new", deps.Auth.RequireAuth(trackerHandler.NewTrackerForm))
        mux.HandleFunc("/trackers/create", deps.Auth.RequireAuth(trackerHandler.CreateTracker))
        mux.HandleFunc("/trackers/edit", deps.Auth.RequireAuth(trackerHandler.EditTrackerForm))
        mux.HandleFunc("/trackers/update", deps.Auth.RequireAuth(trackerHandler.UpdateTracker))
        mux.HandleFunc("/trackers/delete", deps.Auth.RequireAuth(trackerHandler.DeleteTracker))
        mux.HandleFunc("/trackers/search", deps.Auth.RequireAuth(trackerHandler.SearchTrackers))
}</span>

func setupTrueSkillRoutes(mux *http.ServeMux, deps *AppDependencies) <span class="cov0" title="0">{
        trueskillHandler := handlers.NewTrueSkillHandler(deps.TrueSkillService, deps.Templates)

        // Main app TrueSkill routes - protected by unified Discord OAuth
        mux.HandleFunc("/trueskill/update-all", deps.Auth.RequireAuth(trueskillHandler.UpdateAllUserTrueSkill))
        mux.HandleFunc("/trueskill/update-user", deps.Auth.RequireAuth(trueskillHandler.UpdateUserTrueSkill))
        mux.HandleFunc("/trueskill/recalculate", deps.Auth.RequireAuth(trueskillHandler.RecalculateAllUserTrueSkill))
        mux.HandleFunc("/trueskill/stats", deps.Auth.RequireAuth(trueskillHandler.GetTrueSkillStats))
}</span>

func setupAPIRoutes(mux *http.ServeMux, deps *AppDependencies) <span class="cov0" title="0">{
        // v1 API handlers (legacy)
        userHandler := handlers.NewUserHandler(deps.UserRepo, deps.Templates)
        trackerHandler := handlers.NewTrackerHandler(deps.TrackerRepo, deps.TrueSkillService, deps.Templates)
        trueskillHandler := handlers.NewTrueSkillHandler(deps.TrueSkillService, deps.Templates)

        // v2 API handlers (modern with pagination, filtering, bulk operations)
        v2UsersHandler := uslHandlers.NewV2UsersHandler(deps.UserRepo)
        v2TrackersHandler := uslHandlers.NewV2TrackersHandler(deps.TrackerRepo)

        // v1 API routes - protected by unified Discord OAuth (legacy)
        mux.HandleFunc("/api/users", deps.Auth.RequireAuth(userHandler.ListUsersAPI))
        mux.HandleFunc("/api/trackers", deps.Auth.RequireAuth(trackerHandler.ListTrackersAPI))
        mux.HandleFunc("/api/trueskill/update-all", deps.Auth.RequireAuth(trueskillHandler.UpdateAllUserTrueSkillAPI))

        // v2 API routes - modern paginated APIs (protected by unified Discord OAuth)
        mux.HandleFunc("/api/v2/users", deps.Auth.RequireAuth(v2UsersHandler.HandleUsers))
        mux.HandleFunc("/api/v2/users/bulk", deps.Auth.RequireAuth(v2UsersHandler.HandleUsersBulk))
        mux.HandleFunc("/api/v2/trackers", deps.Auth.RequireAuth(v2TrackersHandler.HandleTrackers))
        mux.HandleFunc("/api/v2/trackers/bulk", deps.Auth.RequireAuth(v2TrackersHandler.HandleTrackersBulk))
}</span>

func setupUSLRoutes(mux *http.ServeMux, deps *AppDependencies) <span class="cov0" title="0">{
        // TEMPORARY: USL migration handler - will be deleted after migration
        // Create dedicated Supabase client for USL operations
        supabaseClient, err := supabase.NewClient(
                deps.Config.Supabase.URL,
                deps.Config.Supabase.ServiceRoleKey,
                nil,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create USL Supabase client: %v", err)
        }</span>

        <span class="cov0" title="0">uslRepo := usl.NewUSLRepository(supabaseClient, deps.Config, deps.Logger)
        // NOTE: USL handlers no longer need their own auth - they use the unified auth
        uslHandler := uslHandlers.NewMigrationHandler(uslRepo, deps.Templates, deps.TrueSkillService, deps.Config)

        // USL Main Routes (redirect to login or admin based on auth status)
        mux.HandleFunc("/usl/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if deps.Auth.IsAuthenticated(r) </span><span class="cov0" title="0">{
                        http.Redirect(w, r, "/usl/admin", http.StatusSeeOther)
                }</span> else<span class="cov0" title="0"> {
                        http.Redirect(w, r, "/usl/login", http.StatusSeeOther)
                }</span>
        })

        // USL User Management Routes (protected by unified Discord OAuth)
        <span class="cov0" title="0">mux.HandleFunc("/usl/users", deps.Auth.RequireAuth(uslHandler.ListUsers))
        mux.HandleFunc("/usl/users/search", deps.Auth.RequireAuth(uslHandler.SearchUsers))
        mux.HandleFunc("/usl/users/new", deps.Auth.RequireAuth(uslHandler.NewUserForm))
        mux.HandleFunc("/usl/users/create", deps.Auth.RequireAuth(uslHandler.CreateUser))
        mux.HandleFunc("/usl/users/edit", deps.Auth.RequireAuth(uslHandler.EditUserForm))
        mux.HandleFunc("/usl/users/update", deps.Auth.RequireAuth(uslHandler.UpdateUser))
        mux.HandleFunc("/usl/users/delete", deps.Auth.RequireAuth(uslHandler.DeleteUser))

        // USL Tracker Management Routes (protected by unified Discord OAuth)
        mux.HandleFunc("/usl/trackers", deps.Auth.RequireAuth(uslHandler.ListTrackers))
        mux.HandleFunc("/usl/trackers/new", deps.Auth.RequireAuth(uslHandler.NewTrackerForm))
        mux.HandleFunc("/usl/trackers/create", deps.Auth.RequireAuth(uslHandler.CreateTracker))

        // USL Admin Routes (protected by unified Discord OAuth)
        mux.HandleFunc("/usl/admin", deps.Auth.RequireAuth(uslHandler.AdminDashboard))
        mux.HandleFunc("/usl/import", deps.Auth.RequireAuth(uslHandler.ImportData))

        // USL API Routes (protected by unified Discord OAuth)
        mux.HandleFunc("/usl/api/users", deps.Auth.RequireAuth(uslHandler.ListUsersAPI))
        mux.HandleFunc("/usl/api/trackers", deps.Auth.RequireAuth(uslHandler.ListTrackersAPI))
        mux.HandleFunc("/usl/api/leaderboard", deps.Auth.RequireAuth(uslHandler.GetLeaderboardAPI))</span>
}

func startServer(server http.Handler, config *config.Config, logger *slog.Logger) <span class="cov0" title="0">{
        serverAddress := config.Server.Host + ":" + config.Server.Port

        logger.Info("Starting USL server",
                "address", serverAddress,
                "supabase_url", config.Supabase.URL)

        if err := http.ListenAndServe(serverAddress, server); err != nil </span><span class="cov0" title="0">{
                logger.Error("Server failed to start", "error", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strings"

        "github.com/supabase-community/supabase-go"
)

// DiscordAuth provides unified Discord OAuth authentication via Supabase Auth
// This replaces both the main app auth and USL auth systems
type DiscordAuth struct {
        supabaseClient  *supabase.Client
        adminDiscordIDs []string
        supabaseURL     string // Internal Supabase URL for backend calls
        publicURL       string // Public Supabase URL for OAuth redirects
        anonKey         string // Anon key for client-side operations
}

// NewDiscordAuth creates a new unified Discord authentication handler
func NewDiscordAuth(supabaseClient *supabase.Client, adminDiscordIDs []string, supabaseURL, publicURL, anonKey string) *DiscordAuth <span class="cov0" title="0">{
        return &amp;DiscordAuth{
                supabaseClient:  supabaseClient,
                adminDiscordIDs: adminDiscordIDs,
                supabaseURL:     supabaseURL,
                publicURL:       publicURL,
                anonKey:         anonKey,
        }
}</span>

// LoginForm displays the Discord OAuth login form
// This works for both main app and USL routes
func (a *DiscordAuth) LoginForm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Check if already authenticated
        <span class="cov0" title="0">if a.IsAuthenticated(r) </span><span class="cov0" title="0">{
                // Redirect based on the requested path
                if strings.HasPrefix(r.URL.Path, "/usl") </span><span class="cov0" title="0">{
                        http.Redirect(w, r, "/usl/admin", http.StatusSeeOther)
                }</span> else<span class="cov0" title="0"> {
                        http.Redirect(w, r, "/users", http.StatusSeeOther)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Build proper Supabase OAuth URL using configured public URL
        // Determine redirect URL based on context
        <span class="cov0" title="0">var redirectTo string
        if strings.HasPrefix(r.URL.Path, "/usl") </span><span class="cov0" title="0">{
                redirectTo = "http://127.0.0.1:8080/auth/callback?redirect=usl"
        }</span> else<span class="cov0" title="0"> {
                redirectTo = "http://127.0.0.1:8080/auth/callback?redirect=main"
        }</span>

        <span class="cov0" title="0">discordOAuthURL := fmt.Sprintf("%s/auth/v1/authorize?provider=discord&amp;redirect_to=%s",
                a.publicURL, redirectTo)

        // Render login form with Discord OAuth button
        html := fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Sign In&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .login-container {
            background-color: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 400px;
            width: 100%%;
            text-align: center;
        }
        h2 {
            color: #333;
            margin-bottom: 20px;
        }
        .discord-btn {
            display: inline-block;
            width: 100%%;
            padding: 15px;
            background-color: #5865F2;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .discord-btn:hover {
            background-color: #4752C4;
        }
        .info {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        .error {
            color: red;
            margin-bottom: 20px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="login-container"&gt;
        &lt;h2&gt;Sign In&lt;/h2&gt;
        &lt;div class="info"&gt;Sign in with Discord to access the application.&lt;/div&gt;
        %s
        &lt;a href="%s" class="discord-btn"&gt;
            üéÆ Sign in with Discord
        &lt;/a&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`, a.getErrorMessage(r), discordOAuthURL)

        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.Write([]byte(html))</span>
}

// AuthCallback handles the OAuth callback from Supabase
// This is a unified callback for both main app and USL
func (a *DiscordAuth) AuthCallback(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Extract session tokens from URL fragment using JavaScript
        redirectParam := r.URL.Query().Get("redirect")
        var finalRedirect string

        switch redirectParam </span>{
        case "usl":<span class="cov0" title="0">
                finalRedirect = "/usl/admin"</span>
        case "main":<span class="cov0" title="0">
                finalRedirect = "/users"</span>
        default:<span class="cov0" title="0">
                finalRedirect = "/users"</span> // Default to main app
        }

        // HTML page that extracts tokens from URL fragment and sets session
        <span class="cov0" title="0">html := fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Processing Login...&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f5f5f5;
        }
        .processing {
            text-align: center;
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="processing"&gt;
        &lt;h2&gt;Processing Login...&lt;/h2&gt;
        &lt;p&gt;Please wait while we complete your authentication.&lt;/p&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // Extract tokens from URL fragment (Supabase returns them in hash)
        const hash = window.location.hash.substring(1);
        const params = new URLSearchParams(hash);
        const accessToken = params.get('access_token');
        const refreshToken = params.get('refresh_token');
        
        if (accessToken) {
            // Send tokens to server for validation and session setup
            fetch('/auth/process', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    access_token: accessToken,
                    refresh_token: refreshToken 
                })
            }).then(response =&gt; {
                if (response.ok) {
                    // Successful authentication - redirect to final destination
                    window.location.href = '%s';
                } else {
                    // Authentication failed
                    window.location.href = '/login?error=unauthorized';
                }
            }).catch(error =&gt; {
                console.error('Auth error:', error);
                window.location.href = '/login?error=invalid';
            });
        } else {
            // No token found - redirect to login with error
            window.location.href = '/login?error=invalid';
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`, finalRedirect)

        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.Write([]byte(html))</span>
}

// ProcessTokens handles the access token validation and session setup
func (a *DiscordAuth) ProcessTokens(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                AccessToken  string `json:"access_token"`
                RefreshToken string `json:"refresh_token"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error decoding token request: %v", err)
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        // Validate tokens with Supabase and get user info
        <span class="cov0" title="0">user, err := a.validateTokensAndGetUser(req.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error validating tokens: %v", err)
                http.Error(w, "Authentication failed", http.StatusUnauthorized)
                return
        }</span>

        // Check if user is authorized (Discord admin)
        <span class="cov0" title="0">if !a.isUserAuthorized(user) </span><span class="cov0" title="0">{
                log.Printf("User not authorized: %+v", user)
                http.Error(w, "Access denied", http.StatusForbidden)
                return
        }</span>

        // Set secure session cookies
        <span class="cov0" title="0">a.setSessionCookies(w, req.AccessToken, req.RefreshToken)

        // Success response
        w.WriteHeader(http.StatusOK)</span>
}

// IsAuthenticated checks if the current request has valid authentication
// This works for both main app and USL routes
func (a *DiscordAuth) IsAuthenticated(r *http.Request) bool <span class="cov0" title="0">{
        // Get access token from cookie
        cookie, err := r.Cookie("auth_access_token")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Validate token and get user info
        <span class="cov0" title="0">user, err := a.validateTokensAndGetUser(cookie.Value)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if user is authorized
        <span class="cov0" title="0">return a.isUserAuthorized(user)</span>
}

// RequireAuth middleware that protects routes with Discord OAuth
// This replaces both the main app auth middleware and USL auth middleware
func (a *DiscordAuth) RequireAuth(next http.HandlerFunc) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if !a.IsAuthenticated(r) </span><span class="cov0" title="0">{
                        // Redirect to appropriate login based on route
                        if strings.HasPrefix(r.URL.Path, "/usl") </span><span class="cov0" title="0">{
                                http.Redirect(w, r, "/usl/login", http.StatusSeeOther)
                        }</span> else<span class="cov0" title="0"> {
                                http.Redirect(w, r, "/login", http.StatusSeeOther)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">next(w, r)</span>
        }
}

// Logout clears the authentication session
func (a *DiscordAuth) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Clear session cookies
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "auth_access_token",
                Value:    "",
                Path:     "/",
                HttpOnly: true,
                MaxAge:   -1,
        })

        http.SetCookie(w, &amp;http.Cookie{
                Name:     "auth_refresh_token",
                Value:    "",
                Path:     "/",
                HttpOnly: true,
                MaxAge:   -1,
        })

        // Redirect to appropriate login
        if strings.HasPrefix(r.URL.Path, "/usl") </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/usl/login", http.StatusSeeOther)
        }</span> else<span class="cov0" title="0"> {
                http.Redirect(w, r, "/login", http.StatusSeeOther)
        }</span>
}

// Helper methods

func (a *DiscordAuth) validateTokensAndGetUser(accessToken string) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Use the main Supabase client with the user's access token

        // Create an authenticated client with the user's token
        userClient := a.supabaseClient.Auth.WithToken(accessToken)

        // Get user info using their access token
        user, err := userClient.GetUser()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user from Supabase: %w", err)
        }</span>

        // Extract user information
        <span class="cov0" title="0">userMap := map[string]interface{}{
                "id":            user.ID,
                "email":         user.Email,
                "user_metadata": user.UserMetadata,
                "app_metadata":  user.AppMetadata,
        }

        return userMap, nil</span>
}

func (a *DiscordAuth) isUserAuthorized(user map[string]interface{}) bool <span class="cov0" title="0">{
        // Extract Discord ID from user metadata
        // The exact location depends on how Supabase stores Discord user info
        discordID := ""

        // Debug: Log the entire user object to see what we're working with

        // Try to get Discord ID from various possible locations
        if metadata, ok := user["user_metadata"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if id, exists := metadata["provider_id"].(string); exists </span><span class="cov0" title="0">{
                        discordID = id
                }</span> else<span class="cov0" title="0"> if id, exists := metadata["sub"].(string); exists </span><span class="cov0" title="0">{
                        discordID = id
                }</span> else<span class="cov0" title="0"> if id, exists := metadata["discord_id"].(string); exists </span><span class="cov0" title="0">{
                        discordID = id
                }</span>
        }

        <span class="cov0" title="0">if discordID == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if Discord ID is in admin list
        <span class="cov0" title="0">for _, adminID := range a.adminDiscordIDs </span><span class="cov0" title="0">{
                if discordID == adminID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (a *DiscordAuth) setSessionCookies(w http.ResponseWriter, accessToken, refreshToken string) <span class="cov0" title="0">{
        // Set access token cookie
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "auth_access_token",
                Value:    accessToken,
                Path:     "/",
                HttpOnly: true,
                Secure:   false, // Set to true in production with HTTPS
                SameSite: http.SameSiteLaxMode,
                MaxAge:   3600, // 1 hour
        })

        // Set refresh token cookie
        if refreshToken != "" </span><span class="cov0" title="0">{
                http.SetCookie(w, &amp;http.Cookie{
                        Name:     "auth_refresh_token",
                        Value:    refreshToken,
                        Path:     "/",
                        HttpOnly: true,
                        Secure:   false, // Set to true in production with HTTPS
                        SameSite: http.SameSiteLaxMode,
                        MaxAge:   86400 * 7, // 7 days
                })
        }</span>
}

func (a *DiscordAuth) getErrorMessage(r *http.Request) string <span class="cov0" title="0">{
        errorType := r.URL.Query().Get("error")
        switch errorType </span>{
        case "invalid":<span class="cov0" title="0">
                return `&lt;div class="error"&gt;Login failed. Please try again.&lt;/div&gt;`</span>
        case "unauthorized":<span class="cov0" title="0">
                return `&lt;div class="error"&gt;Access denied. Your Discord account is not authorized.&lt;/div&gt;`</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "github.com/joho/godotenv"
        "log"
        "os"
        "strconv"
        "strings"
)

// Config holds all configuration for the application
// Matches the configuration structure from the Google Apps Script project
type Config struct {
        Server    ServerConfig    `json:"server"`
        Database  DatabaseConfig  `json:"database"`
        Supabase  SupabaseConfig  `json:"supabase"`
        TrueSkill TrueSkillConfig `json:"trueskill"`
        MMR       MMRConfig       `json:"mmr"`
        USL       USLConfig       `json:"usl"`
}

type ServerConfig struct {
        Host string `json:"host"`
        Port string `json:"port"`
}

type DatabaseConfig struct {
        URL string `json:"url"`
}

type SupabaseConfig struct {
        URL            string `json:"url"`
        PublicURL      string `json:"public_url"` // For OAuth callbacks via ngrok
        AnonKey        string `json:"anon_key"`
        ServiceRoleKey string `json:"service_role_key"`
}

// TrueSkillConfig matches the configuration from TrueSkillConfig.js
type TrueSkillConfig struct {
        InitialMu            float64 `json:"initial_mu"`
        InitialSigma         float64 `json:"initial_sigma"`
        SigmaMin             float64 `json:"sigma_min"`
        SigmaMax             float64 `json:"sigma_max"`
        GamesForMaxCertainty int     `json:"games_for_max_certainty"`
}

// MMRConfig matches the configuration from MMRConfig.js
type MMRConfig struct {
        OnesWeight           float64 `json:"ones_weight"`
        TwosWeight           float64 `json:"twos_weight"`
        ThreesWeight         float64 `json:"threes_weight"`
        MinGamesThreshold    int     `json:"min_games_threshold"`
        CurrentSeasonWeight  float64 `json:"current_season_weight"`
        PreviousSeasonWeight float64 `json:"previous_season_weight"`
}

// USLConfig holds USL-specific configuration for temporary migration
type USLConfig struct {
        AdminDiscordIDs []string `json:"admin_discord_ids"`
}

// Load initializes configuration from environment variables
func Load() (*Config, error) <span class="cov0" title="0">{
        // Load .env file if it exists
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: .env file not found: %v", err)
        }</span>

        <span class="cov0" title="0">config := &amp;Config{
                Server: ServerConfig{
                        Host: getEnv("SERVER_HOST", "localhost"),
                        Port: getEnv("SERVER_PORT", "8080"),
                },
                Database: DatabaseConfig{
                        URL: getEnv("DATABASE_URL", ""),
                },
                Supabase: SupabaseConfig{
                        URL:            getEnv("SUPABASE_URL", ""),
                        PublicURL:      getEnv("SUPABASE_PUBLIC_URL", getEnv("SUPABASE_URL", "")), // Fallback to URL if not set
                        AnonKey:        getEnv("SUPABASE_ANON_KEY", ""),
                        ServiceRoleKey: getEnv("SUPABASE_SERVICE_ROLE_KEY", ""),
                },
                TrueSkill: TrueSkillConfig{
                        InitialMu:            getEnvFloat("TRUESKILL_INITIAL_MU", 1500.0),
                        InitialSigma:         getEnvFloat("TRUESKILL_INITIAL_SIGMA", 8.333),
                        SigmaMin:             getEnvFloat("TRUESKILL_SIGMA_MIN", 2.5),
                        SigmaMax:             getEnvFloat("TRUESKILL_SIGMA_MAX", 8.333),
                        GamesForMaxCertainty: getEnvInt("TRUESKILL_GAMES_FOR_MAX_CERTAINTY", 1000),
                },
                MMR: MMRConfig{
                        OnesWeight:           getEnvFloat("MMR_ONES_WEIGHT", 1.0),
                        TwosWeight:           getEnvFloat("MMR_TWOS_WEIGHT", 1.5),
                        ThreesWeight:         getEnvFloat("MMR_THREES_WEIGHT", 1.2),
                        MinGamesThreshold:    getEnvInt("MMR_MIN_GAMES_THRESHOLD", 10),
                        CurrentSeasonWeight:  getEnvFloat("MMR_CURRENT_SEASON_WEIGHT", 0.7),
                        PreviousSeasonWeight: getEnvFloat("MMR_PREVIOUS_SEASON_WEIGHT", 0.3),
                },
                USL: USLConfig{
                        AdminDiscordIDs: getEnvStringSlice("USL_ADMIN_DISCORD_IDS", []string{"679038415576104971", "354474826192388127"}),
                },
        }

        return config, nil</span>
}

// Utility functions for environment variable parsing
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvFloat(key string, defaultValue float64) float64 <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if floatValue, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                        return floatValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// GetTrueSkillDefaults returns the default TrueSkill values for new users
// Matches the default values from the Google Apps Script project
func (c *Config) GetTrueSkillDefaults() (float64, float64) <span class="cov0" title="0">{
        return c.TrueSkill.InitialMu, c.TrueSkill.InitialSigma
}</span>

func (c *Config) GetTrueSkillSigmaRange() (float64, float64) <span class="cov0" title="0">{
        return c.TrueSkill.SigmaMax, c.TrueSkill.SigmaMin
}</span>

func (c *Config) GetMMRConfig() MMRConfig <span class="cov0" title="0">{
        return c.MMR
}</span>

// getEnvStringSlice parses a comma-separated string into a slice
func getEnvStringSlice(key string, defaultValue []string) []string <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">parts := strings.Split(value, ",")
        result := make([]string, len(parts))
        for i, part := range parts </span><span class="cov0" title="0">{
                result[i] = strings.TrimSpace(part)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "fmt"
        "os"
)

// Environment represents the deployment environment
type Environment string

const (
        Development Environment = "development"
        Staging     Environment = "staging"
        Production  Environment = "production"
)

// GetEnvironment determines the current environment
func GetEnvironment() Environment <span class="cov0" title="0">{
        env := os.Getenv("ENVIRONMENT")
        switch env </span>{
        case "staging":<span class="cov0" title="0">
                return Staging</span>
        case "production":<span class="cov0" title="0">
                return Production</span>
        default:<span class="cov0" title="0">
                return Development</span>
        }
}

// EnvironmentConfig provides environment-specific configuration
type EnvironmentConfig struct {
        Environment         Environment
        RequireHTTPS        bool
        AllowedOrigins      []string
        LogLevel            string
        SessionCookieSecure bool
        EnableDebugLogging  bool
}

// GetEnvironmentConfig returns configuration based on environment
func GetEnvironmentConfig() EnvironmentConfig <span class="cov0" title="0">{
        env := GetEnvironment()

        switch env </span>{
        case Production:<span class="cov0" title="0">
                return EnvironmentConfig{
                        Environment:         Production,
                        RequireHTTPS:        true,
                        AllowedOrigins:      []string{"https://your-domain.com"},
                        LogLevel:            "info",
                        SessionCookieSecure: true,
                        EnableDebugLogging:  false,
                }</span>
        case Staging:<span class="cov0" title="0">
                return EnvironmentConfig{
                        Environment:         Staging,
                        RequireHTTPS:        true,
                        AllowedOrigins:      []string{"https://staging.your-domain.com"},
                        LogLevel:            "debug",
                        SessionCookieSecure: true,
                        EnableDebugLogging:  true,
                }</span>
        default:<span class="cov0" title="0"> // Development
                return EnvironmentConfig{
                        Environment:         Development,
                        RequireHTTPS:        false,
                        AllowedOrigins:      []string{"http://localhost:8080", "http://127.0.0.1:8080"},
                        LogLevel:            "debug",
                        SessionCookieSecure: false,
                        EnableDebugLogging:  true,
                }</span>
        }
}

// GetSupabaseConfig returns environment-appropriate Supabase configuration
func GetSupabaseConfig() SupabaseConfig <span class="cov0" title="0">{
        env := GetEnvironment()

        // Base configuration from environment variables
        baseConfig := SupabaseConfig{
                URL:            getEnv("SUPABASE_URL", ""),
                AnonKey:        getEnv("SUPABASE_ANON_KEY", ""),
                ServiceRoleKey: getEnv("SUPABASE_SERVICE_ROLE_KEY", ""),
        }

        // Environment-specific logic
        switch env </span>{
        case Development:<span class="cov0" title="0">
                // In development, PublicURL might be different (ngrok)
                baseConfig.PublicURL = getEnv("SUPABASE_PUBLIC_URL", baseConfig.URL)</span>
        default:<span class="cov0" title="0">
                // In staging/production, PublicURL is same as URL
                baseConfig.PublicURL = baseConfig.URL</span>
        }

        // Validate required fields
        <span class="cov0" title="0">if baseConfig.URL == "" </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("SUPABASE_URL is required for %s environment", env))</span>
        }

        <span class="cov0" title="0">return baseConfig</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "html/template"
        "log"
        "net/http"
        "strconv"
        "usl-server/internal/models"
        "usl-server/internal/repositories"
        "usl-server/internal/services"
)

const (
        // Number parsing constants
        ParseIntBase    = 10
        ParseIntBitSize = 64
)

type GuildHandler struct {
        guildRepository   *repositories.GuildRepository
        permissionService *services.PermissionService
        templates         *template.Template
}

func NewGuildHandler(guildRepo *repositories.GuildRepository, permService *services.PermissionService, templates *template.Template) *GuildHandler <span class="cov0" title="0">{
        return &amp;GuildHandler{
                guildRepository:   guildRepo,
                permissionService: permService,
                templates:         templates,
        }
}</span>

// Helper methods for common operations

func (h *GuildHandler) validateHTTPMethod(w http.ResponseWriter, r *http.Request, allowedMethod string) bool <span class="cov0" title="0">{
        if r.Method != allowedMethod </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (h *GuildHandler) renderTemplate(w http.ResponseWriter, templateName string, data any) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        if err := h.templates.ExecuteTemplate(w, "base", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Template rendering error (%s): %v", templateName, err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

func (h *GuildHandler) renderErrorPage(w http.ResponseWriter, title, message string, statusCode int) <span class="cov0" title="0">{
        w.WriteHeader(statusCode)
        errorData := struct {
                Title   string
                Message string
        }{
                Title:   title,
                Message: message,
        }
        h.renderTemplate(w, "error.html", errorData)
}</span>

func (h *GuildHandler) renderJSONResponse(w http.ResponseWriter, data any, statusCode int) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                log.Printf("JSON encoding error: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// parseGuildIDFromQuery extracts and validates guild ID from query parameters
func (h *GuildHandler) parseGuildIDFromQuery(r *http.Request) (int64, error) <span class="cov0" title="0">{
        guildIDStr := r.URL.Query().Get("id")
        if guildIDStr == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Guild ID is required")
        }</span>

        <span class="cov0" title="0">guildID, err := strconv.ParseInt(guildIDStr, ParseIntBase, ParseIntBitSize)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Invalid guild ID")
        }</span>

        <span class="cov0" title="0">return guildID, nil</span>
}

// Guild management endpoints

// GetGuildConfig handles GET /guilds/{id}/config
func (h *GuildHandler) GetGuildConfig(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.validateHTTPMethod(w, r, http.MethodGet) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">guildID, err := h.parseGuildIDFromQuery(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">config, err := h.guildRepository.GetConfig(guildID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get guild config: %v", err)
                h.renderErrorPage(w, "Configuration Error", "Failed to load guild configuration", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.renderJSONResponse(w, config, http.StatusOK)</span>
}

// UpdateGuildConfig handles PUT /guilds/{id}/config
func (h *GuildHandler) UpdateGuildConfig(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.validateHTTPMethod(w, r, http.MethodPut) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">guildID, err := h.parseGuildIDFromQuery(r)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var config models.GuildConfig
        if err := json.NewDecoder(r.Body).Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Validate configuration immediately
        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        // Update the configuration
        <span class="cov0" title="0">if err := h.guildRepository.UpdateConfig(guildID, &amp;config); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update guild config: %v", err)
                h.renderErrorPage(w, "Update Error", "Failed to update guild configuration", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.renderJSONResponse(w, map[string]string{"status": "success"}, http.StatusOK)</span>
}

// CreateGuild handles POST /guilds
func (h *GuildHandler) CreateGuild(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.validateHTTPMethod(w, r, http.MethodPost) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var guildData models.GuildCreateRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;guildData); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Set default config if not provided
        <span class="cov0" title="0">if guildData.Config.Discord.BotCommandPrefix == "" </span><span class="cov0" title="0">{
                guildData.Config = models.GetDefaultGuildConfig()
        }</span>

        // Validate the guild data
        <span class="cov0" title="0">if err := guildData.Config.Validate(); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">guild, err := h.guildRepository.CreateGuild(guildData)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create guild: %v", err)
                h.renderErrorPage(w, "Creation Error", "Failed to create guild", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.renderJSONResponse(w, guild, http.StatusCreated)</span>
}

// GetAllGuilds handles GET /guilds
func (h *GuildHandler) GetAllGuilds(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.validateHTTPMethod(w, r, http.MethodGet) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">activeOnlyStr := r.URL.Query().Get("active_only")
        activeOnly := activeOnlyStr == "true"

        guilds, err := h.guildRepository.GetAllGuilds(activeOnly)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get guilds: %v", err)
                h.renderErrorPage(w, "Retrieval Error", "Failed to load guilds", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.renderJSONResponse(w, guilds, http.StatusOK)</span>
}

// GetGuild handles GET /guilds/{id}
func (h *GuildHandler) GetGuild(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.validateHTTPMethod(w, r, http.MethodGet) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">guildIDStr := r.URL.Query().Get("id")
        if guildIDStr == "" </span><span class="cov0" title="0">{
                http.Error(w, "Guild ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">guildID, err := strconv.ParseInt(guildIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid guild ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">guild, err := h.guildRepository.FindGuildByID(guildID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get guild: %v", err)
                h.renderErrorPage(w, "Not Found", "Guild not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">h.renderJSONResponse(w, guild, http.StatusOK)</span>
}

// GetGuildByDiscordID handles GET /guilds/discord/{discord_id}
func (h *GuildHandler) GetGuildByDiscordID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.validateHTTPMethod(w, r, http.MethodGet) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">discordGuildID := r.URL.Query().Get("discord_id")
        if discordGuildID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Discord Guild ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">guild, err := h.guildRepository.FindGuildByDiscordID(discordGuildID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get guild by Discord ID: %v", err)
                h.renderErrorPage(w, "Not Found", "Guild not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">h.renderJSONResponse(w, guild, http.StatusOK)</span>
}

// DeactivateGuild handles DELETE /guilds/{id}
func (h *GuildHandler) DeactivateGuild(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.validateHTTPMethod(w, r, http.MethodDelete) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">guildIDStr := r.URL.Query().Get("id")
        if guildIDStr == "" </span><span class="cov0" title="0">{
                http.Error(w, "Guild ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">guildID, err := strconv.ParseInt(guildIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid guild ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">guild, err := h.guildRepository.DeactivateGuild(guildID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to deactivate guild: %v", err)
                h.renderErrorPage(w, "Deactivation Error", "Failed to deactivate guild", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.renderJSONResponse(w, guild, http.StatusOK)</span>
}

// CheckPermissions handles GET /guilds/{id}/permissions
func (h *GuildHandler) CheckPermissions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.validateHTTPMethod(w, r, http.MethodGet) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">guildIDStr := r.URL.Query().Get("id")
        if guildIDStr == "" </span><span class="cov0" title="0">{
                http.Error(w, "Guild ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">guildID, err := strconv.ParseInt(guildIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid guild ID", http.StatusBadRequest)
                return
        }</span>

        // For now, we'll use a placeholder for user roles
        // In a real implementation, this would come from Discord OAuth or session
        <span class="cov0" title="0">userRoles := r.URL.Query()["role"]

        permissions := h.permissionService.GetUserPermissions(userRoles, guildID)
        h.renderJSONResponse(w, permissions, http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "encoding/json"
        "html/template"
        "log"
        "net/http"
        "strconv"
        "usl-server/internal/models"
        "usl-server/internal/repositories"
        "usl-server/internal/services"
)

// TrackerHandler handles HTTP requests for tracker management
type TrackerHandler struct {
        trackerRepo      *repositories.TrackerRepository
        trueSkillService *services.UserTrueSkillService
        templates        *template.Template
}

// NewTrackerHandler creates a new tracker handler
func NewTrackerHandler(trackerRepo *repositories.TrackerRepository, trueSkillService *services.UserTrueSkillService, templates *template.Template) *TrackerHandler <span class="cov0" title="0">{
        return &amp;TrackerHandler{
                trackerRepo:      trackerRepo,
                trueSkillService: trueSkillService,
                templates:        templates,
        }
}</span>

// ListTrackers displays all trackers in HTML format
func (h *TrackerHandler) ListTrackers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">validOnly := r.URL.Query().Get("valid_only") == "true"
        trackers, err := h.trackerRepo.GetAllTrackers(validOnly)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting trackers: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title     string
                Trackers  []*models.UserTracker
                ValidOnly bool
        }{
                Title:     "Tracker Management",
                Trackers:  trackers,
                ValidOnly: validOnly,
        }

        if err := h.templates.ExecuteTemplate(w, "base", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// NewTrackerForm displays the form for creating a new tracker
func (h *TrackerHandler) NewTrackerForm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title string
        }{
                Title: "Create New Tracker",
        }

        if err := h.templates.ExecuteTemplate(w, "base", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// CreateTracker handles the creation of a new tracker
func (h *TrackerHandler) CreateTracker(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to parse form", http.StatusBadRequest)
                return
        }</span>

        // Parse form values to integers
        <span class="cov0" title="0">parseInt := func(value string) int </span><span class="cov0" title="0">{
                if value == "" </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">if i, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov0" title="0">return 0</span>
        }

        <span class="cov0" title="0">trackerData := models.TrackerCreateRequest{
                DiscordID:                 r.FormValue("discord_id"),
                URL:                       r.FormValue("url"),
                OnesCurrentSeasonPeak:     parseInt(r.FormValue("ones_current_peak")),
                OnesPreviousSeasonPeak:    parseInt(r.FormValue("ones_previous_peak")),
                OnesAllTimePeak:           parseInt(r.FormValue("ones_all_time_peak")),
                OnesCurrentSeasonGames:    parseInt(r.FormValue("ones_current_games")),
                OnesPreviousSeasonGames:   parseInt(r.FormValue("ones_previous_games")),
                TwosCurrentSeasonPeak:     parseInt(r.FormValue("twos_current_peak")),
                TwosPreviousSeasonPeak:    parseInt(r.FormValue("twos_previous_peak")),
                TwosAllTimePeak:           parseInt(r.FormValue("twos_all_time_peak")),
                TwosCurrentSeasonGames:    parseInt(r.FormValue("twos_current_games")),
                TwosPreviousSeasonGames:   parseInt(r.FormValue("twos_previous_games")),
                ThreesCurrentSeasonPeak:   parseInt(r.FormValue("threes_current_peak")),
                ThreesPreviousSeasonPeak:  parseInt(r.FormValue("threes_previous_peak")),
                ThreesAllTimePeak:         parseInt(r.FormValue("threes_all_time_peak")),
                ThreesCurrentSeasonGames:  parseInt(r.FormValue("threes_current_games")),
                ThreesPreviousSeasonGames: parseInt(r.FormValue("threes_previous_games")),
                Valid:                     r.FormValue("valid") == "true",
        }

        tracker, err := h.trackerRepo.CreateTracker(trackerData)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating tracker: %v", err)
                http.Error(w, "Failed to create tracker: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        // Auto-update TrueSkill after tracker creation
        <span class="cov0" title="0">result := h.trueSkillService.UpdateUserTrueSkillFromTrackers(tracker.DiscordID)
        if !result.Success </span><span class="cov0" title="0">{
                log.Printf("TrueSkill auto-update failed for %s: %s", tracker.DiscordID, result.Error)
                // Continue anyway - don't fail the tracker operation
        }</span> else<span class="cov0" title="0"> if result.TrueSkillResult != nil </span><span class="cov0" title="0">{
                log.Printf("Auto-updated TrueSkill for %s: Œº=%.1f",
                        tracker.DiscordID, result.TrueSkillResult.Mu)
        }</span>

        <span class="cov0" title="0">log.Printf("Created tracker for user: %s", tracker.DiscordID)
        http.Redirect(w, r, "/trackers", http.StatusSeeOther)</span>
}

// EditTrackerForm displays the form for editing an existing tracker
func (h *TrackerHandler) EditTrackerForm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">trackerIDStr := r.URL.Query().Get("id")
        if trackerIDStr == "" </span><span class="cov0" title="0">{
                http.Error(w, "Tracker ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">trackerID, err := strconv.Atoi(trackerIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid tracker ID", http.StatusBadRequest)
                return
        }</span>

        // Get tracker by finding all trackers and filtering by ID (simplified approach)
        <span class="cov0" title="0">allTrackers, err := h.trackerRepo.GetAllTrackers(false)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting trackers: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">var tracker *models.UserTracker
        for _, t := range allTrackers </span><span class="cov0" title="0">{
                if t.ID == trackerID </span><span class="cov0" title="0">{
                        tracker = t
                        break</span>
                }
        }

        <span class="cov0" title="0">if tracker == nil </span><span class="cov0" title="0">{
                http.Error(w, "Tracker not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title   string
                Tracker *models.UserTracker
        }{
                Title:   "Edit Tracker",
                Tracker: tracker,
        }

        if err := h.templates.ExecuteTemplate(w, "base", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// UpdateTracker handles updating an existing tracker
func (h *TrackerHandler) UpdateTracker(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to parse form", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">trackerIDStr := r.FormValue("tracker_id")
        if trackerIDStr == "" </span><span class="cov0" title="0">{
                http.Error(w, "Tracker ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">trackerID, err := strconv.Atoi(trackerIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid tracker ID", http.StatusBadRequest)
                return
        }</span>

        // Parse form values to integers
        <span class="cov0" title="0">parseInt := func(value string) int </span><span class="cov0" title="0">{
                if value == "" </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">if i, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov0" title="0">return 0</span>
        }

        <span class="cov0" title="0">trackerData := models.TrackerUpdateRequest{
                URL:                       r.FormValue("url"),
                OnesCurrentSeasonPeak:     parseInt(r.FormValue("ones_current_peak")),
                OnesPreviousSeasonPeak:    parseInt(r.FormValue("ones_previous_peak")),
                OnesAllTimePeak:           parseInt(r.FormValue("ones_all_time_peak")),
                OnesCurrentSeasonGames:    parseInt(r.FormValue("ones_current_games")),
                OnesPreviousSeasonGames:   parseInt(r.FormValue("ones_previous_games")),
                TwosCurrentSeasonPeak:     parseInt(r.FormValue("twos_current_peak")),
                TwosPreviousSeasonPeak:    parseInt(r.FormValue("twos_previous_peak")),
                TwosAllTimePeak:           parseInt(r.FormValue("twos_all_time_peak")),
                TwosCurrentSeasonGames:    parseInt(r.FormValue("twos_current_games")),
                TwosPreviousSeasonGames:   parseInt(r.FormValue("twos_previous_games")),
                ThreesCurrentSeasonPeak:   parseInt(r.FormValue("threes_current_peak")),
                ThreesPreviousSeasonPeak:  parseInt(r.FormValue("threes_previous_peak")),
                ThreesAllTimePeak:         parseInt(r.FormValue("threes_all_time_peak")),
                ThreesCurrentSeasonGames:  parseInt(r.FormValue("threes_current_games")),
                ThreesPreviousSeasonGames: parseInt(r.FormValue("threes_previous_games")),
                Valid:                     r.FormValue("valid") == "true",
        }

        tracker, err := h.trackerRepo.UpdateTracker(trackerID, trackerData)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error updating tracker: %v", err)
                http.Error(w, "Failed to update tracker: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        // Auto-update TrueSkill after tracker update
        <span class="cov0" title="0">result := h.trueSkillService.UpdateUserTrueSkillFromTrackers(tracker.DiscordID)
        if !result.Success </span><span class="cov0" title="0">{
                log.Printf("TrueSkill auto-update failed for %s: %s", tracker.DiscordID, result.Error)
                // Continue anyway - don't fail the tracker operation
        }</span> else<span class="cov0" title="0"> if result.TrueSkillResult != nil </span><span class="cov0" title="0">{
                log.Printf("Auto-updated TrueSkill for %s: Œº=%.1f",
                        tracker.DiscordID, result.TrueSkillResult.Mu)
        }</span>

        <span class="cov0" title="0">log.Printf("Updated tracker for user: %s", tracker.DiscordID)
        http.Redirect(w, r, "/trackers", http.StatusSeeOther)</span>
}

// DeleteTracker handles deleting (marking invalid) a tracker
func (h *TrackerHandler) DeleteTracker(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">trackerIDStr := r.URL.Query().Get("id")
        if trackerIDStr == "" </span><span class="cov0" title="0">{
                http.Error(w, "Tracker ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">trackerID, err := strconv.Atoi(trackerIDStr)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid tracker ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">tracker, err := h.trackerRepo.DeleteTracker(trackerID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error deleting tracker: %v", err)
                http.Error(w, "Failed to delete tracker: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        // Auto-update TrueSkill after tracker deletion (may revert to defaults)
        <span class="cov0" title="0">result := h.trueSkillService.UpdateUserTrueSkillFromTrackers(tracker.DiscordID)
        if !result.Success </span><span class="cov0" title="0">{
                log.Printf("TrueSkill auto-update failed for %s: %s", tracker.DiscordID, result.Error)
                // Continue anyway - don't fail the tracker operation
        }</span> else<span class="cov0" title="0"> if result.TrueSkillResult != nil </span><span class="cov0" title="0">{
                log.Printf("Auto-updated TrueSkill for %s: Œº=%.1f",
                        tracker.DiscordID, result.TrueSkillResult.Mu)
        }</span>

        <span class="cov0" title="0">log.Printf("Deleted tracker for user: %s", tracker.DiscordID)
        http.Redirect(w, r, "/trackers", http.StatusSeeOther)</span>
}

// SearchTrackers handles searching for trackers
func (h *TrackerHandler) SearchTrackers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">query := r.URL.Query().Get("q")
        if query == "" </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/trackers", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">trackers, err := h.trackerRepo.SearchTrackers(query, 50)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error searching trackers: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title    string
                Trackers []*models.UserTracker
                Query    string
        }{
                Title:    "Tracker Search Results",
                Trackers: trackers,
                Query:    query,
        }

        if err := h.templates.ExecuteTemplate(w, "base", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

func (h *TrackerHandler) ListTrackersAPI(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">validOnly := r.URL.Query().Get("valid_only") == "true"
        trackers, err := h.trackerRepo.GetAllTrackers(validOnly)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting trackers: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(trackers); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error encoding JSON: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "encoding/json"
        "html/template"
        "log"
        "net/http"
        "usl-server/internal/services"
)

const (
        // Template names
        TrueSkillResultTemplate     = "trueskill_result.html"
        UserTrueSkillResultTemplate = "user_trueskill_result.html"
        TrueSkillStatsTemplate      = "trueskill_stats.html"

        // Page titles
        TrueSkillUpdateCompleteTitle = "TrueSkill Update Complete"
        TrueSkillRecalculationTitle  = "TrueSkill Recalculation Complete"
        UserTrueSkillUpdateTitle     = "User TrueSkill Update"
        TrueSkillStatsTitle          = "TrueSkill Statistics"
)

// TrueSkillHandler handles HTTP requests for TrueSkill calculations
type TrueSkillHandler struct {
        trueSkillService *services.UserTrueSkillService
        templates        *template.Template
}

// NewTrueSkillHandler creates a new TrueSkill handler
func NewTrueSkillHandler(trueSkillService *services.UserTrueSkillService, templates *template.Template) *TrueSkillHandler <span class="cov0" title="0">{
        return &amp;TrueSkillHandler{
                trueSkillService: trueSkillService,
                templates:        templates,
        }
}</span>

// UpdateAllUserTrueSkill handles batch TrueSkill updates for all users (HTML response)
func (h *TrueSkillHandler) UpdateAllUserTrueSkill(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">result, err := h.trueSkillService.UpdateAllUserTrueSkill()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error updating TrueSkill for all users: %v", err)
                http.Error(w, "Failed to update TrueSkill values: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Batch TrueSkill update completed: %d users processed, %d calculated from trackers, %d given defaults",
                result.ProcessedCount, result.TrackerBasedCount, result.DefaultCount)

        data := struct {
                Title  string
                Result *services.BatchUpdateResult
        }{
                Title:  TrueSkillUpdateCompleteTitle,
                Result: result,
        }

        if err := h.templates.ExecuteTemplate(w, "base", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// UpdateUserTrueSkill handles TrueSkill update for a single user
func (h *TrueSkillHandler) UpdateUserTrueSkill(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">discordID := r.URL.Query().Get("discord_id")
        if discordID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Discord ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">result := h.trueSkillService.UpdateUserTrueSkillFromTrackers(discordID)

        data := struct {
                Title     string
                DiscordID string
                Result    *services.TrueSkillUpdateResult
        }{
                Title:     "User TrueSkill Update",
                DiscordID: discordID,
                Result:    result,
        }

        if err := h.templates.ExecuteTemplate(w, "base", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// RecalculateAllUserTrueSkill handles recalculation of TrueSkill for all users
func (h *TrueSkillHandler) RecalculateAllUserTrueSkill(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">result, err := h.trueSkillService.RecalculateAllUserTrueSkill()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error recalculating TrueSkill for all users: %v", err)
                http.Error(w, "Failed to recalculate TrueSkill values: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("TrueSkill recalculation completed: %d users processed", result.ProcessedCount)

        data := struct {
                Title  string
                Result *services.BatchUpdateResult
        }{
                Title:  "TrueSkill Recalculation Complete",
                Result: result,
        }

        if err := h.templates.ExecuteTemplate(w, "base", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// GetTrueSkillStats displays TrueSkill service statistics
func (h *TrueSkillHandler) GetTrueSkillStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">stats := h.trueSkillService.GetTrueSkillStats()

        data := struct {
                Title string
                Stats map[string]interface{}
        }{
                Title: "TrueSkill Service Statistics",
                Stats: stats,
        }

        if err := h.templates.ExecuteTemplate(w, "base", data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

// UpdateAllUserTrueSkillAPI handles batch TrueSkill updates via API (JSON response)
func (h *TrueSkillHandler) UpdateAllUserTrueSkillAPI(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">result, err := h.trueSkillService.UpdateAllUserTrueSkill()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("API: Error updating TrueSkill for all users: %v", err)
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusInternalServerError)
                if encodeErr := json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "error":   err.Error(),
                }); encodeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to encode error response: %v", encodeErr)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">log.Printf("API: Batch TrueSkill update completed: %d users processed", result.ProcessedCount)

        response := map[string]interface{}{
                "success": true,
                "result":  result,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error encoding JSON response: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "encoding/json"
        "html/template"
        "log"
        "net/http"
        "strconv"
        "strings"
        "usl-server/internal/middleware"
        "usl-server/internal/models"
        "usl-server/internal/repositories"
)

type UserHandler struct {
        userRepository *repositories.UserRepository
        templates      *template.Template
}

func NewUserHandler(userRepo *repositories.UserRepository, templates *template.Template) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userRepository: userRepo,
                templates:      templates,
        }
}</span>

// Helper methods for common operations

func (h *UserHandler) validateHTTPMethod(w http.ResponseWriter, r *http.Request, allowedMethod string) bool <span class="cov0" title="0">{
        if r.Method != allowedMethod </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (h *UserHandler) renderTemplate(w http.ResponseWriter, templateName string, data any) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        if err := h.templates.ExecuteTemplate(w, templateName, data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Template rendering error (%s): %v", templateName, err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

func (h *UserHandler) renderFragment(w http.ResponseWriter, fragmentName string, data any) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        if err := h.templates.ExecuteTemplate(w, fragmentName, data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Fragment rendering error (%s): %v", fragmentName, err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}

func (h *UserHandler) isHTMXRequest(r *http.Request) bool <span class="cov0" title="0">{
        return r.Header.Get("HX-Request") == "true"
}</span>

func (h *UserHandler) renderErrorPage(w http.ResponseWriter, title, message string, statusCode int) <span class="cov0" title="0">{
        w.WriteHeader(statusCode)
        errorData := struct {
                Title   string
                Message string
        }{
                Title:   title,
                Message: message,
        }
        h.renderTemplate(w, "content", errorData)
}</span>

type UserPageData struct {
        Title   string
        Guild   *models.Guild
        Users   []*models.User
        Query   string
        Page    int
        HasMore bool
}

type UserFormData struct {
        Title  string
        Guild  *models.Guild
        User   *models.User
        Errors map[string]string
}

// ListUsers displays all users in HTML format
func (h *UserHandler) ListUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.validateHTTPMethod(w, r, http.MethodGet) </span><span class="cov0" title="0">{
                return
        }</span>

        // Get guild from context
        <span class="cov0" title="0">guild, ok := middleware.GetGuildFromRequest(r)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Guild context not found", http.StatusInternalServerError)
                return
        }</span>

        // Get search query
        <span class="cov0" title="0">query := strings.TrimSpace(r.URL.Query().Get("q"))

        var users []*models.User
        var err error

        if query != "" </span><span class="cov0" title="0">{
                users, err = h.userRepository.SearchUsers(query, 50)
        }</span> else<span class="cov0" title="0"> {
                users, err = h.userRepository.GetAllUsers(false)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to retrieve users: %v", err)
                h.renderErrorPage(w, "Error", "Unable to load users", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">pageData := &amp;UserPageData{
                Title: "User Management",
                Guild: guild,
                Users: users,
                Query: query,
        }

        // Check if this is an HTMX request
        if h.isHTMXRequest(r) </span><span class="cov0" title="0">{
                // Return just the user table fragment
                h.renderFragment(w, "user-table", pageData)
        }</span> else<span class="cov0" title="0"> {
                // Return the full page
                h.renderTemplate(w, "content", pageData)
        }</span>
}

// NewUserForm displays the form for creating a new user
func (h *UserHandler) NewUserForm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if !h.validateHTTPMethod(w, r, http.MethodGet) </span><span class="cov0" title="0">{
                return
        }</span>

        // Get guild from context
        <span class="cov0" title="0">guild, ok := middleware.GetGuildFromRequest(r)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Guild context not found", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">formData := &amp;UserFormData{
                Title:  "Add New User",
                Guild:  guild,
                User:   nil,
                Errors: make(map[string]string),
        }

        h.renderTemplate(w, "content", formData)</span>
}

// CreateUser handles the creation of a new user
func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get guild from context
        <span class="cov0" title="0">guild, ok := middleware.GetGuildFromRequest(r)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Guild context not found", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to parse form", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userData := models.UserCreateRequest{
                Name:      strings.TrimSpace(r.FormValue("name")),
                DiscordID: strings.TrimSpace(r.FormValue("discord_id")),
                Active:    r.FormValue("active") == "true",
                Banned:    r.FormValue("banned") == "true",
                MMR:       0, // MMR will be calculated via TrueSkill
        }

        // Validation
        errors := make(map[string]string)
        if userData.Name == "" </span><span class="cov0" title="0">{
                errors["Name"] = "Display name is required"
        }</span>
        <span class="cov0" title="0">if userData.DiscordID == "" </span><span class="cov0" title="0">{
                errors["DiscordID"] = "Discord ID is required"
        }</span>

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                // Return form with errors for HTMX
                formData := &amp;UserFormData{
                        Title:  "Add New User",
                        Guild:  guild,
                        User:   nil,
                        Errors: errors,
                }

                if h.isHTMXRequest(r) </span><span class="cov0" title="0">{
                        h.renderFragment(w, "user-form", formData)
                }</span> else<span class="cov0" title="0"> {
                        h.renderTemplate(w, "content", formData)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">user, err := h.userRepository.CreateUser(userData)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating user: %v", err)
                errors["general"] = "Failed to create user: " + err.Error()

                formData := &amp;UserFormData{
                        Title:  "Add New User",
                        Guild:  guild,
                        User:   nil,
                        Errors: errors,
                }

                if h.isHTMXRequest(r) </span><span class="cov0" title="0">{
                        h.renderFragment(w, "user-form", formData)
                }</span> else<span class="cov0" title="0"> {
                        h.renderTemplate(w, "content", formData)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">log.Printf("Created user: %s (%s)", user.Name, user.DiscordID)

        if h.isHTMXRequest(r) </span><span class="cov0" title="0">{
                // Redirect via HTMX
                w.Header().Set("HX-Redirect", "/"+guild.Slug+"/users")
                w.WriteHeader(http.StatusOK)
        }</span> else<span class="cov0" title="0"> {
                http.Redirect(w, r, "/"+guild.Slug+"/users", http.StatusSeeOther)
        }</span>
}

// EditUserForm displays the form for editing an existing user
func (h *UserHandler) EditUserForm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get guild from context
        <span class="cov0" title="0">guild, ok := middleware.GetGuildFromRequest(r)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Guild context not found", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">userID := r.URL.Query().Get("id")
        if userID == "" </span><span class="cov0" title="0">{
                discordID := r.URL.Query().Get("discord_id")
                if discordID == "" </span><span class="cov0" title="0">{
                        http.Error(w, "User ID or Discord ID is required", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">user, err := h.userRepository.FindUserByDiscordID(discordID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error finding user: %v", err)
                        http.Error(w, "User not found", http.StatusNotFound)
                        return
                }</span>

                <span class="cov0" title="0">formData := &amp;UserFormData{
                        Title:  "Edit User",
                        Guild:  guild,
                        User:   user,
                        Errors: make(map[string]string),
                }

                h.renderTemplate(w, "content", formData)
                return</span>
        }

        // Handle numeric user ID
        <span class="cov0" title="0">id, err := strconv.ParseInt(userID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userRepository.FindUserByID(id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error finding user: %v", err)
                http.Error(w, "User not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">formData := &amp;UserFormData{
                Title:  "Edit User",
                Guild:  guild,
                User:   user,
                Errors: make(map[string]string),
        }

        h.renderTemplate(w, "content", formData)</span>
}

// UpdateUser handles updating an existing user
func (h *UserHandler) UpdateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost &amp;&amp; r.Method != http.MethodPut </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get guild from context
        <span class="cov0" title="0">guild, ok := middleware.GetGuildFromRequest(r)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Guild context not found", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to parse form", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userID := r.FormValue("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                originalDiscordID := r.FormValue("original_discord_id")
                if originalDiscordID == "" </span><span class="cov0" title="0">{
                        http.Error(w, "User ID or Original Discord ID is required", http.StatusBadRequest)
                        return
                }</span>

                // Find user by Discord ID first
                <span class="cov0" title="0">user, err := h.userRepository.FindUserByDiscordID(originalDiscordID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error finding user: %v", err)
                        http.Error(w, "User not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">userID = strconv.FormatInt(int64(user.ID), 10)</span>
        }

        <span class="cov0" title="0">id, err := strconv.ParseInt(userID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid user ID", http.StatusBadRequest)
                return
        }</span>

        // Restricted user update: only name, active, and banned status
        <span class="cov0" title="0">userData := models.UserUpdateRequest{
                Name:   strings.TrimSpace(r.FormValue("name")),
                Active: r.FormValue("active") == "true",
                Banned: r.FormValue("banned") == "true",
        }

        // Validation
        errors := make(map[string]string)
        if userData.Name == "" </span><span class="cov0" title="0">{
                errors["Name"] = "Display name is required"
        }</span>

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                user, _ := h.userRepository.FindUserByID(id)
                formData := &amp;UserFormData{
                        Title:  "Edit User",
                        Guild:  guild,
                        User:   user,
                        Errors: errors,
                }

                if h.isHTMXRequest(r) </span><span class="cov0" title="0">{
                        h.renderFragment(w, "user-form", formData)
                }</span> else<span class="cov0" title="0"> {
                        h.renderTemplate(w, "content", formData)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">user, err := h.userRepository.UpdateUser(strconv.FormatInt(id, 10), userData)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error updating user: %v", err)
                errors["general"] = "Failed to update user: " + err.Error()

                user, _ := h.userRepository.FindUserByID(id)
                formData := &amp;UserFormData{
                        Title:  "Edit User",
                        Guild:  guild,
                        User:   user,
                        Errors: errors,
                }

                if h.isHTMXRequest(r) </span><span class="cov0" title="0">{
                        h.renderFragment(w, "user-form", formData)
                }</span> else<span class="cov0" title="0"> {
                        h.renderTemplate(w, "content", formData)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">log.Printf("Updated user: %s (%s)", user.Name, user.DiscordID)

        if h.isHTMXRequest(r) </span><span class="cov0" title="0">{
                // Redirect via HTMX
                w.Header().Set("HX-Redirect", "/"+guild.Slug+"/users")
                w.WriteHeader(http.StatusOK)
        }</span> else<span class="cov0" title="0"> {
                http.Redirect(w, r, "/"+guild.Slug+"/users", http.StatusSeeOther)
        }</span>
}

// DeleteUser handles deleting (marking inactive) a user
func (h *UserHandler) DeleteUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost &amp;&amp; r.Method != http.MethodDelete </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get guild from context
        <span class="cov0" title="0">guild, ok := middleware.GetGuildFromRequest(r)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Guild context not found", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">userID := r.URL.Query().Get("id")
        discordID := r.URL.Query().Get("discord_id")

        if userID == "" &amp;&amp; discordID == "" </span><span class="cov0" title="0">{
                http.Error(w, "User ID or Discord ID is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var user *models.User
        var err error

        if discordID != "" </span><span class="cov0" title="0">{
                user, err = h.userRepository.DeleteUser(discordID)
        }</span> else<span class="cov0" title="0"> {
                // Convert userID to find by Discord ID first (legacy compatibility)
                id, parseErr := strconv.ParseInt(userID, 10, 64)
                if parseErr != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid user ID", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">userObj, findErr := h.userRepository.FindUserByID(id)
                if findErr != nil </span><span class="cov0" title="0">{
                        http.Error(w, "User not found", http.StatusNotFound)
                        return
                }</span>

                <span class="cov0" title="0">user, err = h.userRepository.DeleteUser(userObj.DiscordID)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error deleting user: %v", err)
                http.Error(w, "Failed to delete user: "+err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Deleted user: %s (%s)", user.Name, user.DiscordID)

        if h.isHTMXRequest(r) </span><span class="cov0" title="0">{
                // Return success response for HTMX
                w.WriteHeader(http.StatusOK)
                w.Write([]byte("User deleted successfully"))
        }</span> else<span class="cov0" title="0"> {
                http.Redirect(w, r, "/"+guild.Slug+"/users", http.StatusSeeOther)
        }</span>
}

// SearchUsers handles searching for users
func (h *UserHandler) SearchUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // This method is now handled by ListUsers with query parameter
        <span class="cov0" title="0">h.ListUsers(w, r)</span>
}

// ListUsersAPI returns users in JSON format
func (h *UserHandler) ListUsersAPI(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">users, err := h.userRepository.GetAllUsers(false)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting users: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(users); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error encoding JSON: %v", err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package logger

import (
        "io"
        "log/slog"
        "os"
        "path/filepath"
)

// SetupLogger configures structured logging for the application
func SetupLogger(level slog.Level, logFilePath string) *slog.Logger <span class="cov0" title="0">{
        var writers []io.Writer

        // Always write to stdout
        writers = append(writers, os.Stdout)

        // Also write to file if path provided
        if logFilePath != "" </span><span class="cov0" title="0">{
                // Create logs directory if it doesn't exist
                logDir := filepath.Dir(logFilePath)
                if err := os.MkdirAll(logDir, 0755); err != nil </span><span class="cov0" title="0">{
                        // Fallback to stdout only if we can't create log directory
                        writers = []io.Writer{os.Stdout}
                }</span> else<span class="cov0" title="0"> {
                        // Open log file (create if doesn't exist, append if it does)
                        logFile, err := os.OpenFile(logFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                        if err != nil </span><span class="cov0" title="0">{
                                // Fallback to stdout only if we can't open log file
                                writers = []io.Writer{os.Stdout}
                        }</span> else<span class="cov0" title="0"> {
                                writers = append(writers, logFile)
                        }</span>
                }
        }

        // Create multi-writer to write to both stdout and file
        <span class="cov0" title="0">output := io.MultiWriter(writers...)

        opts := &amp;slog.HandlerOptions{
                Level:     level,
                AddSource: true, // Include source file/line in logs
        }

        handler := slog.NewJSONHandler(output, opts)
        logger := slog.New(handler)

        // Set as default logger
        slog.SetDefault(logger)

        return logger</span>
}

// NewLogger creates a new logger with additional context
func NewLogger(name string) *slog.Logger <span class="cov0" title="0">{
        return slog.Default().With("component", name)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "net/http"
        "strings"
        "usl-server/internal/models"
        "usl-server/internal/repositories"
)

type contextKey string

const (
        GuildContextKey contextKey = "guild"
)

// GuildContextMiddleware extracts guild information from URL slug and adds it to request context
type GuildContextMiddleware struct {
        guildRepo *repositories.GuildRepository
        logger    *slog.Logger
}

// NewGuildContextMiddleware creates a new guild context middleware
func NewGuildContextMiddleware(guildRepo *repositories.GuildRepository, logger *slog.Logger) *GuildContextMiddleware <span class="cov0" title="0">{
        return &amp;GuildContextMiddleware{
                guildRepo: guildRepo,
                logger:    logger,
        }
}</span>

// GuildContext returns a middleware that extracts guild from URL slug
func (m *GuildContextMiddleware) GuildContext() func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Extract guild slug from URL path
                        // Expected format: /{guild-slug}/... or /api/{guild-slug}/...
                        path := strings.TrimPrefix(r.URL.Path, "/")
                        pathParts := strings.Split(path, "/")

                        var guildSlug string
                        if len(pathParts) &gt; 0 </span><span class="cov0" title="0">{
                                // Handle /api/{guild-slug}/... format
                                if pathParts[0] == "api" &amp;&amp; len(pathParts) &gt; 1 </span><span class="cov0" title="0">{
                                        guildSlug = pathParts[1]
                                }</span> else<span class="cov0" title="0"> {
                                        // Handle /{guild-slug}/... format
                                        guildSlug = pathParts[0]
                                }</span>
                        }

                        <span class="cov0" title="0">if guildSlug == "" </span><span class="cov0" title="0">{
                                // No guild slug in URL, continue without guild context
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Skip guild context for certain routes
                        <span class="cov0" title="0">if shouldSkipGuildContext(guildSlug) </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // Fetch guild from database
                        <span class="cov0" title="0">guild, err := m.guildRepo.FindGuildBySlug(guildSlug)
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Warn("Guild not found", "slug", guildSlug, "error", err)
                                // For now, create a mock guild for USL compatibility
                                if guildSlug == "usl" </span><span class="cov0" title="0">{
                                        guild = &amp;models.Guild{
                                                ID:             1,
                                                DiscordGuildID: "123456789012345678",
                                                Name:           "USL",
                                                Slug:           "usl",
                                                Active:         true,
                                                Config:         models.GetDefaultGuildConfig(),
                                        }
                                }</span> else<span class="cov0" title="0"> {
                                        http.NotFound(w, r)
                                        return
                                }</span>
                        }

                        // Check if guild is active
                        <span class="cov0" title="0">if !guild.Active </span><span class="cov0" title="0">{
                                http.Error(w, "Guild is not active", http.StatusForbidden)
                                return
                        }</span>

                        // Add guild to request context
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), GuildContextKey, guild)
                        r = r.WithContext(ctx)

                        next.ServeHTTP(w, r)</span>
                })
        }
}

// shouldSkipGuildContext determines if guild context should be skipped for certain routes
func shouldSkipGuildContext(slug string) bool <span class="cov0" title="0">{
        skipRoutes := []string{
                "static",
                "auth",
                "login",
                "logout",
                "health",
                "favicon.ico",
        }

        for _, skipRoute := range skipRoutes </span><span class="cov0" title="0">{
                if slug == skipRoute </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// GetGuildFromContext extracts guild from request context
func GetGuildFromContext(ctx context.Context) (*models.Guild, bool) <span class="cov0" title="0">{
        guild, ok := ctx.Value(GuildContextKey).(*models.Guild)
        return guild, ok
}</span>

// GetGuildFromRequest is a convenience function to get guild from request context
func GetGuildFromRequest(r *http.Request) (*models.Guild, bool) <span class="cov0" title="0">{
        return GetGuildFromContext(r.Context())
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "log/slog"
        "net/http"
        "time"
)

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
        written    int64
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        if rw.statusCode == 0 </span><span class="cov0" title="0">{
                rw.statusCode = http.StatusOK
        }</span>
        <span class="cov0" title="0">n, err := rw.ResponseWriter.Write(b)
        rw.written += int64(n)
        return n, err</span>
}

// LoggingMiddleware logs HTTP requests with structured logging
func LoggingMiddleware(logger *slog.Logger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        start := time.Now()

                        // Wrap the response writer
                        rw := &amp;responseWriter{
                                ResponseWriter: w,
                                statusCode:     0,
                        }

                        // Process the request
                        next.ServeHTTP(rw, r)

                        // Log the request
                        duration := time.Since(start)

                        logLevel := slog.LevelInfo
                        if rw.statusCode &gt;= 400 </span><span class="cov0" title="0">{
                                logLevel = slog.LevelWarn
                        }</span>
                        <span class="cov0" title="0">if rw.statusCode &gt;= 500 </span><span class="cov0" title="0">{
                                logLevel = slog.LevelError
                        }</span>

                        <span class="cov0" title="0">logger.Log(r.Context(), logLevel, "HTTP Request",
                                "method", r.Method,
                                "path", r.URL.Path,
                                "query", r.URL.RawQuery,
                                "status", rw.statusCode,
                                "duration_ms", duration.Milliseconds(),
                                "bytes_written", rw.written,
                                "user_agent", r.UserAgent(),
                                "remote_addr", r.RemoteAddr,
                        )</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "html/template"
        "log/slog"
        "net/http"
)

// NotFoundHandler creates a 404 handler that serves a custom 404 page
func NotFoundHandler(logger *slog.Logger, templates *template.Template) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                logger.Warn("404 Not Found",
                        "method", r.Method,
                        "path", r.URL.Path,
                        "query", r.URL.RawQuery,
                        "user_agent", r.UserAgent(),
                        "remote_addr", r.RemoteAddr,
                )

                w.WriteHeader(http.StatusNotFound)
                w.Header().Set("Content-Type", "text/html; charset=utf-8")

                data := struct {
                        Title string
                        Path  string
                }{
                        Title: "Page Not Found",
                        Path:  r.URL.Path,
                }

                if err := templates.ExecuteTemplate(w, "404.html", data); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to render 404 template", "error", err)
                        // Fallback to plain text 404
                        http.Error(w, "404 - Page Not Found", http.StatusNotFound)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "time"
)

// Guild represents a Discord server with USL integration
type Guild struct {
        ID             int64       `json:"id" db:"id"`
        DiscordGuildID string      `json:"discord_guild_id" db:"discord_guild_id" validate:"required,min=17,max=19"`
        Name           string      `json:"name" db:"name" validate:"required,min=1,max=100"`
        Slug           string      `json:"slug" db:"slug" validate:"required,min=1,max=50"`
        Active         bool        `json:"active" db:"active"`
        Config         GuildConfig `json:"config" db:"config"`
        CreatedAt      time.Time   `json:"created_at" db:"created_at"`
        UpdatedAt      time.Time   `json:"updated_at" db:"updated_at"`
}

// GuildCreateRequest represents data needed to create a new guild
type GuildCreateRequest struct {
        DiscordGuildID string      `json:"discord_guild_id" validate:"required,min=17,max=19"`
        Name           string      `json:"name" validate:"required,min=1,max=100"`
        Slug           string      `json:"slug" validate:"required,min=1,max=50"`
        Config         GuildConfig `json:"config"`
}

// GuildUpdateRequest represents data needed to update an existing guild
type GuildUpdateRequest struct {
        Name   string      `json:"name" validate:"required,min=1,max=100"`
        Slug   string      `json:"slug" validate:"required,min=1,max=50"`
        Active bool        `json:"active"`
        Config GuildConfig `json:"config"`
}

// Value implements driver.Valuer for database compatibility
func (g Guild) Value() (driver.Value, error) <span class="cov0" title="0">{
        return g.ID, nil
}</span>

// Scan implements sql.Scanner for reading JSONB config from database
func (g *Guild) Scan(value any) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch v := value.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return json.Unmarshal(v, &amp;g.Config)</span>
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), &amp;g.Config)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// DisplayText returns the guild's display name for UI purposes
func (g *Guild) DisplayText() string <span class="cov0" title="0">{
        if g.Name == "" </span><span class="cov0" title="0">{
                return g.DiscordGuildID
        }</span>
        <span class="cov0" title="0">return g.Name</span>
}

// IsValidForUse checks if guild is active and properly configured
func (g *Guild) IsValidForUse() bool <span class="cov0" title="0">{
        return g.Active &amp;&amp; g.Config.Validate() == nil
}</span>

// GetDefaultConfig returns a new guild configuration with sensible defaults
func GetDefaultGuildConfig() GuildConfig <span class="cov0" title="0">{
        return GuildConfig{
                Discord: DiscordConfig{
                        AnnouncementChannelID: nil,
                        LeaderboardChannelID:  nil,
                        BotCommandPrefix:      "!usl",
                },
                Permissions: PermissionConfig{
                        AdminRoleIDs:     []string{},
                        ModeratorRoleIDs: []string{},
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package models

import (
        "fmt"
        "regexp"
)

const (
        // Default bot command prefix for new guilds
        DefaultBotCommandPrefix = "!usl"

        // Maximum length for bot command prefix
        MaxBotCommandPrefixLength = 5

        // Discord snowflake ID validation pattern (17-19 digits)
        DiscordSnowflakePattern = `^\d{17,19}$`
)

// GuildConfig represents the JSONB configuration for a Discord guild
type GuildConfig struct {
        Discord     DiscordConfig    `json:"discord"`
        Permissions PermissionConfig `json:"permissions"`
}

// DiscordConfig contains Discord-specific integration settings
type DiscordConfig struct {
        AnnouncementChannelID *string `json:"announcement_channel_id"`
        LeaderboardChannelID  *string `json:"leaderboard_channel_id"`
        BotCommandPrefix      string  `json:"bot_command_prefix"`
}

// PermissionConfig defines role-based permissions for the guild
type PermissionConfig struct {
        AdminRoleIDs     []string `json:"admin_role_ids"`
        ModeratorRoleIDs []string `json:"moderator_role_ids"`
}

// Discord snowflake ID validation regex
var discordSnowflakeRegex = regexp.MustCompile(DiscordSnowflakePattern)

// Validate ensures the guild configuration is valid
func (gc *GuildConfig) Validate() error <span class="cov0" title="0">{
        gc.setDefaults()

        if err := gc.validateRoleIDs(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := gc.validateChannelIDs(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return gc.validateBotCommandPrefix()</span>
}

// setDefaults applies sensible default values to the configuration
func (gc *GuildConfig) setDefaults() <span class="cov0" title="0">{
        if gc.Discord.BotCommandPrefix == "" </span><span class="cov0" title="0">{
                gc.Discord.BotCommandPrefix = DefaultBotCommandPrefix
        }</span>
}

// validateRoleIDs validates all role IDs in the configuration
func (gc *GuildConfig) validateRoleIDs() error <span class="cov0" title="0">{
        allRoleIDs := append(gc.Permissions.AdminRoleIDs, gc.Permissions.ModeratorRoleIDs...)
        for _, roleID := range allRoleIDs </span><span class="cov0" title="0">{
                if !isValidDiscordSnowflake(roleID) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid Discord role ID format: %s", roleID)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateChannelIDs validates channel IDs if they are provided
func (gc *GuildConfig) validateChannelIDs() error <span class="cov0" title="0">{
        if err := validateOptionalChannelID(gc.Discord.AnnouncementChannelID, "announcement"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return validateOptionalChannelID(gc.Discord.LeaderboardChannelID, "leaderboard")</span>
}

// validateBotCommandPrefix validates the bot command prefix
func (gc *GuildConfig) validateBotCommandPrefix() error <span class="cov0" title="0">{
        if len(gc.Discord.BotCommandPrefix) &gt; MaxBotCommandPrefixLength </span><span class="cov0" title="0">{
                return fmt.Errorf("bot command prefix too long (max %d characters): %s",
                        MaxBotCommandPrefixLength, gc.Discord.BotCommandPrefix)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateOptionalChannelID validates a channel ID if it's provided
func validateOptionalChannelID(channelID *string, channelType string) error <span class="cov0" title="0">{
        if channelID != nil &amp;&amp; !isValidDiscordSnowflake(*channelID) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Discord %s channel ID: %s", channelType, *channelID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// isValidDiscordSnowflake checks if a string is a valid Discord snowflake ID
func isValidDiscordSnowflake(id string) bool <span class="cov0" title="0">{
        return discordSnowflakeRegex.MatchString(id)
}</span>

// HasAdminRole checks if any of the provided role IDs match admin roles
func (gc *GuildConfig) HasAdminRole(userRoleIDs []string) bool <span class="cov0" title="0">{
        return hasAnyRole(userRoleIDs, gc.Permissions.AdminRoleIDs)
}</span>

// HasModeratorRole checks if any of the provided role IDs match moderator or admin roles
func (gc *GuildConfig) HasModeratorRole(userRoleIDs []string) bool <span class="cov0" title="0">{
        allModRoles := append(gc.Permissions.AdminRoleIDs, gc.Permissions.ModeratorRoleIDs...)
        return hasAnyRole(userRoleIDs, allModRoles)
}</span>

// hasAnyRole efficiently checks if any user role matches any allowed role
func hasAnyRole(userRoles, allowedRoles []string) bool <span class="cov0" title="0">{
        // Create a set of allowed roles for O(1) lookup
        allowedSet := make(map[string]bool, len(allowedRoles))
        for _, role := range allowedRoles </span><span class="cov0" title="0">{
                allowedSet[role] = true
        }</span>

        // Check if any user role exists in the allowed set
        <span class="cov0" title="0">for _, userRole := range userRoles </span><span class="cov0" title="0">{
                if allowedSet[userRole] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import (
        "fmt"
        "strconv"
        "strings"
        "time"
)

// PaginationParams represents pagination request parameters
type PaginationParams struct {
        Page   int    `json:"page" validate:"min=1"`
        Limit  int    `json:"limit" validate:"min=1,max=100"`
        Sort   string `json:"sort"`
        Order  string `json:"order" validate:"oneof=asc desc"`
        Cursor string `json:"cursor,omitempty"`
}

// PaginationMetadata represents pagination response metadata
type PaginationMetadata struct {
        Page       int    `json:"page"`
        Limit      int    `json:"limit"`
        Total      int64  `json:"total"`
        TotalPages int    `json:"total_pages"`
        HasNext    bool   `json:"has_next"`
        HasPrev    bool   `json:"has_prev"`
        NextCursor string `json:"next_cursor,omitempty"`
        PrevCursor string `json:"prev_cursor,omitempty"`
}

// ResponseMetadata represents general response metadata
type ResponseMetadata struct {
        Sort           string   `json:"sort"`
        Order          string   `json:"order"`
        FiltersApplied []string `json:"filters_applied"`
        QueryTime      string   `json:"query_time,omitempty"`
}

// PaginatedResponse represents a paginated API response
type PaginatedResponse[T any] struct {
        Data       []T                `json:"data"`
        Pagination PaginationMetadata `json:"pagination"`
        Meta       ResponseMetadata   `json:"meta"`
}

// UserFilters represents filtering parameters for users
type UserFilters struct {
        Search        string     `json:"search,omitempty"`
        Status        string     `json:"status,omitempty" validate:"omeof=active inactive banned"`
        MMRMin        *int       `json:"mmr_min,omitempty" validate:"omitempty,min=0"`
        MMRMax        *int       `json:"mmr_max,omitempty" validate:"omitempty,min=0"`
        CreatedAfter  *time.Time `json:"created_after,omitempty"`
        CreatedBefore *time.Time `json:"created_before,omitempty"`
        HasTrackers   *bool      `json:"has_trackers,omitempty"`
}

// TrackerFilters represents filtering parameters for trackers
type TrackerFilters struct {
        Valid         *bool      `json:"valid,omitempty"`
        Playlist      string     `json:"playlist,omitempty" validate:"omeof=ones twos threes"`
        PeakMin       *int       `json:"peak_min,omitempty" validate:"omitempty,min=0"`
        PeakMax       *int       `json:"peak_max,omitempty" validate:"omitempty,min=0"`
        DiscordID     string     `json:"discord_id,omitempty"`
        GamesMin      *int       `json:"games_min,omitempty" validate:"omitempty,min=0"`
        CreatedAfter  *time.Time `json:"created_after,omitempty"`
        CreatedBefore *time.Time `json:"created_before,omitempty"`
}

// BulkOperation represents a bulk operation request
type BulkOperation struct {
        Operation string                 `json:"operation" validate:"required,oneof=create update delete"`
        Filters   map[string]interface{} `json:"filters,omitempty"`
        Updates   map[string]interface{} `json:"updates,omitempty"`
        UserIDs   []string               `json:"user_ids,omitempty"`
        Data      []interface{}          `json:"data,omitempty"`
}

// BulkOperationResult represents the result of a single item in a bulk operation
type BulkOperationResult struct {
        ID     string      `json:"id"`
        Status string      `json:"status" validate:"oneof=success failed skipped"`
        Data   interface{} `json:"data,omitempty"`
        Error  string      `json:"error,omitempty"`
}

// BulkOperationResponse represents the response for a bulk operation
type BulkOperationResponse struct {
        TotalRequested int                   `json:"total_requested"`
        Successful     int                   `json:"successful"`
        Failed         int                   `json:"failed"`
        Skipped        int                   `json:"skipped"`
        Results        []BulkOperationResult `json:"results"`
        Errors         []string              `json:"errors,omitempty"`
        ProcessingTime string                `json:"processing_time"`
}

// NewPaginationParams creates PaginationParams with defaults
func NewPaginationParams(page, limit int, sort, order string) *PaginationParams <span class="cov0" title="0">{
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if limit &lt; 1 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov0" title="0">if sort == "" </span><span class="cov0" title="0">{
                sort = "created_at"
        }</span>
        <span class="cov0" title="0">if order == "" </span><span class="cov0" title="0">{
                order = "desc"
        }</span>

        <span class="cov0" title="0">return &amp;PaginationParams{
                Page:  page,
                Limit: limit,
                Sort:  sort,
                Order: order,
        }</span>
}

// CalculateOffset calculates the database offset for pagination
func (p *PaginationParams) CalculateOffset() int <span class="cov0" title="0">{
        return (p.Page - 1) * p.Limit
}</span>

// ValidateSort validates and sanitizes sort field names
func (p *PaginationParams) ValidateSort(allowedFields []string) error <span class="cov0" title="0">{
        if p.Sort == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, field := range allowedFields </span><span class="cov0" title="0">{
                if p.Sort == field </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("invalid sort field: %s", p.Sort)</span>
}

// CalculatePagination calculates pagination metadata
func CalculatePagination(params *PaginationParams, total int64) PaginationMetadata <span class="cov0" title="0">{
        totalPages := int((total + int64(params.Limit) - 1) / int64(params.Limit))

        return PaginationMetadata{
                Page:       params.Page,
                Limit:      params.Limit,
                Total:      total,
                TotalPages: totalPages,
                HasNext:    params.Page &lt; totalPages,
                HasPrev:    params.Page &gt; 1,
        }
}</span>

// ToFiltersApplied converts filter struct to string slice for metadata
func (uf *UserFilters) ToFiltersApplied() []string <span class="cov0" title="0">{
        var filters []string

        if uf.Search != "" </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("search=%s", uf.Search))
        }</span>
        <span class="cov0" title="0">if uf.Status != "" </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("status=%s", uf.Status))
        }</span>
        <span class="cov0" title="0">if uf.MMRMin != nil </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("mmr_min=%d", *uf.MMRMin))
        }</span>
        <span class="cov0" title="0">if uf.MMRMax != nil </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("mmr_max=%d", *uf.MMRMax))
        }</span>
        <span class="cov0" title="0">if uf.HasTrackers != nil </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("has_trackers=%t", *uf.HasTrackers))
        }</span>

        <span class="cov0" title="0">return filters</span>
}

// ToFiltersApplied converts filter struct to string slice for metadata
func (tf *TrackerFilters) ToFiltersApplied() []string <span class="cov0" title="0">{
        var filters []string

        if tf.Valid != nil </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("valid=%t", *tf.Valid))
        }</span>
        <span class="cov0" title="0">if tf.Playlist != "" </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("playlist=%s", tf.Playlist))
        }</span>
        <span class="cov0" title="0">if tf.PeakMin != nil </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("peak_min=%d", *tf.PeakMin))
        }</span>
        <span class="cov0" title="0">if tf.PeakMax != nil </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("peak_max=%d", *tf.PeakMax))
        }</span>
        <span class="cov0" title="0">if tf.DiscordID != "" </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("discord_id=%s", tf.DiscordID))
        }</span>

        <span class="cov0" title="0">return filters</span>
}

// ParseIntPointer safely parses a string to *int
func ParseIntPointer(s string) *int <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if val, err := strconv.Atoi(s); err == nil </span><span class="cov0" title="0">{
                return &amp;val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ParseBoolPointer safely parses a string to *bool
func ParseBoolPointer(s string) *bool <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val := strings.ToLower(s) == "true"
        return &amp;val</span>
}

// ParseTimePointer safely parses a string to *time.Time
func ParseTimePointer(s string) *time.Time <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if val, err := time.Parse(time.RFC3339, s); err == nil </span><span class="cov0" title="0">{
                return &amp;val
        }</span>
        // Try parsing without timezone
        <span class="cov0" title="0">if val, err := time.Parse("2006-01-02", s); err == nil </span><span class="cov0" title="0">{
                return &amp;val
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package models

import (
        "database/sql/driver"
        "time"
)

// PlayerEffectiveMMR represents current MMR/TrueSkill data for a user in a specific guild
type PlayerEffectiveMMR struct {
        ID             int64     `json:"id" db:"id"`
        UserID         int64     `json:"user_id" db:"user_id"`
        GuildID        int64     `json:"guild_id" db:"guild_id"`
        MMR            int       `json:"mmr" db:"mmr"`
        TrueSkillMu    float64   `json:"trueskill_mu" db:"trueskill_mu"`
        TrueSkillSigma float64   `json:"trueskill_sigma" db:"trueskill_sigma"`
        GamesPlayed    int       `json:"games_played" db:"games_played"`
        LastUpdated    time.Time `json:"last_updated" db:"last_updated"`
        CreatedAt      time.Time `json:"created_at" db:"created_at"`
        UpdatedAt      time.Time `json:"updated_at" db:"updated_at"`
}

// PlayerEffectiveMMRCreateRequest represents data needed to create a new player's MMR record
type PlayerEffectiveMMRCreateRequest struct {
        UserID         int64   `json:"user_id" validate:"required"`
        GuildID        int64   `json:"guild_id" validate:"required"`
        MMR            int     `json:"mmr" validate:"min=0"`
        TrueSkillMu    float64 `json:"trueskill_mu" validate:"min=0,max=5000"`
        TrueSkillSigma float64 `json:"trueskill_sigma" validate:"min=0,max=20"`
        GamesPlayed    int     `json:"games_played" validate:"min=0"`
}

// PlayerEffectiveMMRUpdateRequest represents data needed to update an existing player's MMR record
type PlayerEffectiveMMRUpdateRequest struct {
        MMR            int     `json:"mmr" validate:"min=0"`
        TrueSkillMu    float64 `json:"trueskill_mu" validate:"min=0,max=5000"`
        TrueSkillSigma float64 `json:"trueskill_sigma" validate:"min=0,max=20"`
        GamesPlayed    int     `json:"games_played" validate:"min=0"`
}

// Value implements driver.Valuer for database compatibility
func (p PlayerEffectiveMMR) Value() (driver.Value, error) <span class="cov0" title="0">{
        return p.ID, nil
}</span>

// IsValidForCompetition checks if player has enough games and valid stats for competitive play
func (p *PlayerEffectiveMMR) IsValidForCompetition(minGames int) bool <span class="cov0" title="0">{
        return p.GamesPlayed &gt;= minGames &amp;&amp; p.TrueSkillMu &gt; 0 &amp;&amp; p.TrueSkillSigma &gt; 0
}</span>

// GetSkillUncertainty returns a normalized uncertainty value (0-1, where 0 is certain)
func (p *PlayerEffectiveMMR) GetSkillUncertainty() float64 <span class="cov0" title="0">{
        // Higher sigma = more uncertainty
        // Normalize to 0-1 range where 8.333 (initial) = 1.0 and 0 = 0.0
        maxSigma := 8.333
        if p.TrueSkillSigma &gt;= maxSigma </span><span class="cov0" title="0">{
                return 1.0
        }</span>
        <span class="cov0" title="0">return p.TrueSkillSigma / maxSigma</span>
}

// GetSkillEstimate returns the conservative skill estimate (mu - 3*sigma)
func (p *PlayerEffectiveMMR) GetSkillEstimate() float64 <span class="cov0" title="0">{
        return p.TrueSkillMu - (3.0 * p.TrueSkillSigma)
}</span>

// HasRecentActivity checks if the player has been active recently
func (p *PlayerEffectiveMMR) HasRecentActivity(daysSince int) bool <span class="cov0" title="0">{
        cutoff := time.Now().AddDate(0, 0, -daysSince)
        return p.LastUpdated.After(cutoff)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package models

import (
        "database/sql/driver"
        "time"
)

// PlayerHistoricalMMR represents a change in a player's MMR/TrueSkill values
type PlayerHistoricalMMR struct {
        ID                   int64     `json:"id" db:"id"`
        UserID               int64     `json:"user_id" db:"user_id"`
        GuildID              int64     `json:"guild_id" db:"guild_id"`
        MMRBefore            *int      `json:"mmr_before" db:"mmr_before"`
        MMRAfter             int       `json:"mmr_after" db:"mmr_after"`
        TrueSkillMuBefore    *float64  `json:"trueskill_mu_before" db:"trueskill_mu_before"`
        TrueSkillMuAfter     float64   `json:"trueskill_mu_after" db:"trueskill_mu_after"`
        TrueSkillSigmaBefore *float64  `json:"trueskill_sigma_before" db:"trueskill_sigma_before"`
        TrueSkillSigmaAfter  float64   `json:"trueskill_sigma_after" db:"trueskill_sigma_after"`
        ChangeReason         string    `json:"change_reason" db:"change_reason"`
        MatchID              *int64    `json:"match_id" db:"match_id"`
        ChangedByUserID      *int64    `json:"changed_by_user_id" db:"changed_by_user_id"`
        CreatedAt            time.Time `json:"created_at" db:"created_at"`
}

// ChangeReason constants for different types of MMR changes
const (
        ChangeReasonMatchResult      = "match_result"
        ChangeReasonManualAdjustment = "manual_adjustment"
        ChangeReasonSeasonReset      = "season_reset"
        ChangeReasonInitialSetup     = "initial_setup"
        ChangeReasonRecalculation    = "recalculation"
)

// PlayerHistoricalMMRCreateRequest represents data needed to create a new historical MMR record
type PlayerHistoricalMMRCreateRequest struct {
        UserID               int64    `json:"user_id" validate:"required"`
        GuildID              int64    `json:"guild_id" validate:"required"`
        MMRBefore            *int     `json:"mmr_before"`
        MMRAfter             int      `json:"mmr_after" validate:"min=0"`
        TrueSkillMuBefore    *float64 `json:"trueskill_mu_before"`
        TrueSkillMuAfter     float64  `json:"trueskill_mu_after" validate:"min=0,max=5000"`
        TrueSkillSigmaBefore *float64 `json:"trueskill_sigma_before"`
        TrueSkillSigmaAfter  float64  `json:"trueskill_sigma_after" validate:"min=0,max=20"`
        ChangeReason         string   `json:"change_reason" validate:"required,oneof=match_result manual_adjustment season_reset initial_setup recalculation"`
        MatchID              *int64   `json:"match_id"`
        ChangedByUserID      *int64   `json:"changed_by_user_id"`
}

// Value implements driver.Valuer for database compatibility
func (p PlayerHistoricalMMR) Value() (driver.Value, error) <span class="cov0" title="0">{
        return p.ID, nil
}</span>

// GetMMRChange returns the difference in MMR (positive = gain, negative = loss)
func (p *PlayerHistoricalMMR) GetMMRChange() int <span class="cov0" title="0">{
        if p.MMRBefore == nil </span><span class="cov0" title="0">{
                return p.MMRAfter // Initial setup case
        }</span>
        <span class="cov0" title="0">return p.MMRAfter - *p.MMRBefore</span>
}

// GetTrueSkillMuChange returns the difference in TrueSkill mu
func (p *PlayerHistoricalMMR) GetTrueSkillMuChange() float64 <span class="cov0" title="0">{
        if p.TrueSkillMuBefore == nil </span><span class="cov0" title="0">{
                return p.TrueSkillMuAfter // Initial setup case
        }</span>
        <span class="cov0" title="0">return p.TrueSkillMuAfter - *p.TrueSkillMuBefore</span>
}

// GetTrueSkillSigmaChange returns the difference in TrueSkill sigma
func (p *PlayerHistoricalMMR) GetTrueSkillSigmaChange() float64 <span class="cov0" title="0">{
        if p.TrueSkillSigmaBefore == nil </span><span class="cov0" title="0">{
                return p.TrueSkillSigmaAfter // Initial setup case
        }</span>
        <span class="cov0" title="0">return p.TrueSkillSigmaAfter - *p.TrueSkillSigmaBefore</span>
}

// IsInitialRecord checks if this is the player's first MMR record
func (p *PlayerHistoricalMMR) IsInitialRecord() bool <span class="cov0" title="0">{
        return p.MMRBefore == nil &amp;&amp; p.TrueSkillMuBefore == nil &amp;&amp; p.TrueSkillSigmaBefore == nil
}</span>

// IsMatchResult checks if this change was due to a match result
func (p *PlayerHistoricalMMR) IsMatchResult() bool <span class="cov0" title="0">{
        return p.ChangeReason == ChangeReasonMatchResult
}</span>

// IsManualAdjustment checks if this change was made manually by an admin
func (p *PlayerHistoricalMMR) IsManualAdjustment() bool <span class="cov0" title="0">{
        return p.ChangeReason == ChangeReasonManualAdjustment
}</span>

// GetChangeDescription returns a human-readable description of the change
func (p *PlayerHistoricalMMR) GetChangeDescription() string <span class="cov0" title="0">{
        mmrChange := p.GetMMRChange()

        switch p.ChangeReason </span>{
        case ChangeReasonMatchResult:<span class="cov0" title="0">
                if mmrChange &gt; 0 </span><span class="cov0" title="0">{
                        return "Won match"
                }</span> else<span class="cov0" title="0"> if mmrChange &lt; 0 </span><span class="cov0" title="0">{
                        return "Lost match"
                }</span>
                <span class="cov0" title="0">return "Match played"</span>
        case ChangeReasonManualAdjustment:<span class="cov0" title="0">
                return "Manual adjustment"</span>
        case ChangeReasonSeasonReset:<span class="cov0" title="0">
                return "Season reset"</span>
        case ChangeReasonInitialSetup:<span class="cov0" title="0">
                return "Initial setup"</span>
        case ChangeReasonRecalculation:<span class="cov0" title="0">
                return "Recalculation"</span>
        default:<span class="cov0" title="0">
                return "Unknown change"</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package models

import (
        "database/sql/driver"
        "strings"
        "time"
)

// UserTracker represents the tracker entity, matching the Google Sheets UserTracker schema exactly
type UserTracker struct {
        ID                        int       `json:"id" db:"id"`
        DiscordID                 string    `json:"discord_id" db:"discord_id" validate:"required,min=17,max=19"`
        URL                       string    `json:"url" db:"url" validate:"required,max=1000"`
        OnesCurrentSeasonPeak     int       `json:"ones_current_season_peak" db:"ones_current_season_peak"`
        OnesPreviousSeasonPeak    int       `json:"ones_previous_season_peak" db:"ones_previous_season_peak"`
        OnesAllTimePeak           int       `json:"ones_all_time_peak" db:"ones_all_time_peak"`
        OnesCurrentSeasonGames    int       `json:"ones_current_season_games" db:"ones_current_season_games"`
        OnesPreviousSeasonGames   int       `json:"ones_previous_season_games" db:"ones_previous_season_games"`
        TwosCurrentSeasonPeak     int       `json:"twos_current_season_peak" db:"twos_current_season_peak"`
        TwosPreviousSeasonPeak    int       `json:"twos_previous_season_peak" db:"twos_previous_season_peak"`
        TwosAllTimePeak           int       `json:"twos_all_time_peak" db:"twos_all_time_peak"`
        TwosCurrentSeasonGames    int       `json:"twos_current_season_games" db:"twos_current_season_games"`
        TwosPreviousSeasonGames   int       `json:"twos_previous_season_games" db:"twos_previous_season_games"`
        ThreesCurrentSeasonPeak   int       `json:"threes_current_season_peak" db:"threes_current_season_peak"`
        ThreesPreviousSeasonPeak  int       `json:"threes_previous_season_peak" db:"threes_previous_season_peak"`
        ThreesAllTimePeak         int       `json:"threes_all_time_peak" db:"threes_all_time_peak"`
        ThreesCurrentSeasonGames  int       `json:"threes_current_season_games" db:"threes_current_season_games"`
        ThreesPreviousSeasonGames int       `json:"threes_previous_season_games" db:"threes_previous_season_games"`
        LastUpdated               time.Time `json:"last_updated" db:"last_updated"`
        Valid                     bool      `json:"valid" db:"valid"`
        CalculatedMMR             int       `json:"calculated_mmr" db:"calculated_mmr"`
        CreatedAt                 time.Time `json:"created_at" db:"created_at"`
        UpdatedAt                 time.Time `json:"updated_at" db:"updated_at"`

        // Computed fields (not stored in database)
        PlatformInfo string `json:"platform_info,omitempty"`
        DisplayText  string `json:"display_text,omitempty"`
}

// TrackerCreateRequest matches the form data from AddUserTrackerForm.html
type TrackerCreateRequest struct {
        DiscordID                 string `json:"discord_id" validate:"required,min=17,max=19"`
        URL                       string `json:"url" validate:"required,max=1000"`
        OnesCurrentSeasonPeak     int    `json:"ones_current_season_peak"`
        OnesPreviousSeasonPeak    int    `json:"ones_previous_season_peak"`
        OnesAllTimePeak           int    `json:"ones_all_time_peak"`
        OnesCurrentSeasonGames    int    `json:"ones_current_season_games"`
        OnesPreviousSeasonGames   int    `json:"ones_previous_season_games"`
        TwosCurrentSeasonPeak     int    `json:"twos_current_season_peak"`
        TwosPreviousSeasonPeak    int    `json:"twos_previous_season_peak"`
        TwosAllTimePeak           int    `json:"twos_all_time_peak"`
        TwosCurrentSeasonGames    int    `json:"twos_current_season_games"`
        TwosPreviousSeasonGames   int    `json:"twos_previous_season_games"`
        ThreesCurrentSeasonPeak   int    `json:"threes_current_season_peak"`
        ThreesPreviousSeasonPeak  int    `json:"threes_previous_season_peak"`
        ThreesAllTimePeak         int    `json:"threes_all_time_peak"`
        ThreesCurrentSeasonGames  int    `json:"threes_current_season_games"`
        ThreesPreviousSeasonGames int    `json:"threes_previous_season_games"`
        Valid                     bool   `json:"valid"`
}

// TrackerUpdateRequest matches the form data from UpdateUserTrackerForm.html
type TrackerUpdateRequest struct {
        DiscordID                 string `json:"discord_id" validate:"required,min=17,max=19"`
        URL                       string `json:"url" validate:"required,max=1000"`
        OnesCurrentSeasonPeak     int    `json:"ones_current_season_peak"`
        OnesPreviousSeasonPeak    int    `json:"ones_previous_season_peak"`
        OnesAllTimePeak           int    `json:"ones_all_time_peak"`
        OnesCurrentSeasonGames    int    `json:"ones_current_season_games"`
        OnesPreviousSeasonGames   int    `json:"ones_previous_season_games"`
        TwosCurrentSeasonPeak     int    `json:"twos_current_season_peak"`
        TwosPreviousSeasonPeak    int    `json:"twos_previous_season_peak"`
        TwosAllTimePeak           int    `json:"twos_all_time_peak"`
        TwosCurrentSeasonGames    int    `json:"twos_current_season_games"`
        TwosPreviousSeasonGames   int    `json:"twos_previous_season_games"`
        ThreesCurrentSeasonPeak   int    `json:"threes_current_season_peak"`
        ThreesPreviousSeasonPeak  int    `json:"threes_previous_season_peak"`
        ThreesAllTimePeak         int    `json:"threes_all_time_peak"`
        ThreesCurrentSeasonGames  int    `json:"threes_current_season_games"`
        ThreesPreviousSeasonGames int    `json:"threes_previous_season_games"`
        Valid                     bool   `json:"valid"`
}

// TrackerStats represents tracker statistics, matching JavaScript getTrackerStats() output
type TrackerStats struct {
        TotalTrackers          int     `json:"totalTrackers"`
        ValidTrackers          int     `json:"validTrackers"`
        AverageMMR             float64 `json:"averageMMR"`
        UniqueUsers            int     `json:"uniqueUsers"`
        AverageGamesPerTracker float64 `json:"averageGamesPerTracker"`
}

// Value implements driver.Valuer for database compatibility
func (ut UserTracker) Value() (driver.Value, error) <span class="cov0" title="0">{
        return ut.ID, nil
}</span>

// ParsePlatformInfo extracts platform information from tracker URL
// Matches JavaScript parseTrackerUrl() function
func (ut *UserTracker) ParsePlatformInfo() string <span class="cov0" title="0">{
        if ut.URL == "" </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov0" title="0">url := strings.ToLower(ut.URL)

        if strings.Contains(url, "/steam/") </span><span class="cov0" title="0">{
                return "steam"
        }</span> else<span class="cov0" title="0"> if strings.Contains(url, "/epic/") </span><span class="cov0" title="0">{
                return "epic"
        }</span> else<span class="cov0" title="0"> if strings.Contains(url, "/psn/") </span><span class="cov0" title="0">{
                return "psn"
        }</span> else<span class="cov0" title="0"> if strings.Contains(url, "/xbl/") </span><span class="cov0" title="0">{
                return "xbox"
        }</span>

        <span class="cov0" title="0">return "unknown"</span>
}

// GenerateDisplayText creates display text for UI purposes
// Matches JavaScript tracker.displayText generation
func (ut *UserTracker) GenerateDisplayText() string <span class="cov0" title="0">{
        platformInfo := ut.ParsePlatformInfo()
        return "/" + platformInfo + " " + string(rune(ut.CalculatedMMR))
}</span>

// TotalGamesPlayed calculates total games across all playlists
func (ut *UserTracker) TotalGamesPlayed() int <span class="cov0" title="0">{
        return ut.OnesCurrentSeasonGames + ut.OnesPreviousSeasonGames +
                ut.TwosCurrentSeasonGames + ut.TwosPreviousSeasonGames +
                ut.ThreesCurrentSeasonGames + ut.ThreesPreviousSeasonGames
}</span>

// HasGameData checks if the tracker has meaningful game data
func (ut *UserTracker) HasGameData() bool <span class="cov0" title="0">{
        return ut.TotalGamesPlayed() &gt; 0 ||
                ut.OnesCurrentSeasonPeak &gt; 0 || ut.OnesPreviousSeasonPeak &gt; 0 ||
                ut.TwosCurrentSeasonPeak &gt; 0 || ut.TwosPreviousSeasonPeak &gt; 0 ||
                ut.ThreesCurrentSeasonPeak &gt; 0 || ut.ThreesPreviousSeasonPeak &gt; 0
}</span>

// IsValidTracker checks if tracker should be considered for calculations
func (ut *UserTracker) IsValidTracker() bool <span class="cov0" title="0">{
        return ut.Valid &amp;&amp; ut.HasGameData()
}</span>

// Tracker is an alias for UserTracker to match service naming conventions
type Tracker = UserTracker
</pre>
		
		<pre class="file" id="file18" style="display: none">package models

import (
        "database/sql/driver"
        "time"
)

// User represents the user entity, matching the Google Sheets User schema exactly
type User struct {
        ID                   int       `json:"id" db:"id"`
        Name                 string    `json:"name" db:"name" validate:"required,min=1,max=50"`
        DiscordID            string    `json:"discord_id" db:"discord_id" validate:"required,min=17,max=19"`
        Active               bool      `json:"active" db:"active"`
        Banned               bool      `json:"banned" db:"banned"`
        MMR                  int       `json:"mmr" db:"mmr"`
        TrueSkillMu          float64   `json:"trueskill_mu" db:"trueskill_mu"`
        TrueSkillSigma       float64   `json:"trueskill_sigma" db:"trueskill_sigma"`
        TrueSkillLastUpdated time.Time `json:"trueskill_last_updated" db:"trueskill_last_updated"`
        CreatedAt            time.Time `json:"created_at" db:"created_at"`
        UpdatedAt            time.Time `json:"updated_at" db:"updated_at"`
}

// UserCreateRequest matches the form data from AddUserForm.html
type UserCreateRequest struct {
        Name      string `json:"name" validate:"required,min=1,max=50"`
        DiscordID string `json:"discord_id" validate:"required,min=17,max=19"`
        Active    bool   `json:"active"`
        Banned    bool   `json:"banned"`
        MMR       int    `json:"mmr"`
}

// UserUpdateRequest matches the form data from UpdateUserForm.html (restricted fields only)
type UserUpdateRequest struct {
        Name   string `json:"name" validate:"required,min=1,max=50"`
        Active bool   `json:"active"`
        Banned bool   `json:"banned"`
}

// UserStats represents user statistics, matching JavaScript getUserStats() output
type UserStats struct {
        TotalUsers         int     `json:"totalUsers"`
        ActiveUsers        int     `json:"activeUsers"`
        BannedUsers        int     `json:"bannedUsers"`
        AverageMMR         float64 `json:"averageMMR"`
        AverageTrueSkillMu float64 `json:"averageTrueSkillMu"`
}

// Value implements driver.Valuer for database compatibility
func (u User) Value() (driver.Value, error) <span class="cov0" title="0">{
        return u.ID, nil
}</span>

// DisplayText returns the user's display name for UI purposes
func (u *User) DisplayText() string <span class="cov0" title="0">{
        if u.Name == "" </span><span class="cov0" title="0">{
                return u.DiscordID
        }</span>
        <span class="cov0" title="0">return u.Name</span>
}

// IsValidForPlay checks if user can participate in matches
func (u *User) IsValidForPlay() bool <span class="cov0" title="0">{
        return u.Active &amp;&amp; !u.Banned
}</span>

// HasTrueSkillData checks if the user has been processed by TrueSkill engine
func (u *User) HasTrueSkillData() bool <span class="cov0" title="0">{
        return u.TrueSkillMu != 0 || u.TrueSkillSigma != 0
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package models

import (
        "database/sql/driver"
        "time"
)

// UserGuildMembership represents a user's membership in a Discord guild
type UserGuildMembership struct {
        ID             int64     `json:"id" db:"id"`
        UserID         int64     `json:"user_id" db:"user_id"`
        GuildID        int64     `json:"guild_id" db:"guild_id"`
        DiscordRoles   []string  `json:"discord_roles" db:"discord_roles"`
        USLPermissions []string  `json:"usl_permissions" db:"usl_permissions"`
        JoinedAt       time.Time `json:"joined_at" db:"joined_at"`
        Active         bool      `json:"active" db:"active"`
        CreatedAt      time.Time `json:"created_at" db:"created_at"`
        UpdatedAt      time.Time `json:"updated_at" db:"updated_at"`
}

// USL Permission constants
const (
        PermissionAdmin       = "admin"
        PermissionModerator   = "moderator"
        PermissionStatsViewer = "stats_viewer"
        PermissionUserManager = "user_manager"
)

// UserGuildMembershipCreateRequest represents data needed to create a new membership
type UserGuildMembershipCreateRequest struct {
        UserID         int64    `json:"user_id" validate:"required"`
        GuildID        int64    `json:"guild_id" validate:"required"`
        DiscordRoles   []string `json:"discord_roles"`
        USLPermissions []string `json:"usl_permissions"`
        Active         bool     `json:"active"`
}

// UserGuildMembershipUpdateRequest represents data needed to update an existing membership
type UserGuildMembershipUpdateRequest struct {
        DiscordRoles   []string `json:"discord_roles"`
        USLPermissions []string `json:"usl_permissions"`
        Active         bool     `json:"active"`
}

// Value implements driver.Valuer for database compatibility
func (m UserGuildMembership) Value() (driver.Value, error) <span class="cov0" title="0">{
        return m.ID, nil
}</span>

func (m *UserGuildMembership) HasPermission(permission string) bool <span class="cov0" title="0">{
        for _, p := range m.USLPermissions </span><span class="cov0" title="0">{
                if p == permission </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (m *UserGuildMembership) HasDiscordRole(roleID string) bool <span class="cov0" title="0">{
        for _, r := range m.DiscordRoles </span><span class="cov0" title="0">{
                if r == roleID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (m *UserGuildMembership) IsAdmin() bool <span class="cov0" title="0">{
        return m.HasPermission(PermissionAdmin)
}</span>

func (m *UserGuildMembership) IsModerator() bool <span class="cov0" title="0">{
        return m.HasPermission(PermissionAdmin) || m.HasPermission(PermissionModerator)
}</span>

func (m *UserGuildMembership) CanAddUsers() bool <span class="cov0" title="0">{
        return m.IsModerator() || m.HasPermission(PermissionUserManager)
}</span>

func (m *UserGuildMembership) CanViewStats() bool <span class="cov0" title="0">{
        return m.IsAdmin() || m.IsModerator() || m.HasPermission(PermissionStatsViewer)
}</span>

func (m *UserGuildMembership) GetPermissionLevel() string <span class="cov0" title="0">{
        if m.IsAdmin() </span><span class="cov0" title="0">{
                return "Admin"
        }</span>
        <span class="cov0" title="0">if m.HasPermission(PermissionModerator) </span><span class="cov0" title="0">{
                return "Moderator"
        }</span>
        <span class="cov0" title="0">if m.HasPermission(PermissionUserManager) </span><span class="cov0" title="0">{
                return "User Manager"
        }</span>
        <span class="cov0" title="0">if m.HasPermission(PermissionStatsViewer) </span><span class="cov0" title="0">{
                return "Stats Viewer"
        }</span>
        <span class="cov0" title="0">return "Member"</span>
}

func (m *UserGuildMembership) IsValidMembership() bool <span class="cov0" title="0">{
        return m.Active &amp;&amp; m.UserID &gt; 0 &amp;&amp; m.GuildID &gt; 0
}</span>

func (m *UserGuildMembership) GetMembershipDuration() time.Duration <span class="cov0" title="0">{
        return time.Since(m.JoinedAt)
}</span>

// AddPermission adds a USL permission if not already present
func (m *UserGuildMembership) AddPermission(permission string) <span class="cov0" title="0">{
        if !m.HasPermission(permission) </span><span class="cov0" title="0">{
                m.USLPermissions = append(m.USLPermissions, permission)
        }</span>
}

// RemovePermission removes a USL permission if present
func (m *UserGuildMembership) RemovePermission(permission string) <span class="cov0" title="0">{
        m.USLPermissions = removeStringFromSlice(m.USLPermissions, permission)
}</span>

// AddDiscordRole adds a Discord role if not already present
func (m *UserGuildMembership) AddDiscordRole(roleID string) <span class="cov0" title="0">{
        if !m.HasDiscordRole(roleID) </span><span class="cov0" title="0">{
                m.DiscordRoles = append(m.DiscordRoles, roleID)
        }</span>
}

// RemoveDiscordRole removes a Discord role if present
func (m *UserGuildMembership) RemoveDiscordRole(roleID string) <span class="cov0" title="0">{
        m.DiscordRoles = removeStringFromSlice(m.DiscordRoles, roleID)
}</span>

// removeStringFromSlice removes the first occurrence of a string from a slice
func removeStringFromSlice(slice []string, item string) []string <span class="cov0" title="0">{
        for i, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return append(slice[:i], slice[i+1:]...)
                }</span>
        }
        <span class="cov0" title="0">return slice</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package models

import (
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"
)

// ValidationError represents a validation error with field details
type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
        Value   string `json:"value,omitempty"`
}

// ValidationErrors represents multiple validation errors
type ValidationErrors []ValidationError

func (ve ValidationErrors) Error() string <span class="cov0" title="0">{
        if len(ve) == 0 </span><span class="cov0" title="0">{
                return "validation failed"
        }</span>

        <span class="cov0" title="0">var messages []string
        for _, err := range ve </span><span class="cov0" title="0">{
                messages = append(messages, fmt.Sprintf("%s: %s", err.Field, err.Message))
        }</span>

        <span class="cov0" title="0">return strings.Join(messages, "; ")</span>
}

// RequestParser handles parsing and validation of HTTP request parameters
type RequestParser struct {
        errors ValidationErrors
}

// NewRequestParser creates a new request parser
func NewRequestParser() *RequestParser <span class="cov0" title="0">{
        return &amp;RequestParser{
                errors: make(ValidationErrors, 0),
        }
}</span>

// ParsePaginationParams parses pagination parameters from HTTP request
func (rp *RequestParser) ParsePaginationParams(r *http.Request) *PaginationParams <span class="cov0" title="0">{
        params := &amp;PaginationParams{
                Page:  1,
                Limit: 20,
                Sort:  "created_at",
                Order: "desc",
        }

        // Parse page
        if pageStr := r.URL.Query().Get("page"); pageStr != "" </span><span class="cov0" title="0">{
                if page, err := strconv.Atoi(pageStr); err != nil </span><span class="cov0" title="0">{
                        rp.AddError("page", "must be a valid integer", pageStr)
                }</span> else<span class="cov0" title="0"> if page &lt; 1 </span><span class="cov0" title="0">{
                        rp.AddError("page", "must be greater than 0", pageStr)
                }</span> else<span class="cov0" title="0"> {
                        params.Page = page
                }</span>
        }

        // Parse limit
        <span class="cov0" title="0">if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err != nil </span><span class="cov0" title="0">{
                        rp.AddError("limit", "must be a valid integer", limitStr)
                }</span> else<span class="cov0" title="0"> if limit &lt; 1 </span><span class="cov0" title="0">{
                        rp.AddError("limit", "must be greater than 0", limitStr)
                }</span> else<span class="cov0" title="0"> if limit &gt; 100 </span><span class="cov0" title="0">{
                        rp.AddError("limit", "must not exceed 100", limitStr)
                }</span> else<span class="cov0" title="0"> {
                        params.Limit = limit
                }</span>
        }

        // Parse sort
        <span class="cov0" title="0">if sort := r.URL.Query().Get("sort"); sort != "" </span><span class="cov0" title="0">{
                params.Sort = sort
        }</span>

        // Parse order
        <span class="cov0" title="0">if order := r.URL.Query().Get("order"); order != "" </span><span class="cov0" title="0">{
                if order != "asc" &amp;&amp; order != "desc" </span><span class="cov0" title="0">{
                        rp.AddError("order", "must be 'asc' or 'desc'", order)
                }</span> else<span class="cov0" title="0"> {
                        params.Order = order
                }</span>
        }

        // Parse cursor
        <span class="cov0" title="0">if cursor := r.URL.Query().Get("cursor"); cursor != "" </span><span class="cov0" title="0">{
                params.Cursor = cursor
        }</span>

        <span class="cov0" title="0">return params</span>
}

// ParseUserFilters parses user filter parameters from HTTP request
func (rp *RequestParser) ParseUserFilters(r *http.Request) *UserFilters <span class="cov0" title="0">{
        filters := &amp;UserFilters{}

        // Parse search
        if search := r.URL.Query().Get("search"); search != "" </span><span class="cov0" title="0">{
                filters.Search = strings.TrimSpace(search)
        }</span>

        // Parse status
        <span class="cov0" title="0">if status := r.URL.Query().Get("status"); status != "" </span><span class="cov0" title="0">{
                if !isValidUserStatus(status) </span><span class="cov0" title="0">{
                        rp.AddError("status", "must be 'active', 'inactive', or 'banned'", status)
                }</span> else<span class="cov0" title="0"> {
                        filters.Status = status
                }</span>
        }

        // Parse MMR range
        <span class="cov0" title="0">if mmrMinStr := r.URL.Query().Get("mmr_min"); mmrMinStr != "" </span><span class="cov0" title="0">{
                if mmrMin, err := strconv.Atoi(mmrMinStr); err != nil </span><span class="cov0" title="0">{
                        rp.AddError("mmr_min", "must be a valid integer", mmrMinStr)
                }</span> else<span class="cov0" title="0"> if mmrMin &lt; 0 </span><span class="cov0" title="0">{
                        rp.AddError("mmr_min", "must be non-negative", mmrMinStr)
                }</span> else<span class="cov0" title="0"> {
                        filters.MMRMin = &amp;mmrMin
                }</span>
        }

        <span class="cov0" title="0">if mmrMaxStr := r.URL.Query().Get("mmr_max"); mmrMaxStr != "" </span><span class="cov0" title="0">{
                if mmrMax, err := strconv.Atoi(mmrMaxStr); err != nil </span><span class="cov0" title="0">{
                        rp.AddError("mmr_max", "must be a valid integer", mmrMaxStr)
                }</span> else<span class="cov0" title="0"> if mmrMax &lt; 0 </span><span class="cov0" title="0">{
                        rp.AddError("mmr_max", "must be non-negative", mmrMaxStr)
                }</span> else<span class="cov0" title="0"> {
                        filters.MMRMax = &amp;mmrMax
                }</span>
        }

        // Validate MMR range
        <span class="cov0" title="0">if isInvalidRange(filters.MMRMin, filters.MMRMax) </span><span class="cov0" title="0">{
                rp.AddError("mmr_range", "mmr_min must be less than or equal to mmr_max",
                        fmt.Sprintf("min=%d, max=%d", *filters.MMRMin, *filters.MMRMax))
        }</span>

        // Parse date range
        <span class="cov0" title="0">if createdAfterStr := r.URL.Query().Get("created_after"); createdAfterStr != "" </span><span class="cov0" title="0">{
                if createdAfter, err := time.Parse(time.RFC3339, createdAfterStr); err != nil </span><span class="cov0" title="0">{
                        // Try parsing date-only format
                        if createdAfter, err := time.Parse("2006-01-02", createdAfterStr); err != nil </span><span class="cov0" title="0">{
                                rp.AddError("created_after", "must be a valid date (YYYY-MM-DD or RFC3339)", createdAfterStr)
                        }</span> else<span class="cov0" title="0"> {
                                filters.CreatedAfter = &amp;createdAfter
                        }</span>
                } else<span class="cov0" title="0"> {
                        filters.CreatedAfter = &amp;createdAfter
                }</span>
        }

        <span class="cov0" title="0">if createdBeforeStr := r.URL.Query().Get("created_before"); createdBeforeStr != "" </span><span class="cov0" title="0">{
                if createdBefore, err := time.Parse(time.RFC3339, createdBeforeStr); err != nil </span><span class="cov0" title="0">{
                        // Try parsing date-only format
                        if createdBefore, err := time.Parse("2006-01-02", createdBeforeStr); err != nil </span><span class="cov0" title="0">{
                                rp.AddError("created_before", "must be a valid date (YYYY-MM-DD or RFC3339)", createdBeforeStr)
                        }</span> else<span class="cov0" title="0"> {
                                filters.CreatedBefore = &amp;createdBefore
                        }</span>
                } else<span class="cov0" title="0"> {
                        filters.CreatedBefore = &amp;createdBefore
                }</span>
        }

        // Parse has_trackers
        <span class="cov0" title="0">if hasTrackersStr := r.URL.Query().Get("has_trackers"); hasTrackersStr != "" </span><span class="cov0" title="0">{
                if hasTrackersStr != "true" &amp;&amp; hasTrackersStr != "false" </span><span class="cov0" title="0">{
                        rp.AddError("has_trackers", "must be 'true' or 'false'", hasTrackersStr)
                }</span> else<span class="cov0" title="0"> {
                        hasTrackers := hasTrackersStr == "true"
                        filters.HasTrackers = &amp;hasTrackers
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

// ParseTrackerFilters parses tracker filter parameters from HTTP request
func (rp *RequestParser) ParseTrackerFilters(r *http.Request) *TrackerFilters <span class="cov0" title="0">{
        filters := &amp;TrackerFilters{}

        // Parse valid
        if validStr := r.URL.Query().Get("valid"); validStr != "" </span><span class="cov0" title="0">{
                if validStr != "true" &amp;&amp; validStr != "false" </span><span class="cov0" title="0">{
                        rp.AddError("valid", "must be 'true' or 'false'", validStr)
                }</span> else<span class="cov0" title="0"> {
                        valid := validStr == "true"
                        filters.Valid = &amp;valid
                }</span>
        }

        // Parse playlist
        <span class="cov0" title="0">if playlist := r.URL.Query().Get("playlist"); playlist != "" </span><span class="cov0" title="0">{
                if !isValidPlaylist(playlist) </span><span class="cov0" title="0">{
                        rp.AddError("playlist", "must be 'ones', 'twos', or 'threes'", playlist)
                }</span> else<span class="cov0" title="0"> {
                        filters.Playlist = playlist
                }</span>
        }

        // Parse peak range
        <span class="cov0" title="0">if peakMinStr := r.URL.Query().Get("peak_min"); peakMinStr != "" </span><span class="cov0" title="0">{
                if peakMin, err := strconv.Atoi(peakMinStr); err != nil </span><span class="cov0" title="0">{
                        rp.AddError("peak_min", "must be a valid integer", peakMinStr)
                }</span> else<span class="cov0" title="0"> if peakMin &lt; 0 </span><span class="cov0" title="0">{
                        rp.AddError("peak_min", "must be non-negative", peakMinStr)
                }</span> else<span class="cov0" title="0"> {
                        filters.PeakMin = &amp;peakMin
                }</span>
        }

        <span class="cov0" title="0">if peakMaxStr := r.URL.Query().Get("peak_max"); peakMaxStr != "" </span><span class="cov0" title="0">{
                if peakMax, err := strconv.Atoi(peakMaxStr); err != nil </span><span class="cov0" title="0">{
                        rp.AddError("peak_max", "must be a valid integer", peakMaxStr)
                }</span> else<span class="cov0" title="0"> if peakMax &lt; 0 </span><span class="cov0" title="0">{
                        rp.AddError("peak_max", "must be non-negative", peakMaxStr)
                }</span> else<span class="cov0" title="0"> {
                        filters.PeakMax = &amp;peakMax
                }</span>
        }

        // Validate peak range
        <span class="cov0" title="0">if isInvalidRange(filters.PeakMin, filters.PeakMax) </span><span class="cov0" title="0">{
                rp.AddError("peak_range", "peak_min must be less than or equal to peak_max",
                        fmt.Sprintf("min=%d, max=%d", *filters.PeakMin, *filters.PeakMax))
        }</span>

        // Parse discord_id
        <span class="cov0" title="0">if discordID := r.URL.Query().Get("discord_id"); discordID != "" </span><span class="cov0" title="0">{
                if len(discordID) &lt; 17 || len(discordID) &gt; 19 </span><span class="cov0" title="0">{
                        rp.AddError("discord_id", "must be 17-19 characters long", discordID)
                }</span> else<span class="cov0" title="0"> {
                        filters.DiscordID = discordID
                }</span>
        }

        // Parse games range
        <span class="cov0" title="0">if gamesMinStr := r.URL.Query().Get("games_min"); gamesMinStr != "" </span><span class="cov0" title="0">{
                if gamesMin, err := strconv.Atoi(gamesMinStr); err != nil </span><span class="cov0" title="0">{
                        rp.AddError("games_min", "must be a valid integer", gamesMinStr)
                }</span> else<span class="cov0" title="0"> if gamesMin &lt; 0 </span><span class="cov0" title="0">{
                        rp.AddError("games_min", "must be non-negative", gamesMinStr)
                }</span> else<span class="cov0" title="0"> {
                        filters.GamesMin = &amp;gamesMin
                }</span>
        }

        // Parse date range
        <span class="cov0" title="0">if createdAfterStr := r.URL.Query().Get("created_after"); createdAfterStr != "" </span><span class="cov0" title="0">{
                if createdAfter, err := time.Parse(time.RFC3339, createdAfterStr); err != nil </span><span class="cov0" title="0">{
                        if createdAfter, err := time.Parse("2006-01-02", createdAfterStr); err != nil </span><span class="cov0" title="0">{
                                rp.AddError("created_after", "must be a valid date (YYYY-MM-DD or RFC3339)", createdAfterStr)
                        }</span> else<span class="cov0" title="0"> {
                                filters.CreatedAfter = &amp;createdAfter
                        }</span>
                } else<span class="cov0" title="0"> {
                        filters.CreatedAfter = &amp;createdAfter
                }</span>
        }

        <span class="cov0" title="0">if createdBeforeStr := r.URL.Query().Get("created_before"); createdBeforeStr != "" </span><span class="cov0" title="0">{
                if createdBefore, err := time.Parse(time.RFC3339, createdBeforeStr); err != nil </span><span class="cov0" title="0">{
                        if createdBefore, err := time.Parse("2006-01-02", createdBeforeStr); err != nil </span><span class="cov0" title="0">{
                                rp.AddError("created_before", "must be a valid date (YYYY-MM-DD or RFC3339)", createdBeforeStr)
                        }</span> else<span class="cov0" title="0"> {
                                filters.CreatedBefore = &amp;createdBefore
                        }</span>
                } else<span class="cov0" title="0"> {
                        filters.CreatedBefore = &amp;createdBefore
                }</span>
        }

        <span class="cov0" title="0">return filters</span>
}

// AddError adds a validation error
func (rp *RequestParser) AddError(field, message, value string) <span class="cov0" title="0">{
        rp.errors = append(rp.errors, ValidationError{
                Field:   field,
                Message: message,
                Value:   value,
        })
}</span>

// HasErrors returns true if there are validation errors
func (rp *RequestParser) HasErrors() bool <span class="cov0" title="0">{
        return len(rp.errors) &gt; 0
}</span>

// GetErrors returns all validation errors
func (rp *RequestParser) GetErrors() ValidationErrors <span class="cov0" title="0">{
        return rp.errors
}</span>

// ValidateUserSortField validates sort fields for users
func ValidateUserSortField(sort string) bool <span class="cov0" title="0">{
        allowedFields := []string{
                "id", "name", "discord_id", "mmr", "trueskill_mu", "trueskill_sigma",
                "created_at", "updated_at", "trueskill_last_updated",
        }

        for _, field := range allowedFields </span><span class="cov0" title="0">{
                if sort == field </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// ValidateTrackerSortField validates sort fields for trackers
func ValidateTrackerSortField(sort string) bool <span class="cov0" title="0">{
        allowedFields := []string{
                "id", "discord_id", "calculated_mmr", "valid", "created_at", "updated_at", "last_updated",
                "ones_current_season_peak", "twos_current_season_peak", "threes_current_season_peak",
        }

        for _, field := range allowedFields </span><span class="cov0" title="0">{
                if sort == field </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// Helper functions for validation simplification

// isValidUserStatus checks if the given status is valid for users
func isValidUserStatus(status string) bool <span class="cov0" title="0">{
        validStatuses := []string{"active", "inactive", "banned"}
        for _, validStatus := range validStatuses </span><span class="cov0" title="0">{
                if status == validStatus </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// isValidPlaylist checks if the given playlist is valid
func isValidPlaylist(playlist string) bool <span class="cov0" title="0">{
        validPlaylists := []string{"ones", "twos", "threes"}
        for _, validPlaylist := range validPlaylists </span><span class="cov0" title="0">{
                if playlist == validPlaylist </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// isInvalidRange checks if min value is greater than max value
func isInvalidRange(min, max *int) bool <span class="cov0" title="0">{
        return min != nil &amp;&amp; max != nil &amp;&amp; *min &gt; *max
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package repositories

import (
        "encoding/json"
        "fmt"
        "strconv"
        "time"
        "usl-server/internal/config"
        "usl-server/internal/models"

        "github.com/supabase-community/supabase-go"
)

const (
        // Database table names
        GuildsTable = "guilds"

        // Default values for guild creation
        DefaultGuildActiveStatus = true

        // Error messages
        ErrGuildAlreadyExists     = "guild with Discord ID %s already exists"
        ErrConfigValidationFailed = "config validation failed: %w"
        ErrGuildCreationFailed    = "failed to create guild: %w"
        ErrGuildParsingFailed     = "failed to parse created guild: %w"
        ErrNoGuildReturned        = "no guild returned after creation"
        ErrGuildConversionFailed  = "failed to convert guild: %w"
)

// GuildRepository handles all guild data access operations using Supabase Go client
type GuildRepository struct {
        client *supabase.Client
        config *config.Config
}

func NewGuildRepository(client *supabase.Client, cfg *config.Config) *GuildRepository <span class="cov0" title="0">{
        return &amp;GuildRepository{
                client: client,
                config: cfg,
        }
}</span>

// CreateGuild creates a new guild with default configuration
func (r *GuildRepository) CreateGuild(guildData models.GuildCreateRequest) (*models.Guild, error) <span class="cov0" title="0">{
        // Check if guild already exists
        existingGuild, err := r.FindGuildByDiscordID(guildData.DiscordGuildID)
        if err == nil &amp;&amp; existingGuild != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(ErrGuildAlreadyExists, guildData.DiscordGuildID)
        }</span>

        // Validate configuration
        <span class="cov0" title="0">if err := guildData.Config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config validation failed: %w", err)
        }</span>

        // Use a map to avoid ID conflicts - let Supabase generate the ID
        <span class="cov0" title="0">insertData := map[string]interface{}{
                "discord_guild_id": guildData.DiscordGuildID,
                "name":             guildData.Name,
                "slug":             guildData.Slug,
                "active":           DefaultGuildActiveStatus,
                "config":           guildData.Config,
        }

        data, _, err := r.client.From(GuildsTable).Insert(insertData, false, "", "", "").Execute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create guild: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicGuildsSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse created guild: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no guild returned after creation")
        }</span>

        <span class="cov0" title="0">createdGuild, err := r.convertToGuild(result[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert created guild: %w", err)
        }</span>

        <span class="cov0" title="0">return createdGuild, nil</span>
}

// FindGuildByDiscordID finds a guild by Discord guild ID
func (r *GuildRepository) FindGuildByDiscordID(discordGuildID string) (*models.Guild, error) <span class="cov0" title="0">{
        data, _, err := r.client.From("guilds").
                Select("*", "", false).
                Eq("discord_guild_id", discordGuildID).
                Single().
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result models.PublicGuildsSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse guild data: %w", err)
        }</span>

        <span class="cov0" title="0">guild, err := r.convertToGuild(result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert guild: %w", err)
        }</span>

        <span class="cov0" title="0">return guild, nil</span>
}

// FindGuildByID finds a guild by internal ID
func (r *GuildRepository) FindGuildByID(guildID int64) (*models.Guild, error) <span class="cov0" title="0">{
        data, _, err := r.client.From("guilds").
                Select("*", "", false).
                Eq("id", strconv.FormatInt(guildID, 10)).
                Single().
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result models.PublicGuildsSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse guild data: %w", err)
        }</span>

        <span class="cov0" title="0">guild, err := r.convertToGuild(result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert guild: %w", err)
        }</span>

        <span class="cov0" title="0">return guild, nil</span>
}

// FindGuildBySlug finds a guild by URL slug
func (r *GuildRepository) FindGuildBySlug(slug string) (*models.Guild, error) <span class="cov0" title="0">{
        data, _, err := r.client.From("guilds").
                Select("*", "", false).
                Eq("slug", slug).
                Single().
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result models.PublicGuildsSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse guild data: %w", err)
        }</span>

        <span class="cov0" title="0">guild, err := r.convertToGuild(result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert guild: %w", err)
        }</span>

        <span class="cov0" title="0">return guild, nil</span>
}

// UpdateGuild updates an existing guild
func (r *GuildRepository) UpdateGuild(guildID int64, guildData models.GuildUpdateRequest) (*models.Guild, error) <span class="cov0" title="0">{
        // Verify guild exists
        _, err := r.FindGuildByID(guildID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("guild with ID %d not found", guildID)
        }</span>

        // Validate configuration
        <span class="cov0" title="0">if err := guildData.Config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">updateData := map[string]interface{}{
                "name":   guildData.Name,
                "slug":   guildData.Slug,
                "active": guildData.Active,
                "config": guildData.Config,
        }

        data, _, err := r.client.From("guilds").
                Update(updateData, "", "").
                Eq("id", strconv.FormatInt(guildID, 10)).
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update guild: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicGuildsSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse updated guild: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no guild returned after update")
        }</span>

        <span class="cov0" title="0">updatedGuild, err := r.convertToGuild(result[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert updated guild: %w", err)
        }</span>

        <span class="cov0" title="0">return updatedGuild, nil</span>
}

// UpdateConfig updates only the configuration for a guild
func (r *GuildRepository) UpdateConfig(guildID int64, config *models.GuildConfig) error <span class="cov0" title="0">{
        // Validate configuration
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">updateData := map[string]interface{}{
                "config": config,
        }

        _, _, err := r.client.From("guilds").
                Update(updateData, "", "").
                Eq("id", strconv.FormatInt(guildID, 10)).
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update guild config: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConfig retrieves only the configuration for a guild
func (r *GuildRepository) GetConfig(guildID int64) (*models.GuildConfig, error) <span class="cov0" title="0">{
        data, _, err := r.client.From("guilds").
                Select("config", "", false).
                Eq("id", strconv.FormatInt(guildID, 10)).
                Single().
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result struct {
                Config json.RawMessage `json:"config"`
        }
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config data: %w", err)
        }</span>

        <span class="cov0" title="0">var config models.GuildConfig
        if err := json.Unmarshal(result.Config, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// GetAllGuilds retrieves all guilds with optional active filter
func (r *GuildRepository) GetAllGuilds(activeOnly bool) ([]*models.Guild, error) <span class="cov0" title="0">{
        query := r.client.From("guilds").Select("*", "", false).Order("name", nil)

        if activeOnly </span><span class="cov0" title="0">{
                query = query.Eq("active", "true")
        }</span>

        <span class="cov0" title="0">data, _, err := query.Execute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all guilds: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicGuildsSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse guilds: %w", err)
        }</span>

        <span class="cov0" title="0">guilds := make([]*models.Guild, 0, len(result))
        for _, guildSelect := range result </span><span class="cov0" title="0">{
                guild, err := r.convertToGuild(guildSelect)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to convert guild %s: %v\n", guildSelect.DiscordGuildId, err)
                        continue</span>
                }
                <span class="cov0" title="0">guilds = append(guilds, guild)</span>
        }

        <span class="cov0" title="0">return guilds, nil</span>
}

// DeactivateGuild marks a guild as inactive
func (r *GuildRepository) DeactivateGuild(guildID int64) (*models.Guild, error) <span class="cov0" title="0">{
        _, err := r.FindGuildByID(guildID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("guild with ID %d not found", guildID)
        }</span>

        <span class="cov0" title="0">updateData := map[string]interface{}{
                "active": false,
        }

        data, _, err := r.client.From("guilds").
                Update(updateData, "", "").
                Eq("id", strconv.FormatInt(guildID, 10)).
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to deactivate guild: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicGuildsSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse deactivated guild: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no guild returned after deactivation")
        }</span>

        <span class="cov0" title="0">deactivatedGuild, err := r.convertToGuild(result[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert deactivated guild: %w", err)
        }</span>

        <span class="cov0" title="0">return deactivatedGuild, nil</span>
}

// MigrateConfigToRelational is a placeholder for future migration to relational permissions
func (r *GuildRepository) MigrateConfigToRelational() error <span class="cov0" title="0">{
        // This function exists but is unused until needed
        // Extracts JSONB config to proper relational tables
        // You'll thank yourself in 12 months

        // Steps for future implementation:
        // 1. Use proper SQL client for transactions
        // 2. Extract all guild configs
        // 3. INSERT INTO guild_role_permissions SELECT ...
        // 4. UPDATE guilds SET config_migrated = true

        return fmt.Errorf("migration not implemented yet")
}</span>

// Helper function to convert Supabase generated type to internal model
func (r *GuildRepository) convertToGuild(guildSelect models.PublicGuildsSelect) (*models.Guild, error) <span class="cov0" title="0">{
        // Parse timestamps
        createdAt, _ := time.Parse(time.RFC3339, guildSelect.CreatedAt)
        updatedAt, _ := time.Parse(time.RFC3339, guildSelect.UpdatedAt)

        // Parse configuration
        var config models.GuildConfig
        configBytes, err := json.Marshal(guildSelect.Config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal config interface: %w", err)
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(configBytes, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;models.Guild{
                ID:             guildSelect.Id,
                DiscordGuildID: guildSelect.DiscordGuildId,
                Name:           guildSelect.Name,
                Slug:           guildSelect.Slug,
                Active:         guildSelect.Active,
                Config:         config,
                CreatedAt:      createdAt,
                UpdatedAt:      updatedAt,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package repositories

import (
        "encoding/json"
        "fmt"
        "strconv"
        "time"
        "usl-server/internal/config"
        "usl-server/internal/models"

        "github.com/supabase-community/postgrest-go"
        "github.com/supabase-community/supabase-go"
)

// TrackerRepository handles all tracker data access operations using Supabase Go client
// Exactly matches the patterns from JavaScript TrackerRepository
type TrackerRepository struct {
        client *supabase.Client
        config *config.Config
}

// NewTrackerRepository creates a new tracker repository instance
func NewTrackerRepository(client *supabase.Client, cfg *config.Config) *TrackerRepository <span class="cov0" title="0">{
        return &amp;TrackerRepository{
                client: client,
                config: cfg,
        }
}</span>

// CreateTracker creates a new tracker, matching JavaScript createTracker()
func (r *TrackerRepository) CreateTracker(trackerData models.TrackerCreateRequest) (*models.UserTracker, error) <span class="cov0" title="0">{
        // Check for existing tracker by Discord ID
        existingTrackers, err := r.GetTrackersByDiscordID(trackerData.DiscordID, false)
        if err == nil &amp;&amp; len(existingTrackers) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tracker with Discord ID %s already exists", trackerData.DiscordID)
        }</span>

        // Prepare insert data using generated types
        <span class="cov0" title="0">insertData := models.PublicUserTrackersInsert{
                DiscordId:                 trackerData.DiscordID,
                Url:                       trackerData.URL,
                OnesCurrentSeasonPeak:     r.intToInt32Ptr(trackerData.OnesCurrentSeasonPeak),
                OnesPreviousSeasonPeak:    r.intToInt32Ptr(trackerData.OnesPreviousSeasonPeak),
                OnesAllTimePeak:           r.intToInt32Ptr(trackerData.OnesAllTimePeak),
                OnesCurrentSeasonGames:    r.intToInt32Ptr(trackerData.OnesCurrentSeasonGames),
                OnesPreviousSeasonGames:   r.intToInt32Ptr(trackerData.OnesPreviousSeasonGames),
                TwosCurrentSeasonPeak:     r.intToInt32Ptr(trackerData.TwosCurrentSeasonPeak),
                TwosPreviousSeasonPeak:    r.intToInt32Ptr(trackerData.TwosPreviousSeasonPeak),
                TwosAllTimePeak:           r.intToInt32Ptr(trackerData.TwosAllTimePeak),
                TwosCurrentSeasonGames:    r.intToInt32Ptr(trackerData.TwosCurrentSeasonGames),
                TwosPreviousSeasonGames:   r.intToInt32Ptr(trackerData.TwosPreviousSeasonGames),
                ThreesCurrentSeasonPeak:   r.intToInt32Ptr(trackerData.ThreesCurrentSeasonPeak),
                ThreesPreviousSeasonPeak:  r.intToInt32Ptr(trackerData.ThreesPreviousSeasonPeak),
                ThreesAllTimePeak:         r.intToInt32Ptr(trackerData.ThreesAllTimePeak),
                ThreesCurrentSeasonGames:  r.intToInt32Ptr(trackerData.ThreesCurrentSeasonGames),
                ThreesPreviousSeasonGames: r.intToInt32Ptr(trackerData.ThreesPreviousSeasonGames),
                Valid:                     &amp;trackerData.Valid,
                LastUpdated:               r.currentTimeStringPtr(),
        }

        // Insert using Supabase client
        data, _, err := r.client.From("user_trackers").Insert(insertData, false, "", "", "").Execute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create tracker: %w", err)
        }</span>

        // Parse the returned data
        <span class="cov0" title="0">var result []models.PublicUserTrackersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse created tracker: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no tracker returned after creation")
        }</span>

        // Convert to internal UserTracker model
        <span class="cov0" title="0">createdTracker := r.convertToUserTracker(result[0])
        return &amp;createdTracker, nil</span>
}

// GetTrackersByDiscordID finds trackers by Discord ID using Supabase client
func (r *TrackerRepository) GetTrackersByDiscordID(discordID string, validOnly bool) ([]*models.UserTracker, error) <span class="cov0" title="0">{
        query := r.client.From("user_trackers").
                Select("*", "", false).
                Eq("discord_id", discordID).
                Order("created_at", nil)

        if validOnly </span><span class="cov0" title="0">{
                query = query.Eq("valid", "true")
        }</span>

        <span class="cov0" title="0">data, _, err := query.Execute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trackers: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicUserTrackersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse tracker data: %w", err)
        }</span>

        <span class="cov0" title="0">trackers := make([]*models.UserTracker, len(result))
        for i, trackerSelect := range result </span><span class="cov0" title="0">{
                tracker := r.convertToUserTracker(trackerSelect)
                trackers[i] = &amp;tracker
        }</span>

        <span class="cov0" title="0">return trackers, nil</span>
}

// UpdateTracker updates an existing tracker using Supabase client
func (r *TrackerRepository) UpdateTracker(trackerID int, trackerData models.TrackerUpdateRequest) (*models.UserTracker, error) <span class="cov0" title="0">{
        // Prepare update data
        updateData := models.PublicUserTrackersUpdate{
                Url:                       &amp;trackerData.URL,
                OnesCurrentSeasonPeak:     r.intToInt32Ptr(trackerData.OnesCurrentSeasonPeak),
                OnesPreviousSeasonPeak:    r.intToInt32Ptr(trackerData.OnesPreviousSeasonPeak),
                OnesAllTimePeak:           r.intToInt32Ptr(trackerData.OnesAllTimePeak),
                OnesCurrentSeasonGames:    r.intToInt32Ptr(trackerData.OnesCurrentSeasonGames),
                OnesPreviousSeasonGames:   r.intToInt32Ptr(trackerData.OnesPreviousSeasonGames),
                TwosCurrentSeasonPeak:     r.intToInt32Ptr(trackerData.TwosCurrentSeasonPeak),
                TwosPreviousSeasonPeak:    r.intToInt32Ptr(trackerData.TwosPreviousSeasonPeak),
                TwosAllTimePeak:           r.intToInt32Ptr(trackerData.TwosAllTimePeak),
                TwosCurrentSeasonGames:    r.intToInt32Ptr(trackerData.TwosCurrentSeasonGames),
                TwosPreviousSeasonGames:   r.intToInt32Ptr(trackerData.TwosPreviousSeasonGames),
                ThreesCurrentSeasonPeak:   r.intToInt32Ptr(trackerData.ThreesCurrentSeasonPeak),
                ThreesPreviousSeasonPeak:  r.intToInt32Ptr(trackerData.ThreesPreviousSeasonPeak),
                ThreesAllTimePeak:         r.intToInt32Ptr(trackerData.ThreesAllTimePeak),
                ThreesCurrentSeasonGames:  r.intToInt32Ptr(trackerData.ThreesCurrentSeasonGames),
                ThreesPreviousSeasonGames: r.intToInt32Ptr(trackerData.ThreesPreviousSeasonGames),
                Valid:                     &amp;trackerData.Valid,
                LastUpdated:               r.currentTimeStringPtr(),
        }

        // Update using Supabase client
        data, _, err := r.client.From("user_trackers").
                Update(updateData, "", "").
                Eq("id", strconv.Itoa(trackerID)).
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update tracker: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicUserTrackersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse updated tracker: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no tracker returned after update")
        }</span>

        <span class="cov0" title="0">updatedTracker := r.convertToUserTracker(result[0])
        return &amp;updatedTracker, nil</span>
}

// DeleteTracker marks tracker as invalid using Supabase client
func (r *TrackerRepository) DeleteTracker(trackerID int) (*models.UserTracker, error) <span class="cov0" title="0">{
        // Mark as invalid
        invalid := false
        updateData := models.PublicUserTrackersUpdate{
                Valid: &amp;invalid,
        }

        data, _, err := r.client.From("user_trackers").
                Update(updateData, "", "").
                Eq("id", strconv.Itoa(trackerID)).
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete tracker: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicUserTrackersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse deleted tracker: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no tracker returned after deletion")
        }</span>

        <span class="cov0" title="0">deletedTracker := r.convertToUserTracker(result[0])
        return &amp;deletedTracker, nil</span>
}

// GetAllTrackers gets all trackers with optional filters using Supabase client
func (r *TrackerRepository) GetAllTrackers(validOnly bool) ([]*models.UserTracker, error) <span class="cov0" title="0">{
        query := r.client.From("user_trackers").Select("*", "", false).Order("created_at", nil)

        if validOnly </span><span class="cov0" title="0">{
                query = query.Eq("valid", "true")
        }</span>

        <span class="cov0" title="0">data, _, err := query.Execute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all trackers: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicUserTrackersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse trackers: %w", err)
        }</span>

        <span class="cov0" title="0">trackers := make([]*models.UserTracker, len(result))
        for i, trackerSelect := range result </span><span class="cov0" title="0">{
                tracker := r.convertToUserTracker(trackerSelect)
                trackers[i] = &amp;tracker
        }</span>

        <span class="cov0" title="0">return trackers, nil</span>
}

// SearchTrackers searches by Discord ID or URL using Supabase client
func (r *TrackerRepository) SearchTrackers(searchTerm string, maxResults int) ([]*models.UserTracker, error) <span class="cov0" title="0">{
        if searchTerm == "" </span><span class="cov0" title="0">{
                return []*models.UserTracker{}, nil
        }</span>

        <span class="cov0" title="0">if maxResults &lt;= 0 </span><span class="cov0" title="0">{
                maxResults = 50
        }</span>

        // Supabase supports ilike for case-insensitive partial matching
        <span class="cov0" title="0">searchPattern := "%" + searchTerm + "%"

        data, _, err := r.client.From("user_trackers").
                Select("*", "", false).
                Or(fmt.Sprintf("discord_id.ilike.%s,url.ilike.%s", searchPattern, searchPattern), "").
                Order("created_at", nil).
                Limit(maxResults, "").
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search trackers: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicUserTrackersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse search results: %w", err)
        }</span>

        <span class="cov0" title="0">trackers := make([]*models.UserTracker, len(result))
        for i, trackerSelect := range result </span><span class="cov0" title="0">{
                tracker := r.convertToUserTracker(trackerSelect)
                trackers[i] = &amp;tracker
        }</span>

        <span class="cov0" title="0">return trackers, nil</span>
}

// GetTrackerStats calculates tracker statistics using Supabase client
func (r *TrackerRepository) GetTrackerStats() (*models.TrackerStats, error) <span class="cov0" title="0">{
        data, _, err := r.client.From("user_trackers").Select("valid,calculated_mmr", "", false).Execute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tracker data for stats: %w", err)
        }</span>

        <span class="cov0" title="0">var allTrackers []models.PublicUserTrackersSelect
        err = json.Unmarshal(data, &amp;allTrackers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse tracker stats data: %w", err)
        }</span>

        <span class="cov0" title="0">stats := &amp;models.TrackerStats{}
        var totalMMR float64
        var totalGames int

        for _, tracker := range allTrackers </span><span class="cov0" title="0">{
                stats.TotalTrackers++
                if tracker.Valid </span><span class="cov0" title="0">{
                        stats.ValidTrackers++
                        totalMMR += float64(tracker.CalculatedMmr)
                        // Calculate total games for this tracker
                        games := int(tracker.OnesCurrentSeasonGames + tracker.OnesPreviousSeasonGames +
                                tracker.TwosCurrentSeasonGames + tracker.TwosPreviousSeasonGames +
                                tracker.ThreesCurrentSeasonGames + tracker.ThreesPreviousSeasonGames)
                        totalGames += games
                }</span>
        }

        <span class="cov0" title="0">if stats.ValidTrackers &gt; 0 </span><span class="cov0" title="0">{
                stats.AverageMMR = totalMMR / float64(stats.ValidTrackers)
                stats.AverageGamesPerTracker = float64(totalGames) / float64(stats.ValidTrackers)
        }</span>

        // Count unique users
        <span class="cov0" title="0">uniqueUsers := make(map[string]bool)
        for _, tracker := range allTrackers </span><span class="cov0" title="0">{
                uniqueUsers[tracker.DiscordId] = true
        }</span>
        <span class="cov0" title="0">stats.UniqueUsers = len(uniqueUsers)

        return stats, nil</span>
}

// GetTrackersPaginated gets trackers with pagination and filtering using Supabase client
func (r *TrackerRepository) GetTrackersPaginated(params *models.PaginationParams, filters *models.TrackerFilters) ([]*models.UserTracker, *models.PaginationMetadata, error) <span class="cov0" title="0">{
        // Build base query
        query := r.client.From("user_trackers").Select("*", "", false)

        // Apply filters
        if filters != nil </span><span class="cov0" title="0">{
                // Apply valid filter
                if filters.Valid != nil </span><span class="cov0" title="0">{
                        if *filters.Valid </span><span class="cov0" title="0">{
                                query = query.Eq("valid", "true")
                        }</span> else<span class="cov0" title="0"> {
                                query = query.Eq("valid", "false")
                        }</span>
                }

                // Apply playlist filter (based on peak values)
                <span class="cov0" title="0">if filters.Playlist != "" </span><span class="cov0" title="0">{
                        switch filters.Playlist </span>{
                        case "ones":<span class="cov0" title="0">
                                query = query.Gt("ones_current_season_peak", "0")</span>
                        case "twos":<span class="cov0" title="0">
                                query = query.Gt("twos_current_season_peak", "0")</span>
                        case "threes":<span class="cov0" title="0">
                                query = query.Gt("threes_current_season_peak", "0")</span>
                        }
                }

                // Apply Discord ID filter
                <span class="cov0" title="0">if filters.DiscordID != "" </span><span class="cov0" title="0">{
                        query = query.Eq("discord_id", filters.DiscordID)
                }</span>

                // Apply date filters
                <span class="cov0" title="0">if filters.CreatedAfter != nil </span><span class="cov0" title="0">{
                        query = query.Gte("created_at", filters.CreatedAfter.Format(time.RFC3339))
                }</span>
                <span class="cov0" title="0">if filters.CreatedBefore != nil </span><span class="cov0" title="0">{
                        query = query.Lt("created_at", filters.CreatedBefore.Format(time.RFC3339))
                }</span>
        }

        // Get total count for pagination metadata
        <span class="cov0" title="0">total, err := r.getTrackerCount(filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get tracker count: %w", err)
        }</span>

        // Apply sorting
        <span class="cov0" title="0">if params.Sort != "" </span><span class="cov0" title="0">{
                if params.Order == "asc" </span><span class="cov0" title="0">{
                        query = query.Order(params.Sort, &amp;postgrest.OrderOpts{Ascending: true})
                }</span> else<span class="cov0" title="0"> {
                        query = query.Order(params.Sort, &amp;postgrest.OrderOpts{Ascending: false})
                }</span>
        }

        // Apply pagination
        <span class="cov0" title="0">offset := params.CalculateOffset()
        query = query.Range(offset, offset+params.Limit-1, "")

        // Execute query
        data, _, err := query.Execute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get paginated trackers: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicUserTrackersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to parse paginated trackers: %w", err)
        }</span>

        // Convert to internal model
        <span class="cov0" title="0">trackers := make([]*models.UserTracker, len(result))
        for i, trackerSelect := range result </span><span class="cov0" title="0">{
                tracker := r.convertToUserTracker(trackerSelect)
                trackers[i] = &amp;tracker
        }</span>

        // Calculate pagination metadata
        <span class="cov0" title="0">pagination := models.CalculatePagination(params, total)

        return trackers, &amp;pagination, nil</span>
}

// getTrackerCount gets the total count of trackers with filters applied
func (r *TrackerRepository) getTrackerCount(filters *models.TrackerFilters) (int64, error) <span class="cov0" title="0">{
        query := r.client.From("user_trackers").Select("id", "count", false)

        // Apply the same filters as the main query
        if filters != nil </span><span class="cov0" title="0">{
                // Apply valid filter
                if filters.Valid != nil </span><span class="cov0" title="0">{
                        if *filters.Valid </span><span class="cov0" title="0">{
                                query = query.Eq("valid", "true")
                        }</span> else<span class="cov0" title="0"> {
                                query = query.Eq("valid", "false")
                        }</span>
                }

                // Apply playlist filter (based on peak values)
                <span class="cov0" title="0">if filters.Playlist != "" </span><span class="cov0" title="0">{
                        switch filters.Playlist </span>{
                        case "ones":<span class="cov0" title="0">
                                query = query.Gt("ones_current_season_peak", "0")</span>
                        case "twos":<span class="cov0" title="0">
                                query = query.Gt("twos_current_season_peak", "0")</span>
                        case "threes":<span class="cov0" title="0">
                                query = query.Gt("threes_current_season_peak", "0")</span>
                        }
                }

                // Apply Discord ID filter
                <span class="cov0" title="0">if filters.DiscordID != "" </span><span class="cov0" title="0">{
                        query = query.Eq("discord_id", filters.DiscordID)
                }</span>

                // Apply date filters
                <span class="cov0" title="0">if filters.CreatedAfter != nil </span><span class="cov0" title="0">{
                        query = query.Gte("created_at", filters.CreatedAfter.Format(time.RFC3339))
                }</span>
                <span class="cov0" title="0">if filters.CreatedBefore != nil </span><span class="cov0" title="0">{
                        query = query.Lt("created_at", filters.CreatedBefore.Format(time.RFC3339))
                }</span>
        }

        <span class="cov0" title="0">data, _, err := query.Execute()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get tracker count: %w", err)
        }</span>

        // Parse count result
        <span class="cov0" title="0">var countResult []map[string]interface{}
        err = json.Unmarshal(data, &amp;countResult)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse tracker count: %w", err)
        }</span>

        <span class="cov0" title="0">if len(countResult) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Extract count from Supabase response
        <span class="cov0" title="0">count, ok := countResult[0]["count"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return int64(len(countResult)), nil // Fallback to result length
        }</span>

        <span class="cov0" title="0">return int64(count), nil</span>
}

// BulkUpdateTrackers performs bulk updates on trackers
func (r *TrackerRepository) BulkUpdateTrackers(operation *models.BulkOperation) (*models.BulkOperationResponse, error) <span class="cov0" title="0">{
        startTime := time.Now()
        response := &amp;models.BulkOperationResponse{
                Results: make([]models.BulkOperationResult, 0),
                Errors:  make([]string, 0),
        }

        switch operation.Operation </span>{
        case "update":<span class="cov0" title="0">
                return r.bulkUpdateTrackersUpdate(operation, response, startTime)</span>
        case "delete":<span class="cov0" title="0">
                return r.bulkUpdateTrackersDelete(operation, response, startTime)</span>
        default:<span class="cov0" title="0">
                response.Errors = append(response.Errors, fmt.Sprintf("unsupported operation: %s", operation.Operation))
                response.ProcessingTime = time.Since(startTime).String()
                return response, nil</span>
        }
}

// bulkUpdateTrackersUpdate handles bulk tracker updates
func (r *TrackerRepository) bulkUpdateTrackersUpdate(operation *models.BulkOperation, response *models.BulkOperationResponse, startTime time.Time) (*models.BulkOperationResponse, error) <span class="cov0" title="0">{
        // If tracker IDs are specified, update those trackers
        if len(operation.UserIDs) &gt; 0 </span><span class="cov0" title="0">{ // Using UserIDs field to store tracker IDs
                response.TotalRequested = len(operation.UserIDs)

                for _, trackerIDStr := range operation.UserIDs </span><span class="cov0" title="0">{
                        if trackerID, err := strconv.Atoi(trackerIDStr); err != nil </span><span class="cov0" title="0">{
                                response.Failed++
                                response.Results = append(response.Results, models.BulkOperationResult{
                                        ID:     trackerIDStr,
                                        Status: "failed",
                                        Error:  "invalid tracker ID",
                                })
                        }</span> else<span class="cov0" title="0"> if err := r.updateSingleTracker(trackerID, operation.Updates); err != nil </span><span class="cov0" title="0">{
                                response.Failed++
                                response.Results = append(response.Results, models.BulkOperationResult{
                                        ID:     trackerIDStr,
                                        Status: "failed",
                                        Error:  err.Error(),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                response.Successful++
                                response.Results = append(response.Results, models.BulkOperationResult{
                                        ID:     trackerIDStr,
                                        Status: "success",
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Update trackers based on filters
                // TODO: Implement filter-based bulk updates
                response.Errors = append(response.Errors, "filter-based bulk updates not yet implemented")
        }</span>

        <span class="cov0" title="0">response.ProcessingTime = time.Since(startTime).String()
        return response, nil</span>
}

// bulkUpdateTrackersDelete handles bulk tracker deletion (marking invalid)
func (r *TrackerRepository) bulkUpdateTrackersDelete(operation *models.BulkOperation, response *models.BulkOperationResponse, startTime time.Time) (*models.BulkOperationResponse, error) <span class="cov0" title="0">{
        if len(operation.UserIDs) &gt; 0 </span><span class="cov0" title="0">{ // Using UserIDs field to store tracker IDs
                response.TotalRequested = len(operation.UserIDs)

                for _, trackerIDStr := range operation.UserIDs </span><span class="cov0" title="0">{
                        if trackerID, err := strconv.Atoi(trackerIDStr); err != nil </span><span class="cov0" title="0">{
                                response.Failed++
                                response.Results = append(response.Results, models.BulkOperationResult{
                                        ID:     trackerIDStr,
                                        Status: "failed",
                                        Error:  "invalid tracker ID",
                                })
                        }</span> else<span class="cov0" title="0"> if _, err := r.DeleteTracker(trackerID); err != nil </span><span class="cov0" title="0">{
                                response.Failed++
                                response.Results = append(response.Results, models.BulkOperationResult{
                                        ID:     trackerIDStr,
                                        Status: "failed",
                                        Error:  err.Error(),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                response.Successful++
                                response.Results = append(response.Results, models.BulkOperationResult{
                                        ID:     trackerIDStr,
                                        Status: "success",
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">response.ProcessingTime = time.Since(startTime).String()
        return response, nil</span>
}

// updateSingleTracker updates a single tracker with the provided updates
func (r *TrackerRepository) updateSingleTracker(trackerID int, updates map[string]interface{}) error <span class="cov0" title="0">{
        // Validate and sanitize updates
        allowedFields := map[string]bool{
                "url":                          true,
                "ones_current_season_peak":     true,
                "ones_previous_season_peak":    true,
                "ones_all_time_peak":           true,
                "ones_current_season_games":    true,
                "ones_previous_season_games":   true,
                "twos_current_season_peak":     true,
                "twos_previous_season_peak":    true,
                "twos_all_time_peak":           true,
                "twos_current_season_games":    true,
                "twos_previous_season_games":   true,
                "threes_current_season_peak":   true,
                "threes_previous_season_peak":  true,
                "threes_all_time_peak":         true,
                "threes_current_season_games":  true,
                "threes_previous_season_games": true,
                "valid":                        true,
        }

        sanitizedUpdates := make(map[string]interface{})
        for key, value := range updates </span><span class="cov0" title="0">{
                if allowedFields[key] </span><span class="cov0" title="0">{
                        sanitizedUpdates[key] = value
                }</span>
        }

        <span class="cov0" title="0">if len(sanitizedUpdates) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no valid fields to update")
        }</span>

        // Add updated_at and last_updated timestamps
        <span class="cov0" title="0">sanitizedUpdates["updated_at"] = time.Now().Format(time.RFC3339)
        sanitizedUpdates["last_updated"] = time.Now().Format(time.RFC3339)

        // Execute update
        _, _, err := r.client.From("user_trackers").
                Update(sanitizedUpdates, "", "").
                Eq("id", strconv.Itoa(trackerID)).
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update tracker %d: %w", trackerID, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper function to convert Supabase generated type to internal model
func (r *TrackerRepository) convertToUserTracker(trackerSelect models.PublicUserTrackersSelect) models.UserTracker <span class="cov0" title="0">{
        // Parse timestamps
        createdAt, _ := time.Parse(time.RFC3339, trackerSelect.CreatedAt)
        updatedAt, _ := time.Parse(time.RFC3339, trackerSelect.UpdatedAt)
        lastUpdated, _ := time.Parse(time.RFC3339, trackerSelect.LastUpdated)

        return models.UserTracker{
                ID:                        int(trackerSelect.Id),
                DiscordID:                 trackerSelect.DiscordId,
                URL:                       trackerSelect.Url,
                OnesCurrentSeasonPeak:     int(trackerSelect.OnesCurrentSeasonPeak),
                OnesPreviousSeasonPeak:    int(trackerSelect.OnesPreviousSeasonPeak),
                OnesAllTimePeak:           int(trackerSelect.OnesAllTimePeak),
                OnesCurrentSeasonGames:    int(trackerSelect.OnesCurrentSeasonGames),
                OnesPreviousSeasonGames:   int(trackerSelect.OnesPreviousSeasonGames),
                TwosCurrentSeasonPeak:     int(trackerSelect.TwosCurrentSeasonPeak),
                TwosPreviousSeasonPeak:    int(trackerSelect.TwosPreviousSeasonPeak),
                TwosAllTimePeak:           int(trackerSelect.TwosAllTimePeak),
                TwosCurrentSeasonGames:    int(trackerSelect.TwosCurrentSeasonGames),
                TwosPreviousSeasonGames:   int(trackerSelect.TwosPreviousSeasonGames),
                ThreesCurrentSeasonPeak:   int(trackerSelect.ThreesCurrentSeasonPeak),
                ThreesPreviousSeasonPeak:  int(trackerSelect.ThreesPreviousSeasonPeak),
                ThreesAllTimePeak:         int(trackerSelect.ThreesAllTimePeak),
                ThreesCurrentSeasonGames:  int(trackerSelect.ThreesCurrentSeasonGames),
                ThreesPreviousSeasonGames: int(trackerSelect.ThreesPreviousSeasonGames),
                CalculatedMMR:             int(trackerSelect.CalculatedMmr),
                Valid:                     trackerSelect.Valid,
                LastUpdated:               lastUpdated,
                CreatedAt:                 createdAt,
                UpdatedAt:                 updatedAt,
        }
}</span>

// Helper functions for improved code readability

// intToInt32Ptr converts an int to a pointer to int32
func (r *TrackerRepository) intToInt32Ptr(value int) *int32 <span class="cov0" title="0">{
        converted := int32(value)
        return &amp;converted
}</span>

// currentTimeStringPtr returns a pointer to the current time as RFC3339 string
func (r *TrackerRepository) currentTimeStringPtr() *string <span class="cov0" title="0">{
        now := time.Now().Format(time.RFC3339)
        return &amp;now
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package repositories

import (
        "encoding/json"
        "fmt"
        "time"
        "usl-server/internal/config"
        "usl-server/internal/models"

        "github.com/supabase-community/postgrest-go"
        "github.com/supabase-community/supabase-go"
)

// UserRepository handles all user data access operations using Supabase Go client
// Exactly matches the patterns from JavaScript UserRepository
type UserRepository struct {
        client *supabase.Client
        config *config.Config
}

func NewUserRepository(client *supabase.Client, cfg *config.Config) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{
                client: client,
                config: cfg,
        }
}</span>

func (r *UserRepository) CreateUser(userData models.UserCreateRequest) (*models.User, error) <span class="cov0" title="0">{
        existingUser, err := r.FindUserByDiscordID(userData.DiscordID)
        if err == nil &amp;&amp; existingUser != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user with Discord ID %s already exists", userData.DiscordID)
        }</span>

        <span class="cov0" title="0">insertData := models.PublicUsersInsert{
                Name:      userData.Name,
                DiscordId: userData.DiscordID,
                Active:    &amp;userData.Active,
                Banned:    &amp;userData.Banned,
        }

        data, _, err := r.client.From("users").Insert(insertData, false, "", "", "").Execute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicUsersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse created user: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no user returned after creation")
        }</span>

        <span class="cov0" title="0">createdUser := r.convertToUser(result[0])
        return &amp;createdUser, nil</span>
}

func (r *UserRepository) FindUserByDiscordID(discordID string) (*models.User, error) <span class="cov0" title="0">{
        data, _, err := r.client.From("users").
                Select("*", "", false).
                Eq("discord_id", discordID).
                Single().
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result []models.PublicUsersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse user data: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>

        <span class="cov0" title="0">user := r.convertToUser(result[0])
        return &amp;user, nil</span>
}

func (r *UserRepository) FindUserByID(userID int64) (*models.User, error) <span class="cov0" title="0">{
        data, _, err := r.client.From("users").
                Select("*", "", false).
                Eq("id", fmt.Sprintf("%d", userID)).
                Single().
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result []models.PublicUsersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse user data: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>

        <span class="cov0" title="0">user := r.convertToUser(result[0])
        return &amp;user, nil</span>
}

func (r *UserRepository) UpdateUser(discordID string, userData models.UserUpdateRequest) (*models.User, error) <span class="cov0" title="0">{
        _, err := r.FindUserByDiscordID(discordID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user with Discord ID %s not found", discordID)
        }</span>

        // Restricted update: only name, active, and banned status (matches Google Sheets pattern)
        // Discord ID is immutable in this context
        <span class="cov0" title="0">updateData := models.PublicUsersUpdate{
                Name:   &amp;userData.Name,
                Active: &amp;userData.Active,
                Banned: &amp;userData.Banned,
        }

        data, _, err := r.client.From("users").
                Update(updateData, "", "").
                Eq("discord_id", discordID).
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicUsersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse updated user: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no user returned after update")
        }</span>

        <span class="cov0" title="0">updatedUser := r.convertToUser(result[0])
        return &amp;updatedUser, nil</span>
}

// DeleteUser marks user as inactive using Supabase client
func (r *UserRepository) DeleteUser(discordID string) (*models.User, error) <span class="cov0" title="0">{
        _, err := r.FindUserByDiscordID(discordID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user with Discord ID %s not found", discordID)
        }</span>

        <span class="cov0" title="0">inactive := false
        updateData := models.PublicUsersUpdate{
                Active: &amp;inactive,
        }

        data, _, err := r.client.From("users").
                Update(updateData, "", "").
                Eq("discord_id", discordID).
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete user: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicUsersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse deleted user: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no user returned after deletion")
        }</span>

        <span class="cov0" title="0">deletedUser := r.convertToUser(result[0])
        return &amp;deletedUser, nil</span>
}

// GetAllUsers gets all users with optional active filter using Supabase client
func (r *UserRepository) GetAllUsers(activeOnly bool) ([]*models.User, error) <span class="cov0" title="0">{
        query := r.client.From("users").Select("*", "", false).Order("name", nil)

        if activeOnly </span><span class="cov0" title="0">{
                query = query.Eq("active", "true")
        }</span>

        <span class="cov0" title="0">data, _, err := query.Execute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all users: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicUsersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse users: %w", err)
        }</span>

        <span class="cov0" title="0">users := make([]*models.User, len(result))
        for i, userSelect := range result </span><span class="cov0" title="0">{
                user := r.convertToUser(userSelect)
                users[i] = &amp;user
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

// SearchUsers searches by name or Discord ID using Supabase client
func (r *UserRepository) SearchUsers(searchTerm string, maxResults int) ([]*models.User, error) <span class="cov0" title="0">{
        if searchTerm == "" </span><span class="cov0" title="0">{
                return []*models.User{}, nil
        }</span>

        <span class="cov0" title="0">if maxResults &lt;= 0 </span><span class="cov0" title="0">{
                maxResults = 50
        }</span>

        // Supabase supports ilike for case-insensitive partial matching
        <span class="cov0" title="0">searchPattern := "%" + searchTerm + "%"

        data, _, err := r.client.From("users").
                Select("*", "", false).
                Or(fmt.Sprintf("name.ilike.%s,discord_id.ilike.%s", searchPattern, searchPattern), "").
                Order("name", nil).
                Limit(maxResults, "").
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search users: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicUsersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse search results: %w", err)
        }</span>

        <span class="cov0" title="0">users := make([]*models.User, len(result))
        for i, userSelect := range result </span><span class="cov0" title="0">{
                user := r.convertToUser(userSelect)
                users[i] = &amp;user
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

// UpdateUserTrueSkill updates a single user's TrueSkill values using Supabase client
// TODO: Update this function to work with player_effective_mmr table in new schema
func (r *UserRepository) UpdateUserTrueSkill(discordID string, trueskillMu, trueskillSigma float64, lastUpdated *time.Time) error <span class="cov0" title="0">{
        // This function needs to be updated to work with the new schema
        // where MMR data is stored in player_effective_mmr table
        return fmt.Errorf("UpdateUserTrueSkill not yet implemented for new schema")
}</span>

// BatchUpdateTrueSkill updates TrueSkill values for multiple users
func (r *UserRepository) BatchUpdateTrueSkill(updates []models.User) (int, error) <span class="cov0" title="0">{
        successCount := 0

        for _, update := range updates </span><span class="cov0" title="0">{
                err := r.UpdateUserTrueSkill(update.DiscordID, update.TrueSkillMu, update.TrueSkillSigma, &amp;update.TrueSkillLastUpdated)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to update TrueSkill for user %s: %v\n", update.DiscordID, err)
                        continue</span>
                }
                <span class="cov0" title="0">successCount++</span>
        }

        <span class="cov0" title="0">return successCount, nil</span>
}

// GetUserStats calculates user statistics using Supabase client
func (r *UserRepository) GetUserStats() (*models.UserStats, error) <span class="cov0" title="0">{
        data, _, err := r.client.From("users").Select("active,banned,mmr,trueskill_mu", "", false).Execute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user data for stats: %w", err)
        }</span>

        <span class="cov0" title="0">var allUsers []models.PublicUsersSelect
        err = json.Unmarshal(data, &amp;allUsers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse user stats data: %w", err)
        }</span>

        <span class="cov0" title="0">stats := &amp;models.UserStats{}

        for _, user := range allUsers </span><span class="cov0" title="0">{
                stats.TotalUsers++
                if user.Active </span><span class="cov0" title="0">{
                        stats.ActiveUsers++
                        // TODO: Calculate average MMR and TrueSkill from player_effective_mmr table
                }</span>
                <span class="cov0" title="0">if user.Banned </span><span class="cov0" title="0">{
                        stats.BannedUsers++
                }</span>
        }

        // TODO: Query player_effective_mmr table to get MMR statistics
        <span class="cov0" title="0">stats.AverageMMR = 0
        stats.AverageTrueSkillMu = 0

        return stats, nil</span>
}

// Helper function to convert Supabase generated type to internal model
func (r *UserRepository) convertToUser(userSelect models.PublicUsersSelect) models.User <span class="cov0" title="0">{
        // Parse timestamps
        createdAt, _ := time.Parse(time.RFC3339, userSelect.CreatedAt)
        updatedAt, _ := time.Parse(time.RFC3339, userSelect.UpdatedAt)

        return models.User{
                ID:        int(userSelect.Id),
                Name:      userSelect.Name,
                DiscordID: userSelect.DiscordId,
                Active:    userSelect.Active,
                Banned:    userSelect.Banned,
                // MMR fields are now in player_effective_mmr table
                MMR:                  0,           // TODO: Query from player_effective_mmr
                TrueSkillMu:          0,           // TODO: Query from player_effective_mmr
                TrueSkillSigma:       0,           // TODO: Query from player_effective_mmr
                TrueSkillLastUpdated: time.Time{}, // TODO: Query from player_effective_mmr
                CreatedAt:            createdAt,
                UpdatedAt:            updatedAt,
        }
}</span>

// GetUsersPaginated gets users with pagination and filtering using Supabase client
func (r *UserRepository) GetUsersPaginated(params *models.PaginationParams, filters *models.UserFilters) ([]*models.User, *models.PaginationMetadata, error) <span class="cov0" title="0">{
        // Build base query
        query := r.client.From("users").Select("*", "", false)

        // Apply filters
        if filters != nil </span><span class="cov0" title="0">{
                // Apply search filter (name or discord_id)
                if filters.Search != "" </span><span class="cov0" title="0">{
                        searchPattern := "%" + filters.Search + "%"
                        query = query.Or(fmt.Sprintf("name.ilike.%s,discord_id.ilike.%s", searchPattern, searchPattern), "")
                }</span>

                // Apply status filter
                <span class="cov0" title="0">if filters.Status != "" </span><span class="cov0" title="0">{
                        switch filters.Status </span>{
                        case "active":<span class="cov0" title="0">
                                query = query.Eq("active", "true").Eq("banned", "false")</span>
                        case "inactive":<span class="cov0" title="0">
                                query = query.Eq("active", "false")</span>
                        case "banned":<span class="cov0" title="0">
                                query = query.Eq("banned", "true")</span>
                        }
                }

                // Apply date filters
                <span class="cov0" title="0">if filters.CreatedAfter != nil </span><span class="cov0" title="0">{
                        query = query.Gte("created_at", filters.CreatedAfter.Format(time.RFC3339))
                }</span>
                <span class="cov0" title="0">if filters.CreatedBefore != nil </span><span class="cov0" title="0">{
                        query = query.Lt("created_at", filters.CreatedBefore.Format(time.RFC3339))
                }</span>
        }

        // Get total count for pagination metadata
        <span class="cov0" title="0">total, err := r.getUserCount(filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get user count: %w", err)
        }</span>

        // Apply sorting
        <span class="cov0" title="0">if params.Sort != "" </span><span class="cov0" title="0">{
                if params.Order == "asc" </span><span class="cov0" title="0">{
                        query = query.Order(params.Sort, &amp;postgrest.OrderOpts{Ascending: true})
                }</span> else<span class="cov0" title="0"> {
                        query = query.Order(params.Sort, &amp;postgrest.OrderOpts{Ascending: false})
                }</span>
        }

        // Apply pagination
        <span class="cov0" title="0">offset := params.CalculateOffset()
        query = query.Range(offset, offset+params.Limit-1, "")

        // Execute query
        data, _, err := query.Execute()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get paginated users: %w", err)
        }</span>

        <span class="cov0" title="0">var result []models.PublicUsersSelect
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to parse paginated users: %w", err)
        }</span>

        // Convert to internal model
        <span class="cov0" title="0">users := make([]*models.User, len(result))
        for i, userSelect := range result </span><span class="cov0" title="0">{
                user := r.convertToUser(userSelect)
                users[i] = &amp;user
        }</span>

        // Calculate pagination metadata
        <span class="cov0" title="0">pagination := models.CalculatePagination(params, total)

        return users, &amp;pagination, nil</span>
}

// getUserCount gets the total count of users with filters applied
func (r *UserRepository) getUserCount(filters *models.UserFilters) (int64, error) <span class="cov0" title="0">{
        query := r.client.From("users").Select("id", "count", false)

        // Apply the same filters as the main query
        if filters != nil </span><span class="cov0" title="0">{
                // Apply search filter (name or discord_id)
                if filters.Search != "" </span><span class="cov0" title="0">{
                        searchPattern := "%" + filters.Search + "%"
                        query = query.Or(fmt.Sprintf("name.ilike.%s,discord_id.ilike.%s", searchPattern, searchPattern), "")
                }</span>

                // Apply status filter
                <span class="cov0" title="0">if filters.Status != "" </span><span class="cov0" title="0">{
                        switch filters.Status </span>{
                        case "active":<span class="cov0" title="0">
                                query = query.Eq("active", "true").Eq("banned", "false")</span>
                        case "inactive":<span class="cov0" title="0">
                                query = query.Eq("active", "false")</span>
                        case "banned":<span class="cov0" title="0">
                                query = query.Eq("banned", "true")</span>
                        }
                }

                // Apply date filters
                <span class="cov0" title="0">if filters.CreatedAfter != nil </span><span class="cov0" title="0">{
                        query = query.Gte("created_at", filters.CreatedAfter.Format(time.RFC3339))
                }</span>
                <span class="cov0" title="0">if filters.CreatedBefore != nil </span><span class="cov0" title="0">{
                        query = query.Lt("created_at", filters.CreatedBefore.Format(time.RFC3339))
                }</span>
        }

        <span class="cov0" title="0">data, _, err := query.Execute()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get user count: %w", err)
        }</span>

        // Parse count result
        <span class="cov0" title="0">var countResult []map[string]interface{}
        err = json.Unmarshal(data, &amp;countResult)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse user count: %w", err)
        }</span>

        <span class="cov0" title="0">if len(countResult) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Extract count from Supabase response
        <span class="cov0" title="0">count, ok := countResult[0]["count"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return int64(len(countResult)), nil // Fallback to result length
        }</span>

        <span class="cov0" title="0">return int64(count), nil</span>
}

// BulkUpdateUsers performs bulk updates on users
func (r *UserRepository) BulkUpdateUsers(operation *models.BulkOperation) (*models.BulkOperationResponse, error) <span class="cov0" title="0">{
        startTime := time.Now()
        response := &amp;models.BulkOperationResponse{
                Results: make([]models.BulkOperationResult, 0),
                Errors:  make([]string, 0),
        }

        switch operation.Operation </span>{
        case "update":<span class="cov0" title="0">
                return r.bulkUpdateUsersUpdate(operation, response, startTime)</span>
        case "delete":<span class="cov0" title="0">
                return r.bulkUpdateUsersDelete(operation, response, startTime)</span>
        default:<span class="cov0" title="0">
                response.Errors = append(response.Errors, fmt.Sprintf("unsupported operation: %s", operation.Operation))
                response.ProcessingTime = time.Since(startTime).String()
                return response, nil</span>
        }
}

// bulkUpdateUsersUpdate handles bulk user updates
func (r *UserRepository) bulkUpdateUsersUpdate(operation *models.BulkOperation, response *models.BulkOperationResponse, startTime time.Time) (*models.BulkOperationResponse, error) <span class="cov0" title="0">{
        // If user IDs are specified, update those users
        if len(operation.UserIDs) &gt; 0 </span><span class="cov0" title="0">{
                response.TotalRequested = len(operation.UserIDs)

                for _, userID := range operation.UserIDs </span><span class="cov0" title="0">{
                        if err := r.updateSingleUser(userID, operation.Updates); err != nil </span><span class="cov0" title="0">{
                                response.Failed++
                                response.Results = append(response.Results, models.BulkOperationResult{
                                        ID:     userID,
                                        Status: "failed",
                                        Error:  err.Error(),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                response.Successful++
                                response.Results = append(response.Results, models.BulkOperationResult{
                                        ID:     userID,
                                        Status: "success",
                                })
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Update users based on filters
                // TODO: Implement filter-based bulk updates
                response.Errors = append(response.Errors, "filter-based bulk updates not yet implemented")
        }</span>

        <span class="cov0" title="0">response.ProcessingTime = time.Since(startTime).String()
        return response, nil</span>
}

// bulkUpdateUsersDelete handles bulk user deletion (marking inactive)
func (r *UserRepository) bulkUpdateUsersDelete(operation *models.BulkOperation, response *models.BulkOperationResponse, startTime time.Time) (*models.BulkOperationResponse, error) <span class="cov0" title="0">{
        if len(operation.UserIDs) &gt; 0 </span><span class="cov0" title="0">{
                response.TotalRequested = len(operation.UserIDs)

                for _, userID := range operation.UserIDs </span><span class="cov0" title="0">{
                        if _, err := r.DeleteUser(userID); err != nil </span><span class="cov0" title="0">{
                                response.Failed++
                                response.Results = append(response.Results, models.BulkOperationResult{
                                        ID:     userID,
                                        Status: "failed",
                                        Error:  err.Error(),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                response.Successful++
                                response.Results = append(response.Results, models.BulkOperationResult{
                                        ID:     userID,
                                        Status: "success",
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">response.ProcessingTime = time.Since(startTime).String()
        return response, nil</span>
}

// updateSingleUser updates a single user with the provided updates
func (r *UserRepository) updateSingleUser(discordID string, updates map[string]interface{}) error <span class="cov0" title="0">{
        // Validate and sanitize updates
        allowedFields := map[string]bool{
                "name":   true,
                "active": true,
                "banned": true,
        }

        sanitizedUpdates := make(map[string]interface{})
        for key, value := range updates </span><span class="cov0" title="0">{
                if allowedFields[key] </span><span class="cov0" title="0">{
                        sanitizedUpdates[key] = value
                }</span>
        }

        <span class="cov0" title="0">if len(sanitizedUpdates) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no valid fields to update")
        }</span>

        // Add updated_at timestamp
        <span class="cov0" title="0">sanitizedUpdates["updated_at"] = time.Now().Format(time.RFC3339)

        // Execute update
        _, _, err := r.client.From("users").
                Update(sanitizedUpdates, "", "").
                Eq("discord_id", discordID).
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user %s: %w", discordID, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package services

import (
        "fmt"
        "strconv"
        "time"
        "usl-server/internal/models"
)

// DataTransformationService handles data transformations between different formats and structures.
// Centralizes data mapping logic to ensure consistency across the application.
//
// Service Responsibilities:
// - Transform raw sheet data to structured objects
// - Map between different data representations
// - Validate data structure integrity
// - Provide consistent data formatting
//
// Exact port of JavaScript DataTransformationService
type DataTransformationService struct{}

// TrackerData represents structured tracker data for calculations
type TrackerData struct {
        DiscordID           string    `json:"discordId"`
        URL                 string    `json:"url"`
        OnesCurrentPeak     int       `json:"onesCurrentPeak"`
        OnesPreviousPeak    int       `json:"onesPreviousPeak"`
        OnesAllTimePeak     int       `json:"onesAllTimePeak"`
        OnesCurrentGames    int       `json:"onesCurrentGames"`
        OnesPreviousGames   int       `json:"onesPreviousGames"`
        TwosCurrentPeak     int       `json:"twosCurrentPeak"`
        TwosPreviousPeak    int       `json:"twosPreviousPeak"`
        TwosAllTimePeak     int       `json:"twosAllTimePeak"`
        TwosCurrentGames    int       `json:"twosCurrentGames"`
        TwosPreviousGames   int       `json:"twosPreviousGames"`
        ThreesCurrentPeak   int       `json:"threesCurrentPeak"`
        ThreesPreviousPeak  int       `json:"threesPreviousPeak"`
        ThreesAllTimePeak   int       `json:"threesAllTimePeak"`
        ThreesCurrentGames  int       `json:"threesCurrentGames"`
        ThreesPreviousGames int       `json:"threesPreviousGames"`
        LastUpdated         time.Time `json:"lastUpdated"`
}

// NewDataTransformationService creates a new data transformation service
func NewDataTransformationService() *DataTransformationService <span class="cov8" title="1">{
        return &amp;DataTransformationService{}
}</span>

// TransformRowDataToTracker transforms raw row data to structured tracker data object
// Exact port of JavaScript transformRowDataToTracker() function
func (s *DataTransformationService) TransformRowDataToTracker(rowData []interface{}) (*TrackerData, error) <span class="cov0" title="0">{
        if len(rowData) &lt; 17 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient columns in row data, expected at least 17, got %d", len(rowData))
        }</span>

        // Helper function to safely parse interface{} to string
        <span class="cov0" title="0">safeString := func(val interface{}) string </span><span class="cov0" title="0">{
                if val == nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%v", val)</span>
        }

        // Parse last updated date
        <span class="cov0" title="0">var lastUpdated time.Time
        if rowData[17] != nil </span><span class="cov0" title="0">{
                if dateStr := safeString(rowData[17]); dateStr != "" </span><span class="cov0" title="0">{
                        if parsed, err := time.Parse(time.RFC3339, dateStr); err == nil </span><span class="cov0" title="0">{
                                lastUpdated = parsed
                        }</span> else<span class="cov0" title="0"> {
                                lastUpdated = time.Now()
                        }</span>
                } else<span class="cov0" title="0"> {
                        lastUpdated = time.Now()
                }</span>
        } else<span class="cov0" title="0"> {
                lastUpdated = time.Now()
        }</span>

        <span class="cov0" title="0">return &amp;TrackerData{
                DiscordID:           safeString(rowData[0]),
                URL:                 safeString(rowData[1]),
                OnesCurrentPeak:     s.safeParseNumber(rowData[2], 0),
                OnesPreviousPeak:    s.safeParseNumber(rowData[3], 0),
                OnesAllTimePeak:     s.safeParseNumber(rowData[4], 0),
                OnesCurrentGames:    s.safeParseNumber(rowData[5], 0),
                OnesPreviousGames:   s.safeParseNumber(rowData[6], 0),
                TwosCurrentPeak:     s.safeParseNumber(rowData[7], 0),
                TwosPreviousPeak:    s.safeParseNumber(rowData[8], 0),
                TwosAllTimePeak:     s.safeParseNumber(rowData[9], 0),
                TwosCurrentGames:    s.safeParseNumber(rowData[10], 0),
                TwosPreviousGames:   s.safeParseNumber(rowData[11], 0),
                ThreesCurrentPeak:   s.safeParseNumber(rowData[12], 0),
                ThreesPreviousPeak:  s.safeParseNumber(rowData[13], 0),
                ThreesAllTimePeak:   s.safeParseNumber(rowData[14], 0),
                ThreesCurrentGames:  s.safeParseNumber(rowData[15], 0),
                ThreesPreviousGames: s.safeParseNumber(rowData[16], 0),
                LastUpdated:         lastUpdated,
        }, nil</span>
}

// PrepareTrackerDataForCalculation prepares tracker object for calculations
// Exact port of JavaScript prepareTrackerDataForCalculation() function
func (s *DataTransformationService) PrepareTrackerDataForCalculation(trackerObject *models.Tracker) (*TrackerData, error) <span class="cov8" title="1">{
        if trackerObject == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tracker object is required")
        }</span>

        <span class="cov8" title="1">return &amp;TrackerData{
                DiscordID:           trackerObject.DiscordID,
                URL:                 trackerObject.URL,
                OnesCurrentPeak:     trackerObject.OnesCurrentSeasonPeak,
                OnesPreviousPeak:    trackerObject.OnesPreviousSeasonPeak,
                OnesAllTimePeak:     trackerObject.OnesAllTimePeak,
                OnesCurrentGames:    trackerObject.OnesCurrentSeasonGames,
                OnesPreviousGames:   trackerObject.OnesPreviousSeasonGames,
                TwosCurrentPeak:     trackerObject.TwosCurrentSeasonPeak,
                TwosPreviousPeak:    trackerObject.TwosPreviousSeasonPeak,
                TwosAllTimePeak:     trackerObject.TwosAllTimePeak,
                TwosCurrentGames:    trackerObject.TwosCurrentSeasonGames,
                TwosPreviousGames:   trackerObject.TwosPreviousSeasonGames,
                ThreesCurrentPeak:   trackerObject.ThreesCurrentSeasonPeak,
                ThreesPreviousPeak:  trackerObject.ThreesPreviousSeasonPeak,
                ThreesAllTimePeak:   trackerObject.ThreesAllTimePeak,
                ThreesCurrentGames:  trackerObject.ThreesCurrentSeasonGames,
                ThreesPreviousGames: trackerObject.ThreesPreviousSeasonGames,
                LastUpdated:         trackerObject.LastUpdated,
        }, nil</span>
}

// TransformRowDataToUser transforms raw row data to structured user object
// Exact port of JavaScript transformRowDataToUser() function
func (s *DataTransformationService) TransformRowDataToUser(rowData []interface{}) (*models.User, error) <span class="cov0" title="0">{
        if len(rowData) &lt; 6 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient columns in user row data, expected at least 6, got %d", len(rowData))
        }</span>

        // Helper function to safely parse interface{} to string
        <span class="cov0" title="0">safeString := func(val interface{}) string </span><span class="cov0" title="0">{
                if val == nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%v", val)</span>
        }

        // Helper function to safely parse interface{} to bool
        <span class="cov0" title="0">safeBool := func(val interface{}) bool </span><span class="cov0" title="0">{
                if val == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">switch v := val.(type) </span>{
                case bool:<span class="cov0" title="0">
                        return v</span>
                case string:<span class="cov0" title="0">
                        return v == "true" || v == "TRUE" || v == "1"</span>
                case float64:<span class="cov0" title="0">
                        return v != 0</span>
                case int:<span class="cov0" title="0">
                        return v != 0</span>
                default:<span class="cov0" title="0">
                        return false</span>
                }
        }

        // Helper function to safely parse interface{} to float64
        <span class="cov0" title="0">safeFloat := func(val interface{}, defaultVal float64) float64 </span><span class="cov0" title="0">{
                if val == nil </span><span class="cov0" title="0">{
                        return defaultVal
                }</span>
                <span class="cov0" title="0">switch v := val.(type) </span>{
                case float64:<span class="cov0" title="0">
                        return v</span>
                case int:<span class="cov0" title="0">
                        return float64(v)</span>
                case string:<span class="cov0" title="0">
                        if f, err := strconv.ParseFloat(v, 64); err == nil </span><span class="cov0" title="0">{
                                return f
                        }</span>
                }
                <span class="cov0" title="0">return defaultVal</span>
        }

        // Parse timestamps
        <span class="cov0" title="0">var createdAt, updatedAt, trueskillLastUpdated time.Time
        now := time.Now()

        if len(rowData) &gt; 8 &amp;&amp; rowData[8] != nil </span><span class="cov0" title="0">{
                if dateStr := safeString(rowData[8]); dateStr != "" </span><span class="cov0" title="0">{
                        if parsed, err := time.Parse(time.RFC3339, dateStr); err == nil </span><span class="cov0" title="0">{
                                trueskillLastUpdated = parsed
                        }</span> else<span class="cov0" title="0"> {
                                trueskillLastUpdated = now
                        }</span>
                } else<span class="cov0" title="0"> {
                        trueskillLastUpdated = now
                }</span>
        } else<span class="cov0" title="0"> {
                trueskillLastUpdated = now
        }</span>

        <span class="cov0" title="0">return &amp;models.User{
                Name:                 safeString(rowData[0]),
                DiscordID:            safeString(rowData[1]),
                Active:               safeBool(rowData[2]),
                Banned:               safeBool(rowData[3]),
                MMR:                  s.safeParseNumber(rowData[4], 0),
                TrueSkillMu:          safeFloat(rowData[5], 1000.0),
                TrueSkillSigma:       safeFloat(rowData[6], 8.333),
                TrueSkillLastUpdated: trueskillLastUpdated,
                CreatedAt:            createdAt,
                UpdatedAt:            updatedAt,
        }, nil</span>
}

// ValidateTrackerData validates tracker data structure integrity
// Exact port of JavaScript validateTrackerData() function
func (s *DataTransformationService) ValidateTrackerData(data *TrackerData) error <span class="cov8" title="1">{
        if data == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("tracker data is nil")
        }</span>

        <span class="cov8" title="1">if data.DiscordID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("discord ID is required")
        }</span>

        // Validate MMR values are non-negative
        <span class="cov8" title="1">mmrFields := []struct {
                value int
                name  string
        }{
                {data.OnesCurrentPeak, "onesCurrentPeak"},
                {data.OnesPreviousPeak, "onesPreviousPeak"},
                {data.OnesAllTimePeak, "onesAllTimePeak"},
                {data.TwosCurrentPeak, "twosCurrentPeak"},
                {data.TwosPreviousPeak, "twosPreviousPeak"},
                {data.TwosAllTimePeak, "twosAllTimePeak"},
                {data.ThreesCurrentPeak, "threesCurrentPeak"},
                {data.ThreesPreviousPeak, "threesPreviousPeak"},
                {data.ThreesAllTimePeak, "threesAllTimePeak"},
        }

        for _, field := range mmrFields </span><span class="cov8" title="1">{
                if field.value &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s cannot be negative: %d", field.name, field.value)
                }</span>
        }

        // Validate games values are non-negative
        <span class="cov8" title="1">gameFields := []struct {
                value int
                name  string
        }{
                {data.OnesCurrentGames, "onesCurrentGames"},
                {data.OnesPreviousGames, "onesPreviousGames"},
                {data.TwosCurrentGames, "twosCurrentGames"},
                {data.TwosPreviousGames, "twosPreviousGames"},
                {data.ThreesCurrentGames, "threesCurrentGames"},
                {data.ThreesPreviousGames, "threesPreviousGames"},
        }

        for _, field := range gameFields </span><span class="cov8" title="1">{
                if field.value &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s cannot be negative: %d", field.name, field.value)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetTrackerDataStats returns statistics about tracker data
// Exact port of JavaScript getTrackerDataStats() function
func (s *DataTransformationService) GetTrackerDataStats(data *TrackerData) map[string]interface{} <span class="cov8" title="1">{
        if data == nil </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "error": "tracker data is nil",
                }
        }</span>

        <span class="cov8" title="1">totalGames := data.OnesCurrentGames + data.OnesPreviousGames +
                data.TwosCurrentGames + data.TwosPreviousGames +
                data.ThreesCurrentGames + data.ThreesPreviousGames

        maxCurrentPeak := data.OnesCurrentPeak
        if data.TwosCurrentPeak &gt; maxCurrentPeak </span><span class="cov8" title="1">{
                maxCurrentPeak = data.TwosCurrentPeak
        }</span>
        <span class="cov8" title="1">if data.ThreesCurrentPeak &gt; maxCurrentPeak </span><span class="cov0" title="0">{
                maxCurrentPeak = data.ThreesCurrentPeak
        }</span>

        <span class="cov8" title="1">maxAllTimePeak := data.OnesAllTimePeak
        if data.TwosAllTimePeak &gt; maxAllTimePeak </span><span class="cov8" title="1">{
                maxAllTimePeak = data.TwosAllTimePeak
        }</span>
        <span class="cov8" title="1">if data.ThreesAllTimePeak &gt; maxAllTimePeak </span><span class="cov0" title="0">{
                maxAllTimePeak = data.ThreesAllTimePeak
        }</span>

        <span class="cov8" title="1">activePlaylistsCount := 0
        if data.OnesCurrentGames &gt; 0 || data.OnesPreviousGames &gt; 0 </span><span class="cov8" title="1">{
                activePlaylistsCount++
        }</span>
        <span class="cov8" title="1">if data.TwosCurrentGames &gt; 0 || data.TwosPreviousGames &gt; 0 </span><span class="cov8" title="1">{
                activePlaylistsCount++
        }</span>
        <span class="cov8" title="1">if data.ThreesCurrentGames &gt; 0 || data.ThreesPreviousGames &gt; 0 </span><span class="cov8" title="1">{
                activePlaylistsCount++
        }</span>

        <span class="cov8" title="1">return map[string]interface{}{
                "totalGames":           totalGames,
                "maxCurrentPeak":       maxCurrentPeak,
                "maxAllTimePeak":       maxAllTimePeak,
                "activePlaylistsCount": activePlaylistsCount,
                "hasData":              totalGames &gt; 0,
                "lastUpdated":          data.LastUpdated,
        }</span>
}

// safeParseNumber safely parses interface{} to int with fallback
// Exact port of JavaScript _safeParseNumber() function
func (s *DataTransformationService) safeParseNumber(val interface{}, defaultVal int) int <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>

        <span class="cov0" title="0">switch v := val.(type) </span>{
        case int:<span class="cov0" title="0">
                return v</span>
        case int32:<span class="cov0" title="0">
                return int(v)</span>
        case int64:<span class="cov0" title="0">
                return int(v)</span>
        case float32:<span class="cov0" title="0">
                return int(v)</span>
        case float64:<span class="cov0" title="0">
                return int(v)</span>
        case string:<span class="cov0" title="0">
                if i, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov0" title="0">if f, err := strconv.ParseFloat(v, 64); err == nil </span><span class="cov0" title="0">{
                        return int(f)
                }</span>
        }

        <span class="cov0" title="0">return defaultVal</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package services

import (
        "math"
        "usl-server/internal/config"
)

// Enhanced uncertainty calculation constants
const (
        // Experience-based factors
        MaxGamesForCertainty      = 1000.0
        MinGamesThreshold         = 10
        LowActivityGamesThreshold = 50

        // Uncertainty bounds
        MinUncertaintyFactor     = 0.3
        MaxUncertaintyFactor     = 1.0
        DefaultUncertaintyFactor = 0.5

        // Playlist diversity factors
        TotalPlaylistCount     = 3.0
        VariancePenaltyDivisor = 10000.0
        MaxDistributionPenalty = 0.2

        // Precision for rounding
        UncertaintyPrecision = 1000.0
)

// EnhancedUncertaintyCalculator provides advanced uncertainty (TrueSkill œÉ) calculations
// that go beyond simple game count. It incorporates playlist diversity, skill consistency,
// recency factors, and all-time peak analysis.
//
// Key Features:
// - Percentile-aware uncertainty calculation
// - All-time peak integration
// - Cross-playlist skill consistency analysis
// - Activity and trajectory analysis
//
// Exact port of JavaScript EnhancedUncertaintyCalculator
type EnhancedUncertaintyCalculator struct {
        config *config.Config
}

// NewEnhancedUncertaintyCalculator creates a new enhanced uncertainty calculator
func NewEnhancedUncertaintyCalculator(config *config.Config) *EnhancedUncertaintyCalculator <span class="cov8" title="1">{
        return &amp;EnhancedUncertaintyCalculator{
                config: config,
        }
}</span>

// TrackerBreakdown represents parsed tracker data structure
type TrackerBreakdown struct {
        Ones   TrackerPlaylistBreakdown `json:"ones"`
        Twos   TrackerPlaylistBreakdown `json:"twos"`
        Threes TrackerPlaylistBreakdown `json:"threes"`
}

// TrackerPlaylistBreakdown represents playlist data breakdown
type TrackerPlaylistBreakdown struct {
        Current  SeasonBreakdown `json:"current"`
        Previous SeasonBreakdown `json:"previous"`
}

// SeasonBreakdown represents season data breakdown
type SeasonBreakdown struct {
        MMR   int `json:"mmr"`
        Games int `json:"games"`
}

// CalculateEnhancedUncertainty calculates enhanced TrueSkill sigma value
// This enhanced calculation considers:
// - Experience factor (total games played)
// - Playlist diversity (activity across 1v1, 2v2, 3v3)
// - Skill consistency (variance in normalized skills across playlists)
// - Recency factor (current vs previous season activity)
// - Peak performance analysis (current vs all-time peaks)
// - Data quality and freshness
//
// Exact port of JavaScript calculateEnhancedUncertainty() function
func (c *EnhancedUncertaintyCalculator) CalculateEnhancedUncertainty(trackerData *TrackerData) (float64, error) <span class="cov8" title="1">{
        sigmaMax, sigmaMin := c.config.GetTrueSkillSigmaRange()

        breakdown := c.parseTrackerData(trackerData)
        totalGames := c.calculateTotalGames(breakdown)

        experienceFactor := c.calculateExperienceFactor(totalGames)
        diversityFactor := c.calculatePlaylistDiversityFactor(breakdown)
        consistencyFactor := c.calculatePercentileSkillConsistency(breakdown)
        recencyFactor := c.calculateRecencyFactor(breakdown)
        peakPerformanceFactor := c.calculatePeakPerformanceFactor(breakdown)
        dataQualityFactor := c.calculateDataQualityFactor(trackerData)

        combinedFactor := experienceFactor *
                diversityFactor *
                consistencyFactor *
                recencyFactor *
                peakPerformanceFactor *
                dataQualityFactor

        enhancedSigma := sigmaMax - (combinedFactor * (sigmaMax - sigmaMin))
        finalSigma := math.Max(sigmaMin, math.Min(sigmaMax, enhancedSigma))

        return math.Round(finalSigma*UncertaintyPrecision) / UncertaintyPrecision, nil
}</span>

// parseTrackerData parses tracker data into structured breakdown
func (c *EnhancedUncertaintyCalculator) parseTrackerData(trackerData *TrackerData) TrackerBreakdown <span class="cov8" title="1">{
        return TrackerBreakdown{
                Ones: TrackerPlaylistBreakdown{
                        Current:  SeasonBreakdown{MMR: trackerData.OnesCurrentPeak, Games: trackerData.OnesCurrentGames},
                        Previous: SeasonBreakdown{MMR: trackerData.OnesPreviousPeak, Games: trackerData.OnesPreviousGames},
                },
                Twos: TrackerPlaylistBreakdown{
                        Current:  SeasonBreakdown{MMR: trackerData.TwosCurrentPeak, Games: trackerData.TwosCurrentGames},
                        Previous: SeasonBreakdown{MMR: trackerData.TwosPreviousPeak, Games: trackerData.TwosPreviousGames},
                },
                Threes: TrackerPlaylistBreakdown{
                        Current:  SeasonBreakdown{MMR: trackerData.ThreesCurrentPeak, Games: trackerData.ThreesCurrentGames},
                        Previous: SeasonBreakdown{MMR: trackerData.ThreesPreviousPeak, Games: trackerData.ThreesPreviousGames},
                },
        }
}</span>

// calculateTotalGames calculates total games across all playlists and seasons
func (c *EnhancedUncertaintyCalculator) calculateTotalGames(breakdown TrackerBreakdown) int <span class="cov8" title="1">{
        return breakdown.Ones.Current.Games + breakdown.Ones.Previous.Games +
                breakdown.Twos.Current.Games + breakdown.Twos.Previous.Games +
                breakdown.Threes.Current.Games + breakdown.Threes.Previous.Games
}</span>

// calculateExperienceFactor calculates experience factor based on total games
func (c *EnhancedUncertaintyCalculator) calculateExperienceFactor(totalGames int) float64 <span class="cov8" title="1">{
        return math.Min(float64(totalGames)/MaxGamesForCertainty, MaxUncertaintyFactor)
}</span>

// calculatePlaylistDiversityFactor calculates diversity factor based on active playlists
func (c *EnhancedUncertaintyCalculator) calculatePlaylistDiversityFactor(breakdown TrackerBreakdown) float64 <span class="cov8" title="1">{
        activePlaylistCount := 0
        gameDistribution := []int{}

        playlists := []TrackerPlaylistBreakdown{breakdown.Ones, breakdown.Twos, breakdown.Threes}
        for _, playlist := range playlists </span><span class="cov8" title="1">{
                totalGames := playlist.Current.Games + playlist.Previous.Games
                if totalGames &gt;= MinGamesThreshold </span><span class="cov8" title="1">{
                        activePlaylistCount++
                        gameDistribution = append(gameDistribution, totalGames)
                }</span>
        }

        <span class="cov8" title="1">if activePlaylistCount == 0 </span><span class="cov8" title="1">{
                return MinUncertaintyFactor
        }</span>

        // Base diversity factor
        <span class="cov8" title="1">diversityBonus := float64(activePlaylistCount) / TotalPlaylistCount

        // Calculate game distribution variance penalty
        if len(gameDistribution) &gt; 1 </span><span class="cov8" title="1">{
                mean := 0.0
                for _, games := range gameDistribution </span><span class="cov8" title="1">{
                        mean += float64(games)
                }</span>
                <span class="cov8" title="1">mean /= float64(len(gameDistribution))

                variance := 0.0
                for _, games := range gameDistribution </span><span class="cov8" title="1">{
                        variance += math.Pow(float64(games)-mean, 2)
                }</span>
                <span class="cov8" title="1">variance /= float64(len(gameDistribution))

                // High variance in game distribution reduces certainty
                distributionPenalty := math.Min(variance/VariancePenaltyDivisor, MaxDistributionPenalty)
                diversityBonus *= (1.0 - distributionPenalty)</span>
        }

        <span class="cov8" title="1">return math.Max(MinUncertaintyFactor, math.Min(MaxUncertaintyFactor, diversityBonus))</span>
}

// calculatePercentileSkillConsistency calculates skill consistency across playlists
func (c *EnhancedUncertaintyCalculator) calculatePercentileSkillConsistency(breakdown TrackerBreakdown) float64 <span class="cov8" title="1">{
        // This is a simplified version - in practice, would need percentile calculations
        // For now, return a reasonable default based on game activity
        totalGames := c.calculateTotalGames(breakdown)
        if totalGames &lt; LowActivityGamesThreshold </span><span class="cov8" title="1">{
                return DefaultUncertaintyFactor
        }</span>
        <span class="cov8" title="1">return 0.8</span>
}

// calculateRecencyFactor calculates recency factor based on current vs previous season activity
func (c *EnhancedUncertaintyCalculator) calculateRecencyFactor(breakdown TrackerBreakdown) float64 <span class="cov8" title="1">{
        currentGames := breakdown.Ones.Current.Games + breakdown.Twos.Current.Games + breakdown.Threes.Current.Games
        previousGames := breakdown.Ones.Previous.Games + breakdown.Twos.Previous.Games + breakdown.Threes.Previous.Games
        totalGames := currentGames + previousGames

        if totalGames == 0 </span><span class="cov8" title="1">{
                return 0.3
        }</span>

        // Higher current season activity = higher certainty
        <span class="cov8" title="1">recencyRatio := float64(currentGames) / float64(totalGames)
        return math.Max(0.3, math.Min(1.0, 0.5+recencyRatio*0.5))</span>
}

// calculatePeakPerformanceFactor calculates peak performance factor
func (c *EnhancedUncertaintyCalculator) calculatePeakPerformanceFactor(breakdown TrackerBreakdown) float64 <span class="cov8" title="1">{
        // Simplified peak performance analysis
        // In practice, would compare current peaks to all-time peaks
        maxPeak := 0
        playlists := []TrackerPlaylistBreakdown{breakdown.Ones, breakdown.Twos, breakdown.Threes}

        for _, playlist := range playlists </span><span class="cov8" title="1">{
                if playlist.Current.MMR &gt; maxPeak </span><span class="cov8" title="1">{
                        maxPeak = playlist.Current.MMR
                }</span>
                <span class="cov8" title="1">if playlist.Previous.MMR &gt; maxPeak </span><span class="cov0" title="0">{
                        maxPeak = playlist.Previous.MMR
                }</span>
        }

        // Players with higher peaks have more certainty in their skill level
        <span class="cov8" title="1">if maxPeak &lt; 600 </span><span class="cov8" title="1">{
                return 0.5 // Lower certainty for lower skilled players
        }</span> else<span class="cov8" title="1"> if maxPeak &gt; 1200 </span><span class="cov8" title="1">{
                return 0.9 // Higher certainty for higher skilled players
        }</span>

        // Linear interpolation between 600-1200 MMR
        <span class="cov8" title="1">return 0.5 + (float64(maxPeak-600)/600.0)*0.4</span>
}

// calculateDataQualityFactor calculates data quality and freshness factor
func (c *EnhancedUncertaintyCalculator) calculateDataQualityFactor(trackerData *TrackerData) float64 <span class="cov8" title="1">{
        // Check for missing or invalid data
        totalFields := 12 // Total tracker data fields
        validFields := 0

        if trackerData.OnesCurrentPeak &gt; 0 </span><span class="cov8" title="1">{
                validFields++
        }</span>
        <span class="cov8" title="1">if trackerData.OnesCurrentGames &gt; 0 </span><span class="cov8" title="1">{
                validFields++
        }</span>
        <span class="cov8" title="1">if trackerData.OnesPreviousPeak &gt; 0 </span><span class="cov8" title="1">{
                validFields++
        }</span>
        <span class="cov8" title="1">if trackerData.OnesPreviousGames &gt; 0 </span><span class="cov8" title="1">{
                validFields++
        }</span>
        <span class="cov8" title="1">if trackerData.TwosCurrentPeak &gt; 0 </span><span class="cov8" title="1">{
                validFields++
        }</span>
        <span class="cov8" title="1">if trackerData.TwosCurrentGames &gt; 0 </span><span class="cov8" title="1">{
                validFields++
        }</span>
        <span class="cov8" title="1">if trackerData.TwosPreviousPeak &gt; 0 </span><span class="cov8" title="1">{
                validFields++
        }</span>
        <span class="cov8" title="1">if trackerData.TwosPreviousGames &gt; 0 </span><span class="cov8" title="1">{
                validFields++
        }</span>
        <span class="cov8" title="1">if trackerData.ThreesCurrentPeak &gt; 0 </span><span class="cov8" title="1">{
                validFields++
        }</span>
        <span class="cov8" title="1">if trackerData.ThreesCurrentGames &gt; 0 </span><span class="cov8" title="1">{
                validFields++
        }</span>
        <span class="cov8" title="1">if trackerData.ThreesPreviousPeak &gt; 0 </span><span class="cov8" title="1">{
                validFields++
        }</span>
        <span class="cov8" title="1">if trackerData.ThreesPreviousGames &gt; 0 </span><span class="cov8" title="1">{
                validFields++
        }</span>

        <span class="cov8" title="1">return math.Max(0.5, float64(validFields)/float64(totalFields))</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package services

import (
        "fmt"
        "math"
        "time"
        "usl-server/internal/config"
        "usl-server/internal/models"
)

// PlaylistData represents MMR and games for current and previous seasons
type PlaylistData struct {
        Current  PlaylistSeason `json:"current"`
        Previous PlaylistSeason `json:"previous"`
}

// PlaylistSeason represents MMR and games for a single season
type PlaylistSeason struct {
        MMR   int `json:"mmr"`
        Games int `json:"games"`
}

// PlayerMMRData represents structured player data for percentile calculations
// Exactly matches the JavaScript playerData structure
type PlayerMMRData struct {
        Ones   PlaylistData `json:"ones"`
        Twos   PlaylistData `json:"twos"`
        Threes PlaylistData `json:"threes"`
}

// Type aliases for TrueSkill service compatibility
type PlayerData = PlayerMMRData
type PlaylistSeasonData = PlaylistSeason
type PercentileSkillResult = SkillCalculationResult

// PlaylistBreakdown represents the calculation breakdown for each playlist
type PlaylistBreakdown struct {
        EffectiveMMR    float64  `json:"effectiveMMR"`
        NormalizedSkill *float64 `json:"normalizedSkill"` // Pointer to allow null
        Games           int      `json:"games"`
}

// SkillCalculationResult matches the JavaScript return structure exactly
type SkillCalculationResult struct {
        NormalizedSkill float64                      `json:"normalizedSkill"`
        TrueskillMu     float64                      `json:"trueskillMu"`
        TotalGames      int                          `json:"totalGames"`
        Breakdown       map[string]PlaylistBreakdown `json:"breakdown"`
        Weights         map[string]float64           `json:"weights"`
        AggregationInfo AggregationInfo              `json:"aggregationInfo"`
        Error           string                       `json:"error,omitempty"`
        Fallback        string                       `json:"fallback,omitempty"`
}

// AggregationInfo provides metadata about the calculation method
type AggregationInfo struct {
        Method    string `json:"method"`
        Converter string `json:"converter"`
        Timestamp string `json:"timestamp"`
}

// MMRCalculator handles all MMR calculation logic
// Exactly ports the JavaScript PercentileMMRCalculator
type MMRCalculator struct {
        config              *config.Config
        percentileConverter *PercentileConverter
}

// NewMMRCalculator creates a new MMR calculator with dependency injection
func NewMMRCalculator(cfg *config.Config, percentileConverter *PercentileConverter) *MMRCalculator <span class="cov8" title="1">{
        return &amp;MMRCalculator{
                config:              cfg,
                percentileConverter: percentileConverter,
        }
}</span>

// CalculatePercentileBasedSkill is the main calculation function
// Exact port of JavaScript calculatePercentileBasedSkill()
func (m *MMRCalculator) CalculatePercentileBasedSkill(playerData PlayerMMRData) SkillCalculationResult <span class="cov8" title="1">{

        // Validate input data
        if err := m.validatePlayerData(playerData); err != nil </span><span class="cov0" title="0">{
                return SkillCalculationResult{
                        NormalizedSkill: 50.0,   // Default to median
                        TrueskillMu:     1000.0, // Default Œº for 50th percentile (0-2000 range)
                        TotalGames:      0,
                        Error:           err.Error(),
                        Fallback:        "default_values",
                }
        }</span>

        // Parse and structure playlist data exactly like JavaScript
        <span class="cov8" title="1">playlists := map[string]PlaylistData{
                "ones":   playerData.Ones,
                "twos":   playerData.Twos,
                "threes": playerData.Threes,
        }

        playlistEffectiveMMRs := make(map[string]float64)
        playlistNormalizedSkills := make(map[string]*float64)

        minGames := 10 // config.RELIABILITY_THRESHOLDS.MIN_GAMES_INCLUSION

        // Calculate effective MMR for each playlist (games-weighted pooling)
        for playlistName, data := range playlists </span><span class="cov8" title="1">{
                totalGames := data.Current.Games + data.Previous.Games
                var effectiveMMR float64

                if totalGames &gt; 0 </span><span class="cov8" title="1">{
                        effectiveMMR = float64(data.Current.MMR*data.Current.Games+data.Previous.MMR*data.Previous.Games) / float64(totalGames)
                }</span> else<span class="cov8" title="1"> {
                        effectiveMMR = 0
                }</span>

                <span class="cov8" title="1">playlistEffectiveMMRs[playlistName] = effectiveMMR

                // Convert to normalized skill if meets minimum requirements
                if totalGames &gt;= minGames &amp;&amp; effectiveMMR &gt; 0 </span><span class="cov8" title="1">{
                        playlistMapping := map[string]string{
                                "ones":   "soloDuel",
                                "twos":   "doubles",
                                "threes": "standard",
                        }

                        normalizedSkill := m.percentileConverter.MMRToNormalizedSkill(effectiveMMR, playlistMapping[playlistName])
                        playlistNormalizedSkills[playlistName] = &amp;normalizedSkill
                }</span> else<span class="cov8" title="1"> {
                        playlistNormalizedSkills[playlistName] = nil
                }</span>
        }

        // Playlist weights from config (matches JavaScript weights)
        <span class="cov8" title="1">weights := map[string]float64{
                "ones":   m.config.MMR.OnesWeight,
                "twos":   m.config.MMR.TwosWeight,
                "threes": m.config.MMR.ThreesWeight,
        }

        // Aggregate skills across playlists
        aggregatedSkill := m.percentileConverter.AggregatePlaylistSkills(playlistNormalizedSkills, weights)

        // Convert to TrueSkill Œº
        finalMu := m.percentileConverter.NormalizedSkillToTrueSkillMu(aggregatedSkill)

        // Calculate total games
        totalGames := (playerData.Ones.Current.Games + playerData.Ones.Previous.Games) +
                (playerData.Twos.Current.Games + playerData.Twos.Previous.Games) +
                (playerData.Threes.Current.Games + playerData.Threes.Previous.Games)

        // Build breakdown exactly matching JavaScript structure
        breakdown := map[string]PlaylistBreakdown{
                "ones": {
                        EffectiveMMR:    playlistEffectiveMMRs["ones"],
                        NormalizedSkill: playlistNormalizedSkills["ones"],
                        Games:           playerData.Ones.Current.Games + playerData.Ones.Previous.Games,
                },
                "twos": {
                        EffectiveMMR:    playlistEffectiveMMRs["twos"],
                        NormalizedSkill: playlistNormalizedSkills["twos"],
                        Games:           playerData.Twos.Current.Games + playerData.Twos.Previous.Games,
                },
                "threes": {
                        EffectiveMMR:    playlistEffectiveMMRs["threes"],
                        NormalizedSkill: playlistNormalizedSkills["threes"],
                        Games:           playerData.Threes.Current.Games + playerData.Threes.Previous.Games,
                },
        }

        return SkillCalculationResult{
                NormalizedSkill: math.Round(aggregatedSkill*100) / 100,
                TrueskillMu:     math.Round(finalMu*100) / 100,
                TotalGames:      totalGames,
                Breakdown:       breakdown,
                Weights:         weights,
                AggregationInfo: AggregationInfo{
                        Method:    "percentile-based",
                        Converter: "PercentileConverter",
                        Timestamp: time.Now().UTC().Format(time.RFC3339),
                },
        }</span>
}

// CalculatePercentileBasedSkillLegacy provides backward compatibility
// Exact port of JavaScript calculatePercentileBasedSkillLegacy()
func (m *MMRCalculator) CalculatePercentileBasedSkillLegacy(
        onesCurrentPeak, onesCurrentGames, onesPreviousPeak, onesPreviousGames,
        twosCurrentPeak, twosCurrentGames, twosPreviousPeak, twosPreviousGames,
        threesCurrentPeak, threesCurrentGames, threesPreviousPeak, threesPreviousGames int) SkillCalculationResult <span class="cov0" title="0">{

        playerData := PlayerMMRData{
                Ones: PlaylistData{
                        Current:  PlaylistSeason{MMR: onesCurrentPeak, Games: onesCurrentGames},
                        Previous: PlaylistSeason{MMR: onesPreviousPeak, Games: onesPreviousGames},
                },
                Twos: PlaylistData{
                        Current:  PlaylistSeason{MMR: twosCurrentPeak, Games: twosCurrentGames},
                        Previous: PlaylistSeason{MMR: twosPreviousPeak, Games: twosPreviousGames},
                },
                Threes: PlaylistData{
                        Current:  PlaylistSeason{MMR: threesCurrentPeak, Games: threesCurrentGames},
                        Previous: PlaylistSeason{MMR: threesPreviousPeak, Games: threesPreviousGames},
                },
        }

        return m.CalculatePercentileBasedSkill(playerData)
}</span>

// CalculatePercentileSkillFromTracker calculates from UserTracker model
// Matches JavaScript calculatePercentileSkillFromRow()
func (m *MMRCalculator) CalculatePercentileSkillFromTracker(tracker models.UserTracker) SkillCalculationResult <span class="cov0" title="0">{
        playerData := PlayerMMRData{
                Ones: PlaylistData{
                        Current:  PlaylistSeason{MMR: tracker.OnesCurrentSeasonPeak, Games: tracker.OnesCurrentSeasonGames},
                        Previous: PlaylistSeason{MMR: tracker.OnesPreviousSeasonPeak, Games: tracker.OnesPreviousSeasonGames},
                },
                Twos: PlaylistData{
                        Current:  PlaylistSeason{MMR: tracker.TwosCurrentSeasonPeak, Games: tracker.TwosCurrentSeasonGames},
                        Previous: PlaylistSeason{MMR: tracker.TwosPreviousSeasonPeak, Games: tracker.TwosPreviousSeasonGames},
                },
                Threes: PlaylistData{
                        Current:  PlaylistSeason{MMR: tracker.ThreesCurrentSeasonPeak, Games: tracker.ThreesCurrentSeasonGames},
                        Previous: PlaylistSeason{MMR: tracker.ThreesPreviousSeasonPeak, Games: tracker.ThreesPreviousSeasonGames},
                },
        }

        return m.CalculatePercentileBasedSkill(playerData)
}</span>

// validatePlayerData ensures the input data is valid
func (m *MMRCalculator) validatePlayerData(playerData PlayerMMRData) error <span class="cov8" title="1">{
        // Basic validation - could be expanded based on JavaScript validation logic
        if playerData.Ones.Current.Games &lt; 0 || playerData.Ones.Previous.Games &lt; 0 ||
                playerData.Twos.Current.Games &lt; 0 || playerData.Twos.Previous.Games &lt; 0 ||
                playerData.Threes.Current.Games &lt; 0 || playerData.Threes.Previous.Games &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("games played cannot be negative")
        }</span>

        <span class="cov8" title="1">if playerData.Ones.Current.MMR &lt; 0 || playerData.Ones.Previous.MMR &lt; 0 ||
                playerData.Twos.Current.MMR &lt; 0 || playerData.Twos.Previous.MMR &lt; 0 ||
                playerData.Threes.Current.MMR &lt; 0 || playerData.Threes.Previous.MMR &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("MMR values cannot be negative")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package services

import (
        "math"
        "sort"
        "usl-server/internal/config"
)

// RankRange represents MMR range for a rank
type RankRange struct {
        Rank   string
        MinMMR float64
        MaxMMR float64
}

// RankInfo contains cached rank information for O(1) lookup
type RankInfo struct {
        CumulativeBelow float64
        RankPercent     float64
}

// PercentileConverter handles MMR to percentile conversions
// Exact port of JavaScript PercentileConverter with performance optimizations
type PercentileConverter struct {
        config                 *config.Config
        sortedRangesByPlaylist map[string][]RankRange
        rankOrderCache         map[string]map[string]RankInfo
}

// NewPercentileConverter creates a new percentile converter
func NewPercentileConverter(cfg *config.Config) *PercentileConverter <span class="cov8" title="1">{
        return &amp;PercentileConverter{
                config:                 cfg,
                sortedRangesByPlaylist: make(map[string][]RankRange),
                rankOrderCache:         make(map[string]map[string]RankInfo),
        }
}</span>

// MMRToPercentile converts MMR to percentile for a given playlist
// Exact port of JavaScript mmrToPercentile() with binary search optimization
func (p *PercentileConverter) MMRToPercentile(mmr float64, playlist string) float64 <span class="cov8" title="1">{

        // Validate inputs
        if mmr &lt; 0 </span><span class="cov0" title="0">{
                mmr = 0
        }</span>

        // Use hardcoded rank distributions matching JavaScript config
        <span class="cov8" title="1">rankDistributions := p.getRankDistributions()
        mmrRanges := p.getMMRRanges()

        if _, exists := rankDistributions[playlist]; !exists </span><span class="cov0" title="0">{
                playlist = "doubles" // Default fallback
        }</span>

        <span class="cov8" title="1">distribution := rankDistributions[playlist]
        ranges := mmrRanges[playlist]

        // Build sorted ranges cache for binary search
        if _, exists := p.sortedRangesByPlaylist[playlist]; !exists </span><span class="cov8" title="1">{
                var sortedRanges []RankRange
                for rank, mmrRange := range ranges </span><span class="cov8" title="1">{
                        sortedRanges = append(sortedRanges, RankRange{
                                Rank:   rank,
                                MinMMR: mmrRange[0],
                                MaxMMR: mmrRange[1],
                        })
                }</span>
                <span class="cov8" title="1">sort.Slice(sortedRanges, func(i, j int) bool </span><span class="cov8" title="1">{
                        return sortedRanges[i].MinMMR &lt; sortedRanges[j].MinMMR
                }</span>)
                <span class="cov8" title="1">p.sortedRangesByPlaylist[playlist] = sortedRanges</span>
        }

        // Binary search to find rank
        <span class="cov8" title="1">targetRank := p.binarySearchRank(mmr, p.sortedRangesByPlaylist[playlist])

        // Handle edge cases
        if targetRank == "" </span><span class="cov0" title="0">{
                if mmr &lt; p.getLowestMMR(ranges) </span><span class="cov0" title="0">{
                        return 0.00001 // Below lowest rank
                }</span> else<span class="cov0" title="0"> {
                        return 99.99999 // Above highest rank
                }</span>
        }

        // Build rank order cache for O(1) lookup
        <span class="cov8" title="1">if _, exists := p.rankOrderCache[playlist]; !exists </span><span class="cov8" title="1">{
                p.rankOrderCache[playlist] = p.buildRankOrderCache(playlist, distribution)
        }</span>

        <span class="cov8" title="1">rankInfo, exists := p.rankOrderCache[playlist][targetRank]
        if !exists </span><span class="cov0" title="0">{
                return 50.0 // Default to median
        }</span>

        // Calculate cumulative percentile
        <span class="cov8" title="1">cumulativePercent := rankInfo.CumulativeBelow

        // Interpolate within the rank based on MMR position
        rankRange := ranges[targetRank]
        rankSpan := rankRange[1] - rankRange[0]
        if rankSpan &gt; 0 </span><span class="cov8" title="1">{
                positionWithinRank := (mmr - rankRange[0]) / rankSpan
                positionWithinRank = math.Max(0, math.Min(1, positionWithinRank))
                cumulativePercent += positionWithinRank * rankInfo.RankPercent
        }</span>

        <span class="cov8" title="1">return math.Max(0.00001, math.Min(99.99999, cumulativePercent))</span>
}

// MMRToNormalizedSkill converts MMR to normalized skill (0-100 scale)
// Exact port of JavaScript mmrToNormalizedSkill()
func (p *PercentileConverter) MMRToNormalizedSkill(mmr float64, playlist string) float64 <span class="cov8" title="1">{
        percentile := p.MMRToPercentile(mmr, playlist)
        return p.PercentileToNormalizedSkill(percentile)
}</span>

// PercentileToNormalizedSkill converts percentile to normalized skill using power expansion transform
// EXACT port of JavaScript percentileToNormalizedSkill() with piecewise function
func (p *PercentileConverter) PercentileToNormalizedSkill(percentile float64) float64 <span class="cov8" title="1">{
        // POWER EXPANSION TRANSFORM v2.0 - Exact JavaScript port
        // Validate input with high precision bounds
        percentile = math.Max(0.00001, math.Min(99.99999, percentile))

        // Power expansion transform - provides superior upper-end separation
        if percentile &lt; 85 </span><span class="cov8" title="1">{
                // Compress lower tiers slightly for stability
                return percentile * 0.85
        }</span> else<span class="cov8" title="1"> {
                // Exponential expansion for elite players (85%+)
                excess := percentile - 85
                baseValue := 85 * 0.85 // 72.25
                expandedExcess := math.Pow(excess/15, 1.5) * 27.75
                normalizedSkill := baseValue + expandedExcess

                // Ensure bounds with high precision (matches JavaScript SKILL_SCALE)
                return math.Max(0.00001, math.Min(99.99999, normalizedSkill))
        }</span>
}

// NormalizedSkillToTrueSkillMu converts normalized skill to TrueSkill Œº
// EXACT port of JavaScript normalizedSkillToTrueSkillMu() with proper config values
func (p *PercentileConverter) NormalizedSkillToTrueSkillMu(normalizedSkill float64) float64 <span class="cov8" title="1">{
        // Validate input
        normalizedSkill = math.Max(0, math.Min(100, normalizedSkill))

        // JavaScript config values - EXACT match
        // MU_SCALE: { MIN: 0, MAX: 2000 }
        // SKILL_SCALE: { MIN: 0.00001, MAX: 99.99999 }
        muMin := 0.0
        muMax := 2000.0
        skillMin := 0.00001
        skillMax := 99.99999

        // Linear mapping from normalized skill to Œº scale (matches JavaScript exactly)
        muRange := muMax - muMin
        skillRange := skillMax - skillMin

        mu := muMin + (normalizedSkill/skillRange)*muRange

        // Ensure bounds
        return math.Max(muMin, math.Min(muMax, mu))
}</span>

// AggregatePlaylistSkills aggregates skills across playlists with weights
// Exact port of JavaScript aggregatePlaylistSkills()
func (p *PercentileConverter) AggregatePlaylistSkills(playlistSkills map[string]*float64, weights map[string]float64) float64 <span class="cov8" title="1">{
        var totalWeightedSkill, totalWeight float64

        for playlist, skill := range playlistSkills </span><span class="cov8" title="1">{
                if skill != nil &amp;&amp; weights[playlist] &gt; 0 </span><span class="cov8" title="1">{
                        totalWeightedSkill += *skill * weights[playlist]
                        totalWeight += weights[playlist]
                }</span>
        }

        <span class="cov8" title="1">if totalWeight == 0 </span><span class="cov8" title="1">{
                return 50.0 // Default to median skill if no valid data
        }</span>

        <span class="cov8" title="1">return totalWeightedSkill / totalWeight</span>
}

// Helper functions

func (p *PercentileConverter) binarySearchRank(mmr float64, sortedRanges []RankRange) string <span class="cov8" title="1">{
        left, right := 0, len(sortedRanges)-1

        for left &lt;= right </span><span class="cov8" title="1">{
                mid := (left + right) / 2
                r := sortedRanges[mid]

                if mmr &gt;= r.MinMMR &amp;&amp; mmr &lt;= r.MaxMMR </span><span class="cov8" title="1">{
                        return r.Rank
                }</span> else<span class="cov8" title="1"> if mmr &lt; r.MinMMR </span><span class="cov8" title="1">{
                        right = mid - 1
                }</span> else<span class="cov8" title="1"> {
                        left = mid + 1
                }</span>
        }

        <span class="cov0" title="0">return ""</span> // Not found
}

func (p *PercentileConverter) getLowestMMR(ranges map[string][2]float64) float64 <span class="cov0" title="0">{
        lowest := math.Inf(1)
        for _, mmrRange := range ranges </span><span class="cov0" title="0">{
                if mmrRange[0] &lt; lowest </span><span class="cov0" title="0">{
                        lowest = mmrRange[0]
                }</span>
        }
        <span class="cov0" title="0">return lowest</span>
}

func (p *PercentileConverter) buildRankOrderCache(playlist string, distribution map[string]float64) map[string]RankInfo <span class="cov8" title="1">{
        cache := make(map[string]RankInfo)

        // EXACT JavaScript rank order matching PercentileConfig.js
        var cumulative float64

        // Rank order matching JavaScript _buildRankOrderCache()
        rankOrder := []string{
                "Bronze 1", "Bronze 2", "Bronze 3",
                "Silver 1", "Silver 2", "Silver 3",
                "Gold 1", "Gold 2", "Gold 3",
                "Platinum 1", "Platinum 2", "Platinum 3",
                "Diamond 1", "Diamond 2", "Diamond 3",
                "Champion 1", "Champion 2", "Champion 3",
                "Grand Champion 1", "Grand Champion 2", "Grand Champion 3",
                "Supersonic Legend",
        }

        for _, rank := range rankOrder </span><span class="cov8" title="1">{
                if percent, exists := distribution[rank]; exists </span><span class="cov8" title="1">{
                        cache[rank] = RankInfo{
                                CumulativeBelow: cumulative,
                                RankPercent:     percent,
                        }
                        cumulative += percent
                }</span>
        }

        <span class="cov8" title="1">return cache</span>
}

// Hardcoded configuration data (matches JavaScript PercentileConfig)

func (p *PercentileConverter) getRankDistributions() map[string]map[string]float64 <span class="cov8" title="1">{
        // EXACT JavaScript rank distributions from PercentileConfig.js (Season 14, 2024)
        return map[string]map[string]float64{
                "soloDuel": {
                        "Bronze 1": 0.063, "Bronze 2": 0.296, "Bronze 3": 0.952,
                        "Silver 1": 2.248, "Silver 2": 4.383, "Silver 3": 7.353,
                        "Gold 1": 11.090, "Gold 2": 14.354, "Gold 3": 16.356,
                        "Platinum 1": 16.361, "Platinum 2": 11.923, "Platinum 3": 7.116,
                        "Diamond 1": 3.828, "Diamond 2": 1.864, "Diamond 3": 0.921,
                        "Champion 1": 0.473, "Champion 2": 0.217, "Champion 3": 0.103,
                        "Grand Champion 1": 0.053, "Grand Champion 2": 0.024, "Grand Champion 3": 0.011,
                        "Supersonic Legend": 0.013,
                },
                "doubles": {
                        "Bronze 1": 0.292, "Bronze 2": 0.713, "Bronze 3": 1.485,
                        "Silver 1": 2.741, "Silver 2": 4.411, "Silver 3": 6.346,
                        "Gold 1": 8.427, "Gold 2": 9.790, "Gold 3": 10.237,
                        "Platinum 1": 10.422, "Platinum 2": 9.093, "Platinum 3": 7.552,
                        "Diamond 1": 8.364, "Diamond 2": 6.109, "Diamond 3": 4.451,
                        "Champion 1": 4.663, "Champion 2": 2.397, "Champion 3": 1.272,
                        "Grand Champion 1": 0.809, "Grand Champion 2": 0.293, "Grand Champion 3": 0.087,
                        "Supersonic Legend": 0.045,
                },
                "standard": {
                        "Bronze 1": 0.112, "Bronze 2": 0.347, "Bronze 3": 0.956,
                        "Silver 1": 2.316, "Silver 2": 4.882, "Silver 3": 8.466,
                        "Gold 1": 12.146, "Gold 2": 13.673, "Gold 3": 12.832,
                        "Platinum 1": 11.137, "Platinum 2": 8.700, "Platinum 3": 6.701,
                        "Diamond 1": 6.651, "Diamond 2": 4.291, "Diamond 3": 2.742,
                        "Champion 1": 2.339, "Champion 2": 0.989, "Champion 3": 0.431,
                        "Grand Champion 1": 0.205, "Grand Champion 2": 0.064, "Grand Champion 3": 0.017,
                        "Supersonic Legend": 0.003,
                },
        }
}</span>

func (p *PercentileConverter) getMMRRanges() map[string]map[string][2]float64 <span class="cov8" title="1">{
        // EXACT JavaScript MMR ranges from PercentileConfig.js
        return map[string]map[string][2]float64{
                "soloDuel": {
                        "Bronze 1": {0, 152}, "Bronze 2": {153, 214}, "Bronze 3": {215, 274},
                        "Silver 1": {275, 334}, "Silver 2": {335, 394}, "Silver 3": {395, 454},
                        "Gold 1": {455, 514}, "Gold 2": {515, 574}, "Gold 3": {575, 634},
                        "Platinum 1": {635, 694}, "Platinum 2": {695, 754}, "Platinum 3": {755, 814},
                        "Diamond 1": {815, 874}, "Diamond 2": {875, 934}, "Diamond 3": {935, 994},
                        "Champion 1": {995, 1054}, "Champion 2": {1055, 1114}, "Champion 3": {1115, 1174},
                        "Grand Champion 1": {1175, 1234}, "Grand Champion 2": {1235, 1294}, "Grand Champion 3": {1295, 1354},
                        "Supersonic Legend": {1355, 2000},
                },
                "doubles": {
                        "Bronze 1": {0, 152}, "Bronze 2": {153, 214}, "Bronze 3": {215, 274},
                        "Silver 1": {275, 334}, "Silver 2": {335, 394}, "Silver 3": {395, 454},
                        "Gold 1": {455, 514}, "Gold 2": {515, 574}, "Gold 3": {575, 634},
                        "Platinum 1": {635, 694}, "Platinum 2": {695, 754}, "Platinum 3": {755, 814},
                        "Diamond 1": {815, 874}, "Diamond 2": {875, 934}, "Diamond 3": {935, 994},
                        "Champion 1": {995, 1074}, "Champion 2": {1075, 1174}, "Champion 3": {1175, 1274},
                        "Grand Champion 1": {1275, 1374}, "Grand Champion 2": {1375, 1474}, "Grand Champion 3": {1475, 1574},
                        "Supersonic Legend": {1575, 2300},
                },
                "standard": {
                        "Bronze 1": {0, 152}, "Bronze 2": {153, 214}, "Bronze 3": {215, 274},
                        "Silver 1": {275, 334}, "Silver 2": {335, 394}, "Silver 3": {395, 454},
                        "Gold 1": {455, 514}, "Gold 2": {515, 574}, "Gold 3": {575, 634},
                        "Platinum 1": {635, 694}, "Platinum 2": {695, 754}, "Platinum 3": {755, 834},
                        "Diamond 1": {835, 914}, "Diamond 2": {915, 994}, "Diamond 3": {995, 1074},
                        "Champion 1": {1075, 1174}, "Champion 2": {1175, 1274}, "Champion 3": {1275, 1374},
                        "Grand Champion 1": {1375, 1474}, "Grand Champion 2": {1475, 1574}, "Grand Champion 3": {1575, 1674},
                        "Supersonic Legend": {1675, 2300},
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package services

import (
        "usl-server/internal/models"
        "usl-server/internal/repositories"
)

const (
        // Permission level constants for display
        PermissionLevelAdmin     = "Admin"
        PermissionLevelModerator = "Moderator"
        PermissionLevelMember    = "Member"
        PermissionLevelNone      = "None"
)

// GuildConfigProvider interface for getting guild configurations
type GuildConfigProvider interface {
        GetConfig(guildID int64) (*models.GuildConfig, error)
}

// PermissionService handles role-based permissions for guilds
type PermissionService struct {
        guildRepo GuildConfigProvider
}

// NewPermissionService creates a new permission service
func NewPermissionService(guildRepo *repositories.GuildRepository) *PermissionService <span class="cov0" title="0">{
        return &amp;PermissionService{
                guildRepo: guildRepo,
        }
}</span>

func (s *PermissionService) CanAddUsers(userRoles []string, guildID int64) bool <span class="cov0" title="0">{
        return s.hasPermission(userRoles, guildID, (*models.GuildConfig).HasModeratorRole)
}</span>

func (s *PermissionService) CanAddTrackers(userRoles []string, guildID int64) bool <span class="cov0" title="0">{
        return s.hasPermission(userRoles, guildID, (*models.GuildConfig).HasModeratorRole)
}</span>

func (s *PermissionService) CanRunAdminCommands(userRoles []string, guildID int64) bool <span class="cov0" title="0">{
        return s.hasPermission(userRoles, guildID, (*models.GuildConfig).HasAdminRole)
}</span>

func (s *PermissionService) CanManageGuildConfig(userRoles []string, guildID int64) bool <span class="cov0" title="0">{
        return s.hasPermission(userRoles, guildID, (*models.GuildConfig).HasAdminRole)
}</span>

// hasPermission is a helper method that implements the common permission checking pattern
func (s *PermissionService) hasPermission(userRoles []string, guildID int64,
        checkFunc func(*models.GuildConfig, []string) bool) bool <span class="cov0" title="0">{
        config, err := s.guildRepo.GetConfig(guildID)
        if err != nil </span><span class="cov0" title="0">{
                return false // fail secure
        }</span>

        <span class="cov0" title="0">return checkFunc(config, userRoles)</span>
}

// GetUserPermissions returns a summary of what the user can do in the guild
func (s *PermissionService) GetUserPermissions(userRoles []string, guildID int64) UserPermissions <span class="cov0" title="0">{
        config, err := s.guildRepo.GetConfig(guildID)
        if err != nil </span><span class="cov0" title="0">{
                return UserPermissions{} // no permissions if config can't be loaded
        }</span>

        <span class="cov0" title="0">isAdmin := config.HasAdminRole(userRoles)
        isModerator := config.HasModeratorRole(userRoles)

        return UserPermissions{
                CanAddUsers:         isModerator,
                CanAddTrackers:      isModerator,
                CanRunAdminCommands: isAdmin,
                CanManageConfig:     isAdmin,
                IsAdmin:             isAdmin,
                IsModerator:         isModerator,
        }</span>
}

func (s *PermissionService) ValidateGuildAccess(userRoles []string, guildID int64) bool <span class="cov0" title="0">{
        permissions := s.GetUserPermissions(userRoles, guildID)
        return permissions.HasAnyPermissions()
}</span>

// UserPermissions represents what a user can do in a specific guild
type UserPermissions struct {
        CanAddUsers         bool `json:"can_add_users"`
        CanAddTrackers      bool `json:"can_add_trackers"`
        CanRunAdminCommands bool `json:"can_run_admin_commands"`
        CanManageConfig     bool `json:"can_manage_config"`
        IsAdmin             bool `json:"is_admin"`
        IsModerator         bool `json:"is_moderator"`
}

func (up UserPermissions) HasAnyPermissions() bool <span class="cov0" title="0">{
        return up.CanAddUsers || up.CanAddTrackers || up.CanRunAdminCommands || up.CanManageConfig
}</span>

func (up UserPermissions) PermissionLevel() string <span class="cov0" title="0">{
        if up.IsAdmin </span><span class="cov0" title="0">{
                return PermissionLevelAdmin
        }</span>
        <span class="cov0" title="0">if up.IsModerator </span><span class="cov0" title="0">{
                return PermissionLevelModerator
        }</span>
        <span class="cov0" title="0">if up.HasAnyPermissions() </span><span class="cov0" title="0">{
                return PermissionLevelMember
        }</span>
        <span class="cov0" title="0">return PermissionLevelNone</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "fmt"
        "log"
        "time"
        "usl-server/internal/config"
        "usl-server/internal/models"
        "usl-server/internal/repositories"
)

// UserTrueSkillService manages TrueSkill calculations and updates for individual users and batch operations.
// Exact port of JavaScript UserTrueSkillService with dependency injection pattern.
//
// Service Responsibilities:
// - Individual user TrueSkill calculation from tracker data
// - Batch TrueSkill updates for all users
// - Default TrueSkill assignment for users without trackers
// - TrueSkill recalculation workflows
type UserTrueSkillService struct {
        // Service dependencies - injected at runtime
        trackerRepo               *repositories.TrackerRepository
        userRepo                  *repositories.UserRepository
        percentileCalculator      *MMRCalculator
        enhancedUncertainty       *EnhancedUncertaintyCalculator
        dataTransformationService *DataTransformationService
        config                    *config.Config
}

// BatchUpdateResult represents batch processing results
type BatchUpdateResult struct {
        ProcessedCount    int                        `json:"processedCount"`
        TrackerBasedCount int                        `json:"trackerBasedCount"`
        DefaultCount      int                        `json:"defaultCount"`
        Errors            []TrueSkillProcessingError `json:"errors"`
}

// TrueSkillProcessingError represents errors during batch processing
type TrueSkillProcessingError struct {
        User      string `json:"user"`
        DiscordID string `json:"discordId"`
        Error     string `json:"error"`
}

// TrueSkillUpdateResult represents individual user update results
type TrueSkillUpdateResult struct {
        Success         bool                  `json:"success"`
        HadTrackers     bool                  `json:"hadTrackers"`
        TrueSkillResult *TrueSkillCalculation `json:"trueSkillResult,omitempty"`
        Error           string                `json:"error,omitempty"`
}

// TrueSkillCalculation represents TrueSkill calculation results
type TrueSkillCalculation struct {
        Mu          float64                `json:"mu"`
        Sigma       float64                `json:"sigma"`
        SkillResult *PercentileSkillResult `json:"skillResult"`
        LastUpdated time.Time              `json:"lastUpdated"`
}

// NewUserTrueSkillService creates a new user TrueSkill service instance
func NewUserTrueSkillService(
        trackerRepo *repositories.TrackerRepository,
        userRepo *repositories.UserRepository,
        percentileCalculator *MMRCalculator,
        enhancedUncertainty *EnhancedUncertaintyCalculator,
        dataTransformationService *DataTransformationService,
        config *config.Config,
) *UserTrueSkillService <span class="cov0" title="0">{
        return &amp;UserTrueSkillService{
                trackerRepo:               trackerRepo,
                userRepo:                  userRepo,
                percentileCalculator:      percentileCalculator,
                enhancedUncertainty:       enhancedUncertainty,
                dataTransformationService: dataTransformationService,
                config:                    config,
        }
}</span>

// UpdateAllUserTrueSkill updates TrueSkill values for all users
// Exact port of JavaScript updateAllUserTrueSkill() function
func (s *UserTrueSkillService) UpdateAllUserTrueSkill() (*BatchUpdateResult, error) <span class="cov0" title="0">{
        // Get all users from repository
        allUsers, err := s.userRepo.GetAllUsers(false) // Get all users, not just active
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all users: %w", err)
        }</span>

        <span class="cov0" title="0">if len(allUsers) == 0 </span><span class="cov0" title="0">{
                log.Println("UserTrueSkillService: No users found in repository")
                return &amp;BatchUpdateResult{
                        ProcessedCount:    0,
                        TrackerBasedCount: 0,
                        DefaultCount:      0,
                        Errors:            []TrueSkillProcessingError{},
                }, nil
        }</span>

        <span class="cov0" title="0">log.Printf("UserTrueSkillService: Processing %d users for batch TrueSkill update", len(allUsers))

        var trackerBasedCount int
        var defaultCount int
        var errors []TrueSkillProcessingError
        var usersToUpdate []models.User

        // Calculate TrueSkill for all users and build batch update data
        for _, user := range allUsers </span><span class="cov0" title="0">{
                updatedUser := *user // Copy user data

                // Try to get trackers and calculate TrueSkill
                trackers, err := s.getUserTrackersForTrueSkill(user.DiscordID)
                if err != nil || len(trackers) == 0 </span><span class="cov0" title="0">{
                        // No trackers - use existing values or defaults
                        defaultCount++
                        if !user.HasTrueSkillData() </span><span class="cov0" title="0">{
                                // User has no TrueSkill data, set defaults
                                s.setDefaultTrueSkillValues(&amp;updatedUser)
                        }</span>
                        <span class="cov0" title="0">updatedUser.TrueSkillLastUpdated = time.Now()
                        log.Printf("Keeping existing TrueSkill for %s: Œº=%.1f", user.Name, updatedUser.TrueSkillMu)</span>
                } else<span class="cov0" title="0"> {
                        // User has trackers - calculate new TrueSkill values
                        trackerData, err := s.dataTransformationService.PrepareTrackerDataForCalculation(trackers[0])
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to prepare tracker data for %s: %v", user.Name, err)
                                errors = append(errors, TrueSkillProcessingError{
                                        User:      user.Name,
                                        DiscordID: user.DiscordID,
                                        Error:     fmt.Sprintf("failed to prepare tracker data: %v", err),
                                })
                                // Fall back to existing values
                                defaultCount++
                                updatedUser.TrueSkillLastUpdated = time.Now()
                                continue</span>
                        }

                        <span class="cov0" title="0">trueSkillResult, err := s.calculateTrueSkillValues(trackerData)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to calculate TrueSkill for %s: %v", user.Name, err)
                                errors = append(errors, TrueSkillProcessingError{
                                        User:      user.Name,
                                        DiscordID: user.DiscordID,
                                        Error:     fmt.Sprintf("failed to calculate TrueSkill: %v", err),
                                })
                                // Fall back to existing values
                                defaultCount++
                                updatedUser.TrueSkillLastUpdated = time.Now()
                                continue</span>
                        }

                        <span class="cov0" title="0">trackerBasedCount++
                        updatedUser.TrueSkillMu = trueSkillResult.Mu
                        updatedUser.TrueSkillSigma = trueSkillResult.Sigma
                        updatedUser.TrueSkillLastUpdated = trueSkillResult.LastUpdated
                        log.Printf("Calculated TrueSkill for %s: Œº=%.1f", user.Name, trueSkillResult.Mu)</span>
                }

                <span class="cov0" title="0">usersToUpdate = append(usersToUpdate, updatedUser)</span>
        }

        // Batch update all users
        <span class="cov0" title="0">log.Printf("UserTrueSkillService: Batch updating %d users with new TrueSkill values", len(usersToUpdate))
        successCount, err := s.userRepo.BatchUpdateTrueSkill(usersToUpdate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("batch update failed: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("UserTrueSkillService: Batch update completed successfully, updated %d users", successCount)

        result := &amp;BatchUpdateResult{
                ProcessedCount:    len(allUsers),
                TrackerBasedCount: trackerBasedCount,
                DefaultCount:      defaultCount,
                Errors:            errors,
        }

        s.reportBatchUpdateResults(result)
        return result, nil</span>
}

// UpdateUserTrueSkillFromTrackerData updates TrueSkill for a single user from provided tracker data
// This method bypasses the repository layer and accepts TrackerData directly
func (s *UserTrueSkillService) UpdateUserTrueSkillFromTrackerData(trackerData *TrackerData) *TrueSkillUpdateResult <span class="cov8" title="1">{
        // Validate tracker data
        if err := s.dataTransformationService.ValidateTrackerData(trackerData); err != nil </span><span class="cov8" title="1">{
                return &amp;TrueSkillUpdateResult{
                        Success:     false,
                        HadTrackers: true,
                        Error:       fmt.Sprintf("invalid tracker data: %v", err),
                }
        }</span>

        // Calculate TrueSkill values directly from provided tracker data
        <span class="cov8" title="1">trueSkillResult, err := s.calculateTrueSkillValues(trackerData)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;TrueSkillUpdateResult{
                        Success:     false,
                        HadTrackers: true,
                        Error:       fmt.Sprintf("failed to calculate TrueSkill: %v", err),
                }
        }</span>

        // Update user with new TrueSkill values
        <span class="cov8" title="1">err = s.updateUserWithTrueSkillValues(trackerData.DiscordID, trueSkillResult)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;TrueSkillUpdateResult{
                        Success:     false,
                        HadTrackers: true,
                        Error:       fmt.Sprintf("failed to update user: %v", err),
                }
        }</span>

        <span class="cov0" title="0">log.Printf("UserTrueSkillService: Updated TrueSkill for user %s: Œº=%.1f, œÉ=%.2f (from TrackerData)",
                trackerData.DiscordID, trueSkillResult.Mu, trueSkillResult.Sigma)

        return &amp;TrueSkillUpdateResult{
                Success:         true,
                HadTrackers:     true,
                TrueSkillResult: trueSkillResult,
        }</span>
}

// UpdateUserTrueSkillFromTrackers updates TrueSkill for a single user from their tracker data
// Exact port of JavaScript updateUserTrueSkillFromTrackers() function
func (s *UserTrueSkillService) UpdateUserTrueSkillFromTrackers(discordID string) *TrueSkillUpdateResult <span class="cov0" title="0">{
        trackers, err := s.getUserTrackersForTrueSkill(discordID)
        if err != nil || len(trackers) == 0 </span><span class="cov0" title="0">{
                return &amp;TrueSkillUpdateResult{
                        Success:     false,
                        HadTrackers: false,
                }
        }</span>

        <span class="cov0" title="0">trackerData, err := s.dataTransformationService.PrepareTrackerDataForCalculation(trackers[0])
        if err != nil </span><span class="cov0" title="0">{
                return &amp;TrueSkillUpdateResult{
                        Success:     false,
                        HadTrackers: true,
                        Error:       fmt.Sprintf("failed to prepare tracker data: %v", err),
                }
        }</span>

        <span class="cov0" title="0">trueSkillResult, err := s.calculateTrueSkillValues(trackerData)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;TrueSkillUpdateResult{
                        Success:     false,
                        HadTrackers: true,
                        Error:       fmt.Sprintf("failed to calculate TrueSkill: %v", err),
                }
        }</span>

        // Update user with new TrueSkill values
        <span class="cov0" title="0">err = s.updateUserWithTrueSkillValues(discordID, trueSkillResult)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;TrueSkillUpdateResult{
                        Success:     false,
                        HadTrackers: true,
                        Error:       fmt.Sprintf("failed to update user: %v", err),
                }
        }</span>

        <span class="cov0" title="0">log.Printf("UserTrueSkillService: Updated TrueSkill for user %s: Œº=%.1f, œÉ=%.2f (percentile-based)",
                discordID, trueSkillResult.Mu, trueSkillResult.Sigma)

        return &amp;TrueSkillUpdateResult{
                Success:         true,
                HadTrackers:     true,
                TrueSkillResult: trueSkillResult,
        }</span>
}

// RecalculateAllUserTrueSkill recalculates TrueSkill values for all users
// Exact port of JavaScript recalculateAllUserTrueSkill() function
func (s *UserTrueSkillService) RecalculateAllUserTrueSkill() (*BatchUpdateResult, error) <span class="cov0" title="0">{
        log.Println("UserTrueSkillService: Recalculating all user TrueSkill values (delegating to UpdateAllUserTrueSkill)")
        return s.UpdateAllUserTrueSkill()
}</span>

// getUserTrackersForTrueSkill gets valid trackers for a user's TrueSkill calculation
// Exact port of JavaScript _getUserTrackersForTrueSkill() function
func (s *UserTrueSkillService) getUserTrackersForTrueSkill(discordID string) ([]*models.UserTracker, error) <span class="cov0" title="0">{
        trackers, err := s.trackerRepo.GetTrackersByDiscordID(discordID, true) // activeOnly = true
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("UserTrueSkillService: Error getting trackers for user %s: %v", discordID, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(trackers) == 0 </span><span class="cov0" title="0">{
                log.Printf("UserTrueSkillService: No trackers found for user %s", discordID)
                return nil, nil
        }</span>

        <span class="cov0" title="0">return trackers, nil</span>
}

// calculateTrueSkillValues calculates TrueSkill values from tracker data
// Exact port of JavaScript _calculateTrueSkillValues() function
func (s *UserTrueSkillService) calculateTrueSkillValues(trackerData *TrackerData) (*TrueSkillCalculation, error) <span class="cov8" title="1">{
        // Calculate percentile-based TrueSkill seeding using structured object format
        playerData := PlayerData{
                Ones: PlaylistData{
                        Current:  PlaylistSeasonData{MMR: trackerData.OnesCurrentPeak, Games: trackerData.OnesCurrentGames},
                        Previous: PlaylistSeasonData{MMR: trackerData.OnesPreviousPeak, Games: trackerData.OnesPreviousGames},
                },
                Twos: PlaylistData{
                        Current:  PlaylistSeasonData{MMR: trackerData.TwosCurrentPeak, Games: trackerData.TwosCurrentGames},
                        Previous: PlaylistSeasonData{MMR: trackerData.TwosPreviousPeak, Games: trackerData.TwosPreviousGames},
                },
                Threes: PlaylistData{
                        Current:  PlaylistSeasonData{MMR: trackerData.ThreesCurrentPeak, Games: trackerData.ThreesCurrentGames},
                        Previous: PlaylistSeasonData{MMR: trackerData.ThreesPreviousPeak, Games: trackerData.ThreesPreviousGames},
                },
        }

        skillResult := s.percentileCalculator.CalculatePercentileBasedSkill(playerData)

        trueskillSigma, err := s.enhancedUncertainty.CalculateEnhancedUncertainty(trackerData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate enhanced uncertainty: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;TrueSkillCalculation{
                Mu:          skillResult.TrueskillMu,
                Sigma:       trueskillSigma,
                SkillResult: &amp;skillResult,
                LastUpdated: time.Now(),
        }, nil</span>
}

// updateUserWithTrueSkillValues updates a user's TrueSkill values in the database
// Exact port of JavaScript _updateUserWithTrueSkillValues() function
func (s *UserTrueSkillService) updateUserWithTrueSkillValues(discordID string, trueSkillResult *TrueSkillCalculation) error <span class="cov8" title="1">{
        return s.userRepo.UpdateUserTrueSkill(
                discordID,
                trueSkillResult.Mu,
                trueSkillResult.Sigma,
                &amp;trueSkillResult.LastUpdated,
        )
}</span>

// setDefaultTrueSkillValues sets default TrueSkill values for users without tracker data
// Exact port of JavaScript _setDefaultTrueSkillValues() function
func (s *UserTrueSkillService) setDefaultTrueSkillValues(user *models.User) <span class="cov0" title="0">{
        // For users without tracker data, use reasonable defaults
        defaultMu, defaultSigma := s.config.GetTrueSkillDefaults()

        user.TrueSkillMu = defaultMu
        user.TrueSkillSigma = defaultSigma

        log.Printf("UserTrueSkillService: Set default TrueSkill for user %s: Œº=%.1f, œÉ=%.1f",
                user.DiscordID, defaultMu, defaultSigma)
}</span>

// reportBatchUpdateResults reports the results of batch processing
// Exact port of JavaScript _reportBatchUpdateResults() function
func (s *UserTrueSkillService) reportBatchUpdateResults(result *BatchUpdateResult) <span class="cov0" title="0">{
        log.Printf("UserTrueSkillService: Successfully processed %d users (%d given default values)",
                result.ProcessedCount, result.DefaultCount)

        if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("UserTrueSkillService: %d errors occurred during batch processing", len(result.Errors))
                for _, err := range result.Errors </span><span class="cov0" title="0">{
                        log.Printf("  - User %s (%s): %s", err.User, err.DiscordID, err.Error)
                }</span>
        }

        <span class="cov0" title="0">log.Printf("TrueSkill update complete! Processed %d users. %d calculated from trackers, %d given default values.",
                result.ProcessedCount, result.TrackerBasedCount, result.DefaultCount)</span>
}

// GetTrueSkillStats returns service statistics
// Exact port of JavaScript getTrueSkillStats() function
func (s *UserTrueSkillService) GetTrueSkillStats() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "serviceName": "UserTrueSkillService",
                "version":     "1.0.0",
                "dependencies": map[string]bool{
                        "trackerRepo":               s.trackerRepo != nil,
                        "userRepo":                  s.userRepo != nil,
                        "percentileCalculator":      s.percentileCalculator != nil,
                        "enhancedUncertainty":       s.enhancedUncertainty != nil,
                        "dataTransformationService": s.dataTransformationService != nil,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "html/template"
        "log"
        "net/http"
        "strconv"
        "time"
        "usl-server/internal/config"
        "usl-server/internal/models"
        "usl-server/internal/services"
        "usl-server/internal/usl"
)

// USL-specific constants for type safety
const (
        USLDiscordGuildID = "1390537743385231451" // USL Discord Guild ID
)

// FormField represents typed form field names
type FormField string

const (
        FormFieldDiscordID           FormField = "discord_id"
        FormFieldURL                 FormField = "url"
        FormFieldName                FormField = "name"
        FormFieldActive              FormField = "active"
        FormFieldBanned              FormField = "banned"
        FormFieldValid               FormField = "valid"
        FormFieldID                  FormField = "id"
        FormFieldOnesCurrentPeak     FormField = "ones_current_peak"
        FormFieldOnesPreviousPeak    FormField = "ones_previous_peak"
        FormFieldOnesAllTimePeak     FormField = "ones_all_time_peak"
        FormFieldOnesCurrentGames    FormField = "ones_current_games"
        FormFieldOnesPreviousGames   FormField = "ones_previous_games"
        FormFieldTwosCurrentPeak     FormField = "twos_current_peak"
        FormFieldTwosPreviousPeak    FormField = "twos_previous_peak"
        FormFieldTwosAllTimePeak     FormField = "twos_all_time_peak"
        FormFieldTwosCurrentGames    FormField = "twos_current_games"
        FormFieldTwosPreviousGames   FormField = "twos_previous_games"
        FormFieldThreesCurrentPeak   FormField = "threes_current_peak"
        FormFieldThreesPreviousPeak  FormField = "threes_previous_peak"
        FormFieldThreesAllTimePeak   FormField = "threes_all_time_peak"
        FormFieldThreesCurrentGames  FormField = "threes_current_games"
        FormFieldThreesPreviousGames FormField = "threes_previous_games"
)

// TemplateName represents typed template names
type TemplateName string

const (
        TemplateUSLUsers          TemplateName = "usl_users.html"
        TemplateUSLUserForm       TemplateName = "usl_user_form.html"
        TemplateUSLUserEditForm   TemplateName = "usl_user_edit_form.html"
        TemplateUSLTrackers       TemplateName = "usl_trackers.html"
        TemplateUSLTrackerForm    TemplateName = "usl_tracker_form.html"
        TemplateUSLAdminDashboard TemplateName = "layout.html"
        TemplateUSLImport         TemplateName = "usl_import.html"
)

// parseIntField safely converts a form field to int, returning 0 for empty or invalid values
func parseIntField(value string) int <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if i, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                return i
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// parseUserID safely converts a string to a user ID with proper error handling
func (h *MigrationHandler) parseUserID(userIDStr string) (int64, error) <span class="cov0" title="0">{
        if userIDStr == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("user ID cannot be empty")
        }</span>
        <span class="cov0" title="0">userID, err := strconv.ParseInt(userIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid user ID format: %v", err)
        }</span>
        <span class="cov0" title="0">return userID, nil</span>
}

// getFormValue safely extracts a typed form value
func (h *MigrationHandler) getFormValue(r *http.Request, field FormField) string <span class="cov0" title="0">{
        return r.FormValue(string(field))
}</span>

// getFormBoolValue safely extracts a boolean form value
func (h *MigrationHandler) getFormBoolValue(r *http.Request, field FormField) bool <span class="cov0" title="0">{
        return h.getFormValue(r, field) == "true"
}</span>

// getFormIntValue safely extracts an integer form value
func (h *MigrationHandler) getFormIntValue(r *http.Request, field FormField) int <span class="cov0" title="0">{
        return parseIntField(h.getFormValue(r, field))
}</span>

// handleMethodNotAllowed returns a standardized method not allowed error
func (h *MigrationHandler) handleMethodNotAllowed(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
}</span>

// handleInvalidFormData returns a standardized form data error
func (h *MigrationHandler) handleInvalidFormData(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        log.Printf("[USL-HANDLER] Form parsing error: %v", err)
        http.Error(w, "Invalid form data", http.StatusBadRequest)
}</span>

// handleDatabaseError logs and returns a standardized database error
func (h *MigrationHandler) handleDatabaseError(w http.ResponseWriter, operation string, err error) <span class="cov0" title="0">{
        log.Printf("[USL-HANDLER] Database error during %s: %v", operation, err)
        http.Error(w, fmt.Sprintf("Failed to %s", operation), http.StatusInternalServerError)
}</span>

// handleInvalidID returns a standardized invalid ID error
func (h *MigrationHandler) handleInvalidID(w http.ResponseWriter, idType string) <span class="cov0" title="0">{
        http.Error(w, fmt.Sprintf("%s is required", idType), http.StatusBadRequest)
}</span>

// handleParseError returns a standardized parsing error
func (h *MigrationHandler) handleParseError(w http.ResponseWriter, fieldName string) <span class="cov0" title="0">{
        http.Error(w, fmt.Sprintf("Invalid %s", fieldName), http.StatusBadRequest)
}</span>

// buildTrackerFromForm creates a USLUserTracker from form data
func (h *MigrationHandler) buildTrackerFromForm(r *http.Request) *usl.USLUserTracker <span class="cov0" title="0">{
        discordID := h.getFormValue(r, FormFieldDiscordID)
        url := h.getFormValue(r, FormFieldURL)
        log.Printf("[USL-HANDLER] Building tracker from form: Discord=%s, URL=%s", discordID, url)

        return &amp;usl.USLUserTracker{
                DiscordID:                       discordID,
                URL:                             url,
                OnesCurrentSeasonPeak:           h.getFormIntValue(r, FormFieldOnesCurrentPeak),
                OnesPreviousSeasonPeak:          h.getFormIntValue(r, FormFieldOnesPreviousPeak),
                OnesAllTimePeak:                 h.getFormIntValue(r, FormFieldOnesAllTimePeak),
                OnesCurrentSeasonGamesPlayed:    h.getFormIntValue(r, FormFieldOnesCurrentGames),
                OnesPreviousSeasonGamesPlayed:   h.getFormIntValue(r, FormFieldOnesPreviousGames),
                TwosCurrentSeasonPeak:           h.getFormIntValue(r, FormFieldTwosCurrentPeak),
                TwosPreviousSeasonPeak:          h.getFormIntValue(r, FormFieldTwosPreviousPeak),
                TwosAllTimePeak:                 h.getFormIntValue(r, FormFieldTwosAllTimePeak),
                TwosCurrentSeasonGamesPlayed:    h.getFormIntValue(r, FormFieldTwosCurrentGames),
                TwosPreviousSeasonGamesPlayed:   h.getFormIntValue(r, FormFieldTwosPreviousGames),
                ThreesCurrentSeasonPeak:         h.getFormIntValue(r, FormFieldThreesCurrentPeak),
                ThreesPreviousSeasonPeak:        h.getFormIntValue(r, FormFieldThreesPreviousPeak),
                ThreesAllTimePeak:               h.getFormIntValue(r, FormFieldThreesAllTimePeak),
                ThreesCurrentSeasonGamesPlayed:  h.getFormIntValue(r, FormFieldThreesCurrentGames),
                ThreesPreviousSeasonGamesPlayed: h.getFormIntValue(r, FormFieldThreesPreviousGames),
                Valid:                           h.getFormBoolValue(r, FormFieldValid),
        }
}</span>

// validateTrackerRequired validates required tracker fields
func (h *MigrationHandler) validateTrackerRequired(w http.ResponseWriter, tracker *usl.USLUserTracker) bool <span class="cov0" title="0">{
        if tracker.DiscordID == "" || tracker.URL == "" </span><span class="cov0" title="0">{
                log.Printf("[USL-HANDLER] Tracker validation failed: Discord=%s, URL=%s", tracker.DiscordID, tracker.URL)
                http.Error(w, "Discord ID and URL are required", http.StatusBadRequest)
                return false
        }</span>
        <span class="cov0" title="0">log.Printf("[USL-HANDLER] Tracker validation passed: Discord=%s", tracker.DiscordID)
        return true</span>
}

// logTrueSkillUpdateFailure logs structured failure information
func (h *MigrationHandler) logTrueSkillUpdateFailure(tracker *usl.USLUserTracker, errorMsg string) <span class="cov0" title="0">{
        log.Printf("[USL-TRUESKILL] WARNING: Update failed - Discord=%s, TrackerID=%d, Error=%s",
                tracker.DiscordID, tracker.ID, errorMsg)
        log.Printf("[USL-TRUESKILL] Tracker creation succeeded, TrueSkill update failed - manual intervention may be needed")
}</span>

// logTrueSkillUpdateSuccess logs structured success information
func (h *MigrationHandler) logTrueSkillUpdateSuccess(tracker *usl.USLUserTracker, mu, sigma float64) <span class="cov0" title="0">{
        log.Printf("[USL-TRUESKILL] SUCCESS: Calculated - Discord=%s, TrackerID=%d, Œº=%.1f, œÉ=%.2f",
                tracker.DiscordID, tracker.ID, mu, sigma)
}</span>

// logUSLSyncFailure logs structured USL sync failure information
func (h *MigrationHandler) logUSLSyncFailure(discordID string, err error) <span class="cov0" title="0">{
        log.Printf("[USL-TRUESKILL] WARNING: USL table sync failed - Discord=%s, Error=%v", discordID, err)
        log.Printf("[USL-TRUESKILL] Core tables updated successfully, USL tables inconsistent - manual sync required")
}</span>

// logUSLSyncSuccess logs structured USL sync success information
func (h *MigrationHandler) logUSLSyncSuccess(discordID string) <span class="cov0" title="0">{
        log.Printf("[USL-TRUESKILL] SUCCESS: Full integration completed - Discord=%s (Core ‚úì, USL ‚úì)", discordID)
}</span>

const (
        USL_DISCORD_GUILD_ID = "1390537743385231451" // USL Discord Guild ID
)

// MigrationHandler provides simplified handlers for USL-only operations
// This is a temporary migration solution - no multi-guild complexity
// AUTH NOTE: This handler no longer manages auth - that's handled by unified Discord OAuth in main.go
type MigrationHandler struct {
        uslRepo          *usl.USLRepository
        templates        *template.Template
        trueskillService *services.UserTrueSkillService
        config           *config.Config
}

func NewMigrationHandler(
        uslRepo *usl.USLRepository,
        templates *template.Template,
        trueskillService *services.UserTrueSkillService,
        config *config.Config,
) *MigrationHandler <span class="cov0" title="0">{
        return &amp;MigrationHandler{
                uslRepo:          uslRepo,
                templates:        templates,
                trueskillService: trueskillService,
                config:           config,
        }
}</span>

func (h *MigrationHandler) ListUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">users, err := h.uslRepo.GetAllUsers()
        if err != nil </span><span class="cov0" title="0">{
                h.handleDatabaseError(w, "load users", err)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title string
                Users []*usl.USLUser
                Query string
        }{
                Title: "USL Users",
                Users: users,
                Query: "", // Empty query for full user list
        }

        h.renderTemplate(w, TemplateUSLUsers, data)</span>
}

func (h *MigrationHandler) SearchUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">query := r.URL.Query().Get("q")
        if query == "" </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/usl/users", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">users, err := h.uslRepo.SearchUsers(query)
        if err != nil </span><span class="cov0" title="0">{
                h.handleDatabaseError(w, "search users", err)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title string
                Users []*usl.USLUser
                Query string
        }{
                Title: "USL User Search Results",
                Users: users,
                Query: query,
        }

        h.renderTemplate(w, TemplateUSLUsers, data)</span>
}

func (h *MigrationHandler) NewUserForm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title string
        }{
                Title: "Add USL User",
        }

        h.renderTemplate(w, TemplateUSLUserForm, data)</span>
}

func (h *MigrationHandler) CreateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid form data", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">name := h.getFormValue(r, FormFieldName)
        discordID := h.getFormValue(r, FormFieldDiscordID)
        active := h.getFormBoolValue(r, FormFieldActive)
        banned := h.getFormBoolValue(r, FormFieldBanned)

        if name == "" || discordID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Name and Discord ID are required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user, err := h.uslRepo.CreateUser(name, discordID, active, banned)
        if err != nil </span><span class="cov0" title="0">{
                h.handleDatabaseError(w, "create user", err)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("[USL-HANDLER] Created user: %s (ID: %d, Discord: %s)", user.Name, user.ID, user.DiscordID)
        http.Redirect(w, r, "/usl/users", http.StatusSeeOther)</span>
}

func (h *MigrationHandler) EditUserForm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := r.URL.Query().Get(string(FormFieldID))
        if userIDStr == "" </span><span class="cov0" title="0">{
                h.handleInvalidID(w, "User ID")
                return
        }</span>

        <span class="cov0" title="0">userID, err := h.parseUserID(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.handleParseError(w, "user ID")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.uslRepo.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[USL-HANDLER] User lookup failed: ID=%d, error=%v", userID, err)
                http.Error(w, "User not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title string
                User  *usl.USLUser
        }{
                Title: "Edit USL User",
                User:  user,
        }

        h.renderTemplate(w, TemplateUSLUserEditForm, data)</span>
}

func (h *MigrationHandler) UpdateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                h.handleInvalidFormData(w, err)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := h.getFormValue(r, FormFieldID)
        userID, err := h.parseUserID(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.handleParseError(w, "user ID")
                return
        }</span>

        <span class="cov0" title="0">name := h.getFormValue(r, FormFieldName)
        active := h.getFormBoolValue(r, FormFieldActive)
        banned := h.getFormBoolValue(r, FormFieldBanned)

        user, err := h.uslRepo.UpdateUser(userID, name, active, banned)
        if err != nil </span><span class="cov0" title="0">{
                h.handleDatabaseError(w, "update user", err)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("[USL-HANDLER] Updated user: %s (ID: %d, Discord: %s)", user.Name, user.ID, user.DiscordID)
        http.Redirect(w, r, "/usl/users", http.StatusSeeOther)</span>
}

func (h *MigrationHandler) DeleteUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := h.getFormValue(r, FormFieldID)
        userID, err := h.parseUserID(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.handleParseError(w, "user ID")
                return
        }</span>

        <span class="cov0" title="0">err = h.uslRepo.DeleteUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleDatabaseError(w, "delete user", err)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("[USL-HANDLER] Deleted user: ID=%d", userID)
        http.Redirect(w, r, "/usl/users", http.StatusSeeOther)</span>
}

func (h *MigrationHandler) ListTrackers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">trackers, err := h.uslRepo.GetAllTrackers()
        if err != nil </span><span class="cov0" title="0">{
                h.handleDatabaseError(w, "load trackers", err)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title    string
                Trackers []*usl.USLUserTracker
        }{
                Title:    "USL Trackers",
                Trackers: trackers,
        }

        h.renderTemplate(w, TemplateUSLTrackers, data)</span>
}

func (h *MigrationHandler) NewTrackerForm(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">users, err := h.uslRepo.GetAllUsers()
        if err != nil </span><span class="cov0" title="0">{
                h.handleDatabaseError(w, "load users", err)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title string
                Users []*usl.USLUser
        }{
                Title: "Add USL Tracker",
                Users: users,
        }

        h.renderTemplate(w, TemplateUSLTrackerForm, data)</span>
}

func (h *MigrationHandler) CreateTracker(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">if err := r.ParseForm(); err != nil </span><span class="cov0" title="0">{
                h.handleInvalidFormData(w, err)
                return
        }</span>

        <span class="cov0" title="0">tracker := h.buildTrackerFromForm(r)

        if !h.validateTrackerRequired(w, tracker) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">created, err := h.uslRepo.CreateTracker(tracker)
        if err != nil </span><span class="cov0" title="0">{
                h.handleDatabaseError(w, "create tracker", err)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("[USL-HANDLER] Created tracker: Discord=%s, ID=%d, URL=%s", created.DiscordID, created.ID, created.URL)

        h.performTrueSkillUpdate(created)

        http.Redirect(w, r, "/usl/trackers", http.StatusSeeOther)</span>
}

func (h *MigrationHandler) AdminDashboard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.uslRepo.GetStats()
        if err != nil </span><span class="cov0" title="0">{
                h.handleDatabaseError(w, "load dashboard", err)
                return
        }</span>

        // Create a mock guild for USL compatibility
        <span class="cov0" title="0">uslGuild := &amp;models.Guild{
                ID:             1,
                DiscordGuildID: USLDiscordGuildID,
                Name:           "USL",
                Slug:           "usl",
                Active:         true,
                Config:         models.GetDefaultGuildConfig(),
        }

        data := struct {
                Title string
                Guild *models.Guild
                Stats map[string]interface{}
        }{
                Title: "USL Admin Dashboard",
                Guild: uslGuild,
                Stats: stats,
        }

        h.renderTemplate(w, TemplateUSLAdminDashboard, data)</span>
}

func (h *MigrationHandler) ImportData(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Title string
        }{
                Title: "Import USL Data",
        }

        h.renderTemplate(w, TemplateUSLImport, data)</span>
}

func (h *MigrationHandler) ListUsersAPI(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">users, err := h.uslRepo.GetAllUsers()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to load users", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(users); err != nil </span><span class="cov0" title="0">{
                log.Printf("[USL-HANDLER] JSON encoding error for users API: %v", err)
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
        }</span>
}

func (h *MigrationHandler) ListTrackersAPI(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">trackers, err := h.uslRepo.GetAllTrackers()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to load trackers", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(trackers); err != nil </span><span class="cov0" title="0">{
                log.Printf("[USL-HANDLER] JSON encoding error for trackers API: %v", err)
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
        }</span>
}

func (h *MigrationHandler) GetLeaderboardAPI(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                h.handleMethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov0" title="0">users, err := h.uslRepo.GetLeaderboard()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to load leaderboard", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(users); err != nil </span><span class="cov0" title="0">{
                log.Printf("[USL-HANDLER] JSON encoding error for leaderboard API: %v", err)
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
        }</span>
}

// performTrueSkillUpdate handles TrueSkill calculation and synchronization with comprehensive error handling
func (h *MigrationHandler) performTrueSkillUpdate(tracker *usl.USLUserTracker) <span class="cov0" title="0">{
        if tracker == nil </span><span class="cov0" title="0">{
                log.Printf("[USL-TRUESKILL] ERROR: Cannot perform update - tracker is nil")
                return
        }</span>

        <span class="cov0" title="0">trackerData := h.mapUSLTrackerToTrackerData(tracker)
        log.Printf("[USL-TRUESKILL] Starting update - Discord=%s, TrackerID=%d", tracker.DiscordID, tracker.ID)

        result := h.trueskillService.UpdateUserTrueSkillFromTrackerData(trackerData)

        if !result.Success </span><span class="cov0" title="0">{
                h.logTrueSkillUpdateFailure(tracker, result.Error)
                return
        }</span>

        <span class="cov0" title="0">h.logTrueSkillUpdateSuccess(tracker, result.TrueSkillResult.Mu, result.TrueSkillResult.Sigma)

        err := h.uslRepo.UpdateUserTrueSkill(
                tracker.DiscordID,
                result.TrueSkillResult.Mu,
                result.TrueSkillResult.Sigma,
        )

        if err != nil </span><span class="cov0" title="0">{
                h.logUSLSyncFailure(tracker.DiscordID, err)
        }</span> else<span class="cov0" title="0"> {
                h.logUSLSyncSuccess(tracker.DiscordID)
        }</span>
}

// mapUSLTrackerToTrackerData converts USL tracker format to TrueSkill service input format
func (h *MigrationHandler) mapUSLTrackerToTrackerData(uslTracker *usl.USLUserTracker) *services.TrackerData <span class="cov8" title="1">{
        var lastUpdated time.Time
        if uslTracker.LastUpdated != nil &amp;&amp; *uslTracker.LastUpdated != "" </span><span class="cov8" title="1">{
                if parsed, err := time.Parse(time.RFC3339, *uslTracker.LastUpdated); err == nil </span><span class="cov8" title="1">{
                        lastUpdated = parsed
                }</span> else<span class="cov8" title="1"> {
                        lastUpdated = time.Now()
                }</span>
        } else<span class="cov8" title="1"> {
                lastUpdated = time.Now()
        }</span>

        <span class="cov8" title="1">return &amp;services.TrackerData{
                DiscordID:           uslTracker.DiscordID,
                URL:                 uslTracker.URL,
                OnesCurrentPeak:     uslTracker.OnesCurrentSeasonPeak,
                OnesCurrentGames:    uslTracker.OnesCurrentSeasonGamesPlayed,
                OnesPreviousPeak:    uslTracker.OnesPreviousSeasonPeak,
                OnesPreviousGames:   uslTracker.OnesPreviousSeasonGamesPlayed,
                TwosCurrentPeak:     uslTracker.TwosCurrentSeasonPeak,
                TwosCurrentGames:    uslTracker.TwosCurrentSeasonGamesPlayed,
                TwosPreviousPeak:    uslTracker.TwosPreviousSeasonPeak,
                TwosPreviousGames:   uslTracker.TwosPreviousSeasonGamesPlayed,
                ThreesCurrentPeak:   uslTracker.ThreesCurrentSeasonPeak,
                ThreesCurrentGames:  uslTracker.ThreesCurrentSeasonGamesPlayed,
                ThreesPreviousPeak:  uslTracker.ThreesPreviousSeasonPeak,
                ThreesPreviousGames: uslTracker.ThreesPreviousSeasonGamesPlayed,
                LastUpdated:         lastUpdated,
        }</span>
}

// NOTE: Authentication methods removed - now handled by unified Discord OAuth system in main.go

func (h *MigrationHandler) renderTemplate(w http.ResponseWriter, templateName TemplateName, data any) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        if err := h.templates.ExecuteTemplate(w, string(templateName), data); err != nil </span><span class="cov0" title="0">{
                log.Printf("[USL-HANDLER] Template rendering error: template=%s, error=%v", templateName, err)
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"
        "usl-server/internal/models"
        "usl-server/internal/repositories"
)

// V2TrackersHandler handles modern API requests for trackers with pagination, filtering, and bulk operations
type V2TrackersHandler struct {
        trackerRepo *repositories.TrackerRepository
}

// NewV2TrackersHandler creates a new V2 trackers handler
func NewV2TrackersHandler(trackerRepo *repositories.TrackerRepository) *V2TrackersHandler <span class="cov0" title="0">{
        return &amp;V2TrackersHandler{
                trackerRepo: trackerRepo,
        }
}</span>

// HandleTrackers handles the main /api/v2/trackers endpoint
func (h *V2TrackersHandler) HandleTrackers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                h.handleGetTrackers(w, r)</span>
        case http.MethodPost:<span class="cov0" title="0">
                h.handleCreateTracker(w, r)</span>
        default:<span class="cov0" title="0">
                h.writeErrorResponse(w, http.StatusMethodNotAllowed, msgMethodNotAllowed, nil)</span>
        }
}

// HandleTrackersBulk handles bulk operations on trackers
func (h *V2TrackersHandler) HandleTrackersBulk(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusMethodNotAllowed, msgMethodNotAllowed, nil)
                return
        }</span>

        <span class="cov0" title="0">bulkOperation, err := h.parseBulkOperationRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, msgInvalidRequestBody, map[string]string{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">response, err := h.trackerRepo.BulkUpdateTrackers(bulkOperation)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusInternalServerError, msgBulkOperationFailed, map[string]string{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.writeJSONResponse(w, http.StatusOK, response)</span>
}

// handleGetTrackers handles GET /api/v2/trackers with pagination and filtering
func (h *V2TrackersHandler) handleGetTrackers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestStartTime := time.Now()

        // Parse and validate request parameters
        paginationParams, trackerFilters, validationErr := h.parseAndValidateGetTrackersRequest(r)
        if validationErr != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, msgValidationFailed, validationErr)
                return
        }</span>

        // Retrieve paginated trackers from repository
        <span class="cov0" title="0">trackers, paginationMetadata, err := h.trackerRepo.GetTrackersPaginated(paginationParams, trackerFilters)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusInternalServerError, msgFailedToGetTrackers, map[string]string{"error": err.Error()})
                return
        }</span>

        // Build and send response
        <span class="cov0" title="0">response := h.buildPaginatedTrackersResponse(trackers, paginationMetadata, paginationParams, trackerFilters, requestStartTime)
        h.writeJSONResponse(w, http.StatusOK, response)</span>
}

// handleCreateTracker handles POST /api/v2/trackers
func (h *V2TrackersHandler) handleCreateTracker(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        trackerCreateRequest, err := h.parseTrackerCreateRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, msgInvalidRequestBody, map[string]string{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">createdTracker, err := h.trackerRepo.CreateTracker(*trackerCreateRequest)
        if err != nil </span><span class="cov0" title="0">{
                h.handleTrackerCreationError(w, err, trackerCreateRequest.DiscordID)
                return
        }</span>

        <span class="cov0" title="0">h.writeJSONResponse(w, http.StatusCreated, map[string]interface{}{
                "tracker": createdTracker,
                "message": msgTrackerCreatedSuccessfully,
        })</span>
}

// writeJSONResponse writes a JSON response with proper headers
func (h *V2TrackersHandler) writeJSONResponse(w http.ResponseWriter, status int, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Cache-Control", "no-cache")
        w.WriteHeader(status)

        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                // If encoding fails, log error but don't try to write another response
                fmt.Printf("[ERROR] Failed to encode JSON response: %v\n", err)
        }</span>
}

// writeErrorResponse writes a standardized error response
func (h *V2TrackersHandler) writeErrorResponse(w http.ResponseWriter, status int, message string, details interface{}) <span class="cov0" title="0">{
        errorResponse := map[string]interface{}{
                "error":     message,
                "status":    status,
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        }

        if details != nil </span><span class="cov0" title="0">{
                errorResponse["details"] = details
        }</span>

        <span class="cov0" title="0">h.writeJSONResponse(w, status, errorResponse)</span>
}

// Helper methods for improved code organization

// parseBulkOperationRequest parses a bulk operation request from HTTP body
func (h *V2TrackersHandler) parseBulkOperationRequest(r *http.Request) (*models.BulkOperation, error) <span class="cov0" title="0">{
        var bulkOperation models.BulkOperation
        if err := json.NewDecoder(r.Body).Decode(&amp;bulkOperation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;bulkOperation, nil</span>
}

// parseTrackerCreateRequest parses a tracker creation request from HTTP body
func (h *V2TrackersHandler) parseTrackerCreateRequest(r *http.Request) (*models.TrackerCreateRequest, error) <span class="cov0" title="0">{
        var trackerCreateRequest models.TrackerCreateRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;trackerCreateRequest); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;trackerCreateRequest, nil</span>
}

// parseAndValidateGetTrackersRequest parses and validates parameters for GET trackers request
func (h *V2TrackersHandler) parseAndValidateGetTrackersRequest(r *http.Request) (*models.PaginationParams, *models.TrackerFilters, interface{}) <span class="cov0" title="0">{
        requestParser := models.NewRequestParser()
        paginationParams := requestParser.ParsePaginationParams(r)
        trackerFilters := requestParser.ParseTrackerFilters(r)

        // Check for validation errors
        if requestParser.HasErrors() </span><span class="cov0" title="0">{
                return nil, nil, map[string]interface{}{
                        "errors": requestParser.GetErrors(),
                }
        }</span>

        // Validate sort field
        <span class="cov0" title="0">if paginationParams.Sort != "" &amp;&amp; !models.ValidateTrackerSortField(paginationParams.Sort) </span><span class="cov0" title="0">{
                return nil, nil, map[string]string{
                        "field":   paginationParams.Sort,
                        "allowed": allowedTrackerSortFields,
                }
        }</span>

        <span class="cov0" title="0">return paginationParams, trackerFilters, nil</span>
}

// buildPaginatedTrackersResponse constructs a paginated response for trackers
func (h *V2TrackersHandler) buildPaginatedTrackersResponse(
        trackers []*models.Tracker,
        paginationMetadata *models.PaginationMetadata,
        paginationParams *models.PaginationParams,
        trackerFilters *models.TrackerFilters,
        requestStartTime time.Time,
) models.PaginatedResponse[*models.Tracker] <span class="cov0" title="0">{
        responseMetadata := models.ResponseMetadata{
                Sort:           paginationParams.Sort,
                Order:          paginationParams.Order,
                FiltersApplied: trackerFilters.ToFiltersApplied(),
                QueryTime:      time.Since(requestStartTime).String(),
        }

        return models.PaginatedResponse[*models.Tracker]{
                Data:       trackers,
                Pagination: *paginationMetadata,
                Meta:       responseMetadata,
        }
}</span>

// handleTrackerCreationError handles errors that occur during tracker creation
func (h *V2TrackersHandler) handleTrackerCreationError(w http.ResponseWriter, err error, discordID string) <span class="cov0" title="0">{
        errorMessage := err.Error()
        expectedConflictMessage := fmt.Sprintf("tracker with Discord ID %s already exists", discordID)

        if errorMessage == expectedConflictMessage </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusConflict, msgTrackerAlreadyExists, map[string]string{"discord_id": discordID})
                return
        }</span>

        <span class="cov0" title="0">h.writeErrorResponse(w, http.StatusInternalServerError, msgFailedToCreateTracker, map[string]string{"error": errorMessage})</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"
        "usl-server/internal/models"
        "usl-server/internal/repositories"
)

// V2UsersHandler handles modern API requests for users with pagination, filtering, and bulk operations
type V2UsersHandler struct {
        userRepo *repositories.UserRepository
}

// NewV2UsersHandler creates a new V2 users handler
func NewV2UsersHandler(userRepo *repositories.UserRepository) *V2UsersHandler <span class="cov0" title="0">{
        return &amp;V2UsersHandler{
                userRepo: userRepo,
        }
}</span>

// HandleUsers handles the main /api/v2/users endpoint
func (h *V2UsersHandler) HandleUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov0" title="0">
                h.handleGetUsers(w, r)</span>
        case http.MethodPost:<span class="cov0" title="0">
                h.handleCreateUser(w, r)</span>
        default:<span class="cov0" title="0">
                h.writeErrorResponse(w, http.StatusMethodNotAllowed, msgMethodNotAllowed, nil)</span>
        }
}

// HandleUsersBulk handles bulk operations on users
func (h *V2UsersHandler) HandleUsersBulk(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusMethodNotAllowed, msgMethodNotAllowed, nil)
                return
        }</span>

        <span class="cov0" title="0">bulkOperation, err := h.parseBulkOperationRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, msgInvalidRequestBody, map[string]string{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">response, err := h.userRepo.BulkUpdateUsers(bulkOperation)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusInternalServerError, msgBulkOperationFailed, map[string]string{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.writeJSONResponse(w, http.StatusOK, response)</span>
}

// handleGetUsers handles GET /api/v2/users with pagination and filtering
func (h *V2UsersHandler) handleGetUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        requestStartTime := time.Now()

        // Parse and validate request parameters
        paginationParams, userFilters, validationErr := h.parseAndValidateGetUsersRequest(r)
        if validationErr != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, msgValidationFailed, validationErr)
                return
        }</span>

        // Retrieve paginated users from repository
        <span class="cov0" title="0">users, paginationMetadata, err := h.userRepo.GetUsersPaginated(paginationParams, userFilters)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusInternalServerError, msgFailedToGetUsers, map[string]string{"error": err.Error()})
                return
        }</span>

        // Build and send response
        <span class="cov0" title="0">response := h.buildPaginatedUsersResponse(users, paginationMetadata, paginationParams, userFilters, requestStartTime)
        h.writeJSONResponse(w, http.StatusOK, response)</span>
}

// handleCreateUser handles POST /api/v2/users
func (h *V2UsersHandler) handleCreateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userCreateRequest, err := h.parseUserCreateRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusBadRequest, msgInvalidRequestBody, map[string]string{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">createdUser, err := h.userRepo.CreateUser(*userCreateRequest)
        if err != nil </span><span class="cov0" title="0">{
                h.handleUserCreationError(w, err, userCreateRequest.DiscordID)
                return
        }</span>

        <span class="cov0" title="0">h.writeJSONResponse(w, http.StatusCreated, map[string]interface{}{
                "user":    createdUser,
                "message": msgUserCreatedSuccessfully,
        })</span>
}

// writeJSONResponse writes a JSON response with proper headers
func (h *V2UsersHandler) writeJSONResponse(w http.ResponseWriter, status int, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Cache-Control", "no-cache")
        w.WriteHeader(status)

        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                // If encoding fails, log error but don't try to write another response
                fmt.Printf("[ERROR] Failed to encode JSON response: %v\n", err)
        }</span>
}

// writeErrorResponse writes a standardized error response
func (h *V2UsersHandler) writeErrorResponse(w http.ResponseWriter, status int, message string, details interface{}) <span class="cov0" title="0">{
        errorResponse := map[string]interface{}{
                "error":     message,
                "status":    status,
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        }

        if details != nil </span><span class="cov0" title="0">{
                errorResponse["details"] = details
        }</span>

        <span class="cov0" title="0">h.writeJSONResponse(w, status, errorResponse)</span>
}

// Helper methods for improved code organization

// parseBulkOperationRequest parses a bulk operation request from HTTP body
func (h *V2UsersHandler) parseBulkOperationRequest(r *http.Request) (*models.BulkOperation, error) <span class="cov0" title="0">{
        var bulkOperation models.BulkOperation
        if err := json.NewDecoder(r.Body).Decode(&amp;bulkOperation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;bulkOperation, nil</span>
}

// parseUserCreateRequest parses a user creation request from HTTP body
func (h *V2UsersHandler) parseUserCreateRequest(r *http.Request) (*models.UserCreateRequest, error) <span class="cov0" title="0">{
        var userCreateRequest models.UserCreateRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;userCreateRequest); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;userCreateRequest, nil</span>
}

// parseAndValidateGetUsersRequest parses and validates parameters for GET users request
func (h *V2UsersHandler) parseAndValidateGetUsersRequest(r *http.Request) (*models.PaginationParams, *models.UserFilters, interface{}) <span class="cov0" title="0">{
        requestParser := models.NewRequestParser()
        paginationParams := requestParser.ParsePaginationParams(r)
        userFilters := requestParser.ParseUserFilters(r)

        // Check for validation errors
        if requestParser.HasErrors() </span><span class="cov0" title="0">{
                return nil, nil, map[string]interface{}{
                        "errors": requestParser.GetErrors(),
                }
        }</span>

        // Validate sort field
        <span class="cov0" title="0">if paginationParams.Sort != "" &amp;&amp; !models.ValidateUserSortField(paginationParams.Sort) </span><span class="cov0" title="0">{
                return nil, nil, map[string]string{
                        "field":   paginationParams.Sort,
                        "allowed": allowedUserSortFields,
                }
        }</span>

        <span class="cov0" title="0">return paginationParams, userFilters, nil</span>
}

// buildPaginatedUsersResponse constructs a paginated response for users
func (h *V2UsersHandler) buildPaginatedUsersResponse(
        users []*models.User,
        paginationMetadata *models.PaginationMetadata,
        paginationParams *models.PaginationParams,
        userFilters *models.UserFilters,
        requestStartTime time.Time,
) models.PaginatedResponse[*models.User] <span class="cov0" title="0">{
        responseMetadata := models.ResponseMetadata{
                Sort:           paginationParams.Sort,
                Order:          paginationParams.Order,
                FiltersApplied: userFilters.ToFiltersApplied(),
                QueryTime:      time.Since(requestStartTime).String(),
        }

        return models.PaginatedResponse[*models.User]{
                Data:       users,
                Pagination: *paginationMetadata,
                Meta:       responseMetadata,
        }
}</span>

// handleUserCreationError handles errors that occur during user creation
func (h *V2UsersHandler) handleUserCreationError(w http.ResponseWriter, err error, discordID string) <span class="cov0" title="0">{
        errorMessage := err.Error()
        expectedConflictMessage := fmt.Sprintf("user with Discord ID %s already exists", discordID)

        if errorMessage == expectedConflictMessage </span><span class="cov0" title="0">{
                h.writeErrorResponse(w, http.StatusConflict, msgUserAlreadyExists, map[string]string{"discord_id": discordID})
                return
        }</span>

        <span class="cov0" title="0">h.writeErrorResponse(w, http.StatusInternalServerError, msgFailedToCreateUser, map[string]string{"error": errorMessage})</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package usl

import (
        "time"
        "usl-server/internal/config"
)

// USLUser represents a user in the USL-specific migration table
// Mirrors the Google Sheets User.csv structure exactly
type USLUser struct {
        ID                   int64     `json:"id" db:"id"`
        Name                 string    `json:"name" db:"name"`
        DiscordID            string    `json:"discord_id" db:"discord_id"`
        Active               bool      `json:"active" db:"active"`
        Banned               bool      `json:"banned" db:"banned"`
        MMR                  int       `json:"mmr" db:"mmr"`
        TrueSkillMu          float64   `json:"trueskill_mu" db:"trueskill_mu"`
        TrueSkillSigma       float64   `json:"trueskill_sigma" db:"trueskill_sigma"`
        TrueSkillLastUpdated *string   `json:"trueskill_last_updated" db:"trueskill_last_updated"`
        CreatedAt            time.Time `json:"created_at" db:"created_at"`
        UpdatedAt            time.Time `json:"updated_at" db:"updated_at"`
}

func (u *USLUser) GetTrueSkillLastUpdatedFormatted() string <span class="cov0" title="0">{
        if u.TrueSkillLastUpdated == nil || *u.TrueSkillLastUpdated == "" </span><span class="cov0" title="0">{
                return "Never"
        }</span>
        <span class="cov0" title="0">return *u.TrueSkillLastUpdated</span>
}

func (t *USLUserTracker) GetLastUpdatedFormatted() string <span class="cov0" title="0">{
        if t.LastUpdated == nil || *t.LastUpdated == "" </span><span class="cov0" title="0">{
                return "Never"
        }</span>
        <span class="cov0" title="0">return *t.LastUpdated</span>
}

// USLUserTracker represents a user tracker in the USL-specific migration table
// Mirrors the Google Sheets UserTracker.csv structure exactly
type USLUserTracker struct {
        ID                              int64     `json:"id" db:"id"`
        DiscordID                       string    `json:"discord_id" db:"discord_id"`
        URL                             string    `json:"url" db:"url"`
        OnesCurrentSeasonPeak           int       `json:"ones_current_season_peak" db:"ones_current_season_peak"`
        OnesPreviousSeasonPeak          int       `json:"ones_previous_season_peak" db:"ones_previous_season_peak"`
        OnesAllTimePeak                 int       `json:"ones_all_time_peak" db:"ones_all_time_peak"`
        OnesCurrentSeasonGamesPlayed    int       `json:"ones_current_season_games_played" db:"ones_current_season_games_played"`
        OnesPreviousSeasonGamesPlayed   int       `json:"ones_previous_season_games_played" db:"ones_previous_season_games_played"`
        TwosCurrentSeasonPeak           int       `json:"twos_current_season_peak" db:"twos_current_season_peak"`
        TwosPreviousSeasonPeak          int       `json:"twos_previous_season_peak" db:"twos_previous_season_peak"`
        TwosAllTimePeak                 int       `json:"twos_all_time_peak" db:"twos_all_time_peak"`
        TwosCurrentSeasonGamesPlayed    int       `json:"twos_current_season_games_played" db:"twos_current_season_games_played"`
        TwosPreviousSeasonGamesPlayed   int       `json:"twos_previous_season_games_played" db:"twos_previous_season_games_played"`
        ThreesCurrentSeasonPeak         int       `json:"threes_current_season_peak" db:"threes_current_season_peak"`
        ThreesPreviousSeasonPeak        int       `json:"threes_previous_season_peak" db:"threes_previous_season_peak"`
        ThreesAllTimePeak               int       `json:"threes_all_time_peak" db:"threes_all_time_peak"`
        ThreesCurrentSeasonGamesPlayed  int       `json:"threes_current_season_games_played" db:"threes_current_season_games_played"`
        ThreesPreviousSeasonGamesPlayed int       `json:"threes_previous_season_games_played" db:"threes_previous_season_games_played"`
        LastUpdated                     *string   `json:"last_updated" db:"last_updated"`
        Valid                           bool      `json:"valid" db:"valid"`
        MMR                             int       `json:"mmr" db:"mmr"`
        CreatedAt                       time.Time `json:"created_at" db:"created_at"`
        UpdatedAt                       time.Time `json:"updated_at" db:"updated_at"`
}

type USLUserCSV struct {
        Name                 string `csv:"name"`
        DiscordID            string `csv:"discord id"`
        Active               string `csv:"active"`
        Banned               string `csv:"banned"`
        MMR                  string `csv:"mmr"`
        TrueSkillMu          string `csv:"trueskill_mu"`
        TrueSkillSigma       string `csv:"trueskill_sigma"`
        TrueSkillLastUpdated string `csv:"trueskill_last_updated"`
}

type USLUserTrackerCSV struct {
        DiscordID                       string `csv:"discord id"`
        URL                             string `csv:"url"`
        OnesCurrentSeasonPeak           string `csv:"ones current season peak"`
        OnesPreviousSeasonPeak          string `csv:"ones previous season peak"`
        OnesAllTimePeak                 string `csv:"ones all time peak"`
        OnesCurrentSeasonGamesPlayed    string `csv:"ones current season games played"`
        OnesPreviousSeasonGamesPlayed   string `csv:"ones previous season games played"`
        TwosCurrentSeasonPeak           string `csv:"twos current season peak"`
        TwosPreviousSeasonPeak          string `csv:"twos previous season peak"`
        TwosAllTimePeak                 string `csv:"twos all time peak"`
        TwosCurrentSeasonGamesPlayed    string `csv:"twos current season games played"`
        TwosPreviousSeasonGamesPlayed   string `csv:"twos previous season games played"`
        ThreesCurrentSeasonPeak         string `csv:"threes current season peak"`
        ThreesPreviousSeasonPeak        string `csv:"threes previous season peak"`
        ThreesAllTimePeak               string `csv:"threes all time peak"`
        ThreesCurrentSeasonGamesPlayed  string `csv:"threes current season games played"`
        ThreesPreviousSeasonGamesPlayed string `csv:"threes previous season games played"`
        LastUpdated                     string `csv:"last updated"`
        Valid                           string `csv:"valid"`
        MMR                             string `csv:"mmr"`
}

// IsValidForPlay checks if user can participate in matches
func (u *USLUser) IsValidForPlay() bool <span class="cov0" title="0">{
        return u.Active &amp;&amp; !u.Banned
}</span>

// HasTrueSkillData checks if the user has been processed by TrueSkill engine
func (u *USLUser) HasTrueSkillData(cfg *config.Config) bool <span class="cov0" title="0">{
        defaultMu, defaultSigma := cfg.GetTrueSkillDefaults()
        return u.TrueSkillMu != defaultMu || u.TrueSkillSigma != defaultSigma
}</span>

func (u *USLUser) DisplayName() string <span class="cov0" title="0">{
        if u.Name == "" </span><span class="cov0" title="0">{
                return u.DiscordID
        }</span>
        <span class="cov0" title="0">return u.Name</span>
}

func (t *USLUserTracker) IsValidTracker() bool <span class="cov0" title="0">{
        return t.Valid
}</span>

func (t *USLUserTracker) TotalGames() int <span class="cov0" title="0">{
        return t.OnesCurrentSeasonGamesPlayed + t.TwosCurrentSeasonGamesPlayed + t.ThreesCurrentSeasonGamesPlayed
}</span>

// HasEnoughGames checks if tracker has sufficient games for MMR calculation
func (t *USLUserTracker) HasEnoughGames(cfg *config.Config) bool <span class="cov0" title="0">{
        return t.TotalGames() &gt;= cfg.MMR.MinGamesThreshold
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package usl

import (
        "fmt"
        "log/slog"
        "time"
        "usl-server/internal/config"

        "github.com/supabase-community/postgrest-go"
        "github.com/supabase-community/supabase-go"
)

// USLRepository provides simple, direct access to USL-specific tables
// No guild complexity, no abstractions - just basic CRUD operations
type USLRepository struct {
        client *supabase.Client
        config *config.Config
        logger *slog.Logger
}

func NewUSLRepository(client *supabase.Client, config *config.Config, logger *slog.Logger) *USLRepository <span class="cov0" title="0">{
        return &amp;USLRepository{
                client: client,
                config: config,
                logger: logger.With("component", "usl_repository"),
        }
}</span>

func (r *USLRepository) GetAllUsers() ([]*USLUser, error) <span class="cov0" title="0">{
        var users []*USLUser

        _, err := r.client.From("usl_users").
                Select("*", "", false).
                Order("trueskill_mu", &amp;postgrest.OrderOpts{Ascending: false}).
                ExecuteTo(&amp;users)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all users: %w", err)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

func (r *USLRepository) SearchUsers(query string) ([]*USLUser, error) <span class="cov0" title="0">{
        var users []*USLUser

        _, err := r.client.From("usl_users").
                Select("*", "", false).
                Or(fmt.Sprintf("name.ilike.%%%s%%,discord_id.eq.%s", query, query), "").
                Order("trueskill_mu", &amp;postgrest.OrderOpts{Ascending: false}).
                ExecuteTo(&amp;users)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search users: %w", err)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

func (r *USLRepository) GetUserByID(id int64) (*USLUser, error) <span class="cov0" title="0">{
        var user USLUser

        _, err := r.client.From("usl_users").
                Select("*", "", false).
                Eq("id", fmt.Sprintf("%d", id)).
                Single().
                ExecuteTo(&amp;user)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user by ID %d: %w", id, err)
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *USLRepository) GetUserByDiscordID(discordID string) (*USLUser, error) <span class="cov0" title="0">{
        var user USLUser

        _, err := r.client.From("usl_users").
                Select("*", "", false).
                Eq("discord_id", discordID).
                Single().
                ExecuteTo(&amp;user)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user by Discord ID %s: %w", discordID, err)
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *USLRepository) CreateUser(name, discordID string, active, banned bool) (*USLUser, error) <span class="cov0" title="0">{
        insertData := map[string]interface{}{
                "name":       name,
                "discord_id": discordID,
                "active":     active,
                "banned":     banned,
        }

        var user USLUser
        _, err := r.client.From("usl_users").
                Insert(insertData, false, "", "", "").
                Single().
                ExecuteTo(&amp;user)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *USLRepository) UpdateUser(id int64, name string, active, banned bool) (*USLUser, error) <span class="cov0" title="0">{
        updateData := map[string]interface{}{
                "name":   name,
                "active": active,
                "banned": banned,
        }

        var user USLUser
        _, err := r.client.From("usl_users").
                Update(updateData, "", "").
                Eq("id", fmt.Sprintf("%d", id)).
                Single().
                ExecuteTo(&amp;user)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user %d: %w", id, err)
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *USLRepository) DeleteUser(id int64) error <span class="cov0" title="0">{
        _, _, err := r.client.From("usl_users").
                Delete("", "").
                Eq("id", fmt.Sprintf("%d", id)).
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete user %d: %w", id, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *USLRepository) GetAllTrackers() ([]*USLUserTracker, error) <span class="cov0" title="0">{
        var trackers []*USLUserTracker

        _, err := r.client.From("usl_user_trackers").
                Select("*", "", false).
                Order("mmr", &amp;postgrest.OrderOpts{Ascending: false}).
                ExecuteTo(&amp;trackers)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all trackers: %w", err)
        }</span>

        <span class="cov0" title="0">return trackers, nil</span>
}

func (r *USLRepository) GetValidTrackers() ([]*USLUserTracker, error) <span class="cov0" title="0">{
        var trackers []*USLUserTracker

        _, err := r.client.From("usl_user_trackers").
                Select("*", "", false).
                Eq("valid", "true").
                Order("mmr", &amp;postgrest.OrderOpts{Ascending: false}).
                ExecuteTo(&amp;trackers)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get valid trackers: %w", err)
        }</span>

        <span class="cov0" title="0">return trackers, nil</span>
}

func (r *USLRepository) GetTrackersByDiscordID(discordID string) ([]*USLUserTracker, error) <span class="cov0" title="0">{
        var trackers []*USLUserTracker

        _, err := r.client.From("usl_user_trackers").
                Select("*", "", false).
                Eq("discord_id", discordID).
                Order("created_at", &amp;postgrest.OrderOpts{Ascending: false}).
                ExecuteTo(&amp;trackers)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trackers for Discord ID %s: %w", discordID, err)
        }</span>

        <span class="cov0" title="0">return trackers, nil</span>
}

func (r *USLRepository) CreateTracker(tracker *USLUserTracker) (*USLUserTracker, error) <span class="cov0" title="0">{
        insertData := map[string]interface{}{
                "discord_id":                          tracker.DiscordID,
                "url":                                 tracker.URL,
                "ones_current_season_peak":            tracker.OnesCurrentSeasonPeak,
                "ones_previous_season_peak":           tracker.OnesPreviousSeasonPeak,
                "ones_all_time_peak":                  tracker.OnesAllTimePeak,
                "ones_current_season_games_played":    tracker.OnesCurrentSeasonGamesPlayed,
                "ones_previous_season_games_played":   tracker.OnesPreviousSeasonGamesPlayed,
                "twos_current_season_peak":            tracker.TwosCurrentSeasonPeak,
                "twos_previous_season_peak":           tracker.TwosPreviousSeasonPeak,
                "twos_all_time_peak":                  tracker.TwosAllTimePeak,
                "twos_current_season_games_played":    tracker.TwosCurrentSeasonGamesPlayed,
                "twos_previous_season_games_played":   tracker.TwosPreviousSeasonGamesPlayed,
                "threes_current_season_peak":          tracker.ThreesCurrentSeasonPeak,
                "threes_previous_season_peak":         tracker.ThreesPreviousSeasonPeak,
                "threes_all_time_peak":                tracker.ThreesAllTimePeak,
                "threes_current_season_games_played":  tracker.ThreesCurrentSeasonGamesPlayed,
                "threes_previous_season_games_played": tracker.ThreesPreviousSeasonGamesPlayed,
                "last_updated":                        tracker.LastUpdated,
                "valid":                               tracker.Valid,
                "mmr":                                 tracker.MMR,
        }

        var created USLUserTracker
        _, err := r.client.From("usl_user_trackers").
                Insert(insertData, false, "", "", "").
                Single().
                ExecuteTo(&amp;created)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create tracker: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;created, nil</span>
}

func (r *USLRepository) GetUsersWithTrackers() ([]*USLUser, map[string][]*USLUserTracker, error) <span class="cov0" title="0">{
        users, err := r.GetAllUsers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get users: %w", err)
        }</span>

        <span class="cov0" title="0">allTrackers, err := r.GetAllTrackers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get trackers: %w", err)
        }</span>

        <span class="cov0" title="0">trackersByDiscord := make(map[string][]*USLUserTracker)
        for _, tracker := range allTrackers </span><span class="cov0" title="0">{
                trackersByDiscord[tracker.DiscordID] = append(trackersByDiscord[tracker.DiscordID], tracker)
        }</span>

        <span class="cov0" title="0">return users, trackersByDiscord, nil</span>
}

func (r *USLRepository) GetLeaderboard() ([]*USLUser, error) <span class="cov0" title="0">{
        var users []*USLUser

        _, err := r.client.From("usl_users").
                Select("*", "", false).
                Eq("active", "true").
                Order("trueskill_mu", &amp;postgrest.OrderOpts{Ascending: false}).
                ExecuteTo(&amp;users)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get leaderboard: %w", err)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

func (r *USLRepository) GetStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        r.logger.Info("Getting USL stats")

        users, err := r.GetAllUsers()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get users for stats", "error", err)
                return nil, fmt.Errorf("failed to get users for stats: %w", err)
        }</span>
        <span class="cov0" title="0">r.logger.Info("Retrieved users for stats", "count", len(users))

        trackers, err := r.GetAllTrackers()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Failed to get trackers for stats", "error", err)
                return nil, fmt.Errorf("failed to get trackers for stats: %w", err)
        }</span>
        <span class="cov0" title="0">r.logger.Info("Retrieved trackers for stats", "count", len(trackers))

        activeUsers := 0
        bannedUsers := 0
        validTrackers := 0
        totalTrueSkillMu := 0.0

        for _, user := range users </span><span class="cov0" title="0">{
                if user.Active </span><span class="cov0" title="0">{
                        activeUsers++
                }</span>
                <span class="cov0" title="0">if user.Banned </span><span class="cov0" title="0">{
                        bannedUsers++
                }</span>
                <span class="cov0" title="0">totalTrueSkillMu += user.TrueSkillMu</span>
        }

        <span class="cov0" title="0">for _, tracker := range trackers </span><span class="cov0" title="0">{
                if tracker.Valid </span><span class="cov0" title="0">{
                        validTrackers++
                }</span>
        }

        <span class="cov0" title="0">averageTrueSkillMu := 0.0
        if len(users) &gt; 0 </span><span class="cov0" title="0">{
                averageTrueSkillMu = totalTrueSkillMu / float64(len(users))
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "total_users":          len(users),
                "active_users":         activeUsers,
                "banned_users":         bannedUsers,
                "total_trackers":       len(trackers),
                "valid_trackers":       validTrackers,
                "average_trueskill_mu": averageTrueSkillMu,
        }, nil</span>
}

// UpdateUserTrueSkill updates TrueSkill values for a user in USL tables
func (r *USLRepository) UpdateUserTrueSkill(discordID string, mu, sigma float64) error <span class="cov0" title="0">{
        updateData := map[string]interface{}{
                "trueskill_mu":           mu,
                "trueskill_sigma":        sigma,
                "trueskill_last_updated": time.Now().Format(time.RFC3339),
        }

        _, _, err := r.client.From("usl_users").
                Update(updateData, "", "").
                Eq("discord_id", discordID).
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update TrueSkill for user %s: %w", discordID, err)
        }</span>

        <span class="cov0" title="0">r.logger.Info("Updated USL user TrueSkill values",
                "discord_id", discordID,
                "mu", mu,
                "sigma", sigma)

        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
